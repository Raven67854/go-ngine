package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	uio "github.com/metaleap/go-util/io"
)

type shaderSrc struct {
	name, src string
}

type shaderSrcSortable []shaderSrc

func (me shaderSrcSortable) Swap(i, j int)      { me[i], me[j] = me[j], me[i] }
func (me shaderSrcSortable) Len() int           { return len(me) }
func (me shaderSrcSortable) Less(i, j int) bool { return me[i].name < me[j].name }

type shaderSrcSortables struct {
	vert, tessCtl, tessEval, geo, frag, comp shaderSrcSortable
}

func (me shaderSrcSortables) mapAll() map[string]shaderSrcSortable {
	return map[string]shaderSrcSortable{"Vertex": me.vert, "TessCtl": me.tessCtl, "TessEval": me.tessEval, "Geometry": me.geo, "Fragment": me.frag, "Compute": me.comp}
}

func collectShaders(srcDirPath string, allShaders *shaderSrcSortables, incShaders map[string]string, stripComments bool) {
	var (
		fileInfos                                                   []os.FileInfo
		fileName, shaderSource                                      string
		isInc, isVert, isTessCtl, isTessEval, isGeo, isFrag, isComp bool
		pos1, pos2                                                  int
	)
	if src, err := os.Open(srcDirPath); err == nil {
		fileInfos, err = src.Readdir(0)
		src.Close()
		if err == nil {
			for _, fileInfo := range fileInfos {
				fileName = fileInfo.Name()
				if fileInfo.IsDir() {
					collectShaders(filepath.Join(srcDirPath, fileName), allShaders, incShaders, stripComments)
				} else {
					isInc, isVert, isTessCtl, isTessEval, isGeo, isFrag, isComp = strings.HasSuffix(fileName, ".glsl"), strings.HasSuffix(fileName, ".glvs"), strings.HasSuffix(fileName, ".gltc"), strings.HasSuffix(fileName, ".glte"), strings.HasSuffix(fileName, ".glgs"), strings.HasSuffix(fileName, ".glfs"), strings.HasSuffix(fileName, ".glcs")
					if isInc || isVert || isTessCtl || isTessEval || isGeo || isFrag || isComp {
						if shaderSource = uio.ReadTextFile(filepath.Join(srcDirPath, fileName), false, ""); len(shaderSource) > 0 {
							if stripComments {
								for {
									if pos1, pos2 = strings.Index(shaderSource, "/*"), strings.Index(shaderSource, "*/"); (pos1 < 0) || (pos2 < pos1) {
										break
									}
									shaderSource = shaderSource[0:pos1] + shaderSource[pos2+2:]
								}
							}
							if isInc {
								incShaders[fileName] = shaderSource
							}
							if isVert {
								allShaders.vert = append(allShaders.vert, shaderSrc{fileName, shaderSource})
							}
							if isTessCtl {
								allShaders.tessCtl = append(allShaders.tessCtl, shaderSrc{fileName, shaderSource})
							}
							if isTessEval {
								allShaders.tessEval = append(allShaders.tessEval, shaderSrc{fileName, shaderSource})
							}
							if isGeo {
								allShaders.geo = append(allShaders.geo, shaderSrc{fileName, shaderSource})
							}
							if isFrag {
								allShaders.frag = append(allShaders.frag, shaderSrc{fileName, shaderSource})
							}
							if isComp {
								allShaders.comp = append(allShaders.comp, shaderSrc{fileName, shaderSource})
							}
						}
					}
				}
			}
		}
	}
}

func generateShadersFile(srcDirPath, outFilePath, pkgName string, stripComments bool) (err error) {
	var (
		shaderSource       shaderSrc
		allNames           []string
		shaderName, tmpSrc string
	)
	newSrc := "package " + pkgName + "\n\n//\tGenerated by ng-buildrun from files in " + srcDirPath + "\nfunc init() {\n\tglc.progMan.Reset()\n\tglc.shaderMan.init()\n"
	allShaders := shaderSrcSortables{shaderSrcSortable{}, shaderSrcSortable{}, shaderSrcSortable{}, shaderSrcSortable{}, shaderSrcSortable{}, shaderSrcSortable{}}
	incShaders := map[string]string{}
	oldSrc := uio.ReadTextFile(outFilePath, false, "")
	collectShaders(srcDirPath, &allShaders, incShaders, stripComments)
	sort.Sort(allShaders.comp)
	sort.Sort(allShaders.frag)
	sort.Sort(allShaders.geo)
	sort.Sort(allShaders.tessCtl)
	sort.Sort(allShaders.tessEval)
	sort.Sort(allShaders.vert)
	for varName, shaderSrcItem := range allShaders.mapAll() {
		for _, shaderSource = range shaderSrcItem {
			if shaderName = shaderSource.name[:strings.LastIndex(shaderSource.name, ".")]; !inSlice(allNames, shaderName) {
				allNames = append(allNames, shaderName)
			}
			newSrc += fmt.Sprintf("\tglc.progMan.RawSources.%s[\"%s\"] = %#v\n", varName, shaderName, includeShaders(shaderSource.name, shaderSource.src, incShaders))
		}
	}
	for shaderName, tmpSrc = range incShaders {
		newSrc += fmt.Sprintf("\tglc.shaderMan.rawSources[%#v] = %#v\n", shaderName[:strings.Index(shaderName, ".")], tmpSrc)
	}
	if newSrc += fmt.Sprintf("\tglc.progMan.Names = %#v\n}\n", allNames); newSrc != oldSrc {
		err = uio.WriteTextFile(outFilePath, newSrc)
	}
	return
}

func includeShaders(fileName, shaderSource string, incShaders map[string]string) string {
	const linePrefix = "#pragma incl "
	var (
		str      string
		i        int
		includes []string
	)
	lines := strings.Split(shaderSource, "\n")
	for i, str = range lines {
		if strings.HasPrefix(str, linePrefix) {
			includes = strings.Split(str[len(linePrefix):], " ")
			break
		}
	}
	if len(includes) > 0 {
		shaderSource = fmt.Sprintf("#line 1" /*+" \"%v\""*/ +"\n" /*, fileName*/) + strings.Join(lines[:i], "\n")
		for _, str = range includes {
			shaderSource += fmt.Sprintf("\n#line %v" /*+" \"%v\""*/ +"\n", 1 /*, str*/)
			shaderSource += fmt.Sprintf("%v\n", incShaders[str])
		}
		shaderSource += fmt.Sprintf("#line %v" /*+" \"%v\""*/ +"\n", i+1 /*fileName*/)
		shaderSource += strings.Join(lines[i+1:], "\n")
		return includeShaders(fileName, shaderSource, incShaders)
	}
	return shaderSource
}

func inSlice(slice []string, val string) bool {
	for _, v := range slice {
		if v == val {
			return true
		}
	}
	return false
}

func main() {
	var (
		outTime, srcTime, tmpTime int64
	)
	force, nginePath := false, os.Args[1]
	srcDirPath, outFilePath := filepath.Join(nginePath, "core", "_glsl"), filepath.Join(nginePath, "core", "-gen-glsl-src.go")
	if fileInfo, err := os.Stat(outFilePath); err == nil && !force {
		outTime = fileInfo.ModTime().UnixNano()
	}
	if outTime > 0 {
		ff := func(_ *uio.DirWalker, filePath string, isDir bool) bool {
			if fileInfo, err := os.Stat(filePath); (err == nil) && !fileInfo.IsDir() {
				if tmpTime = fileInfo.ModTime().UnixNano(); tmpTime > srcTime {
					srcTime = tmpTime
				}
			}
			return srcTime <= outTime
		}
		if errs := uio.NewDirWalker(nil, ff).Walk(srcDirPath); len(errs) > 0 {
			panic(errs[0])
		}
	}
	if (outTime == 0) || (srcTime > outTime) {
		fmt.Printf("Re-merging changed shader files inside %v into %v... ", strings.Replace(srcDirPath, nginePath, ".", -1), strings.Replace(outFilePath, nginePath, ".", -1))
		if err := generateShadersFile(srcDirPath, outFilePath, "core", true); err == nil {
			fmt.Println("DONE.")
		} else {
			panic(err)
		}
	}
}
