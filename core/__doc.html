<html>
	<head>
		<title>Package github.com/go3d/go-ngine/core</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/core</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/core"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *core* package provides go:ngine client-side core functionality such as rendering and user I/O.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Dispose">func Dispose()</a></dd>
			
				
				<dd><a href="#Init">func Init(options *EngineOptions, winTitle string) (err error)</a></dd>
			
				
				<dd><a href="#Sfmt">func Sfmt(format string, fmtArgs ...interface{}) string</a></dd>
			
			
				
				<dd><a href="#Camera">type Camera</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCamera">func NewCamera() (me *Camera)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.ApplyMatrices">func (me *Camera) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.SetTechnique">func (me *Camera) SetTechnique(name string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.ToggleTechnique">func (me *Camera) ToggleTechnique()</a></dd>
				
			
				
				<dd><a href="#CameraViewPort">type CameraViewPort</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewPort.SetAbs">func (me *CameraViewPort) SetAbs(x, y, width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewPort.SetRel">func (me *CameraViewPort) SetRel(x, y, width, height float64)</a></dd>
				
			
				
				<dd><a href="#Controller">type Controller</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.BeginUpdate">func (me *Controller) BeginUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.EndUpdate">func (me *Controller) EndUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveBackward">func (me *Controller) MoveBackward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveDown">func (me *Controller) MoveDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveForward">func (me *Controller) MoveForward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveLeft">func (me *Controller) MoveLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveRight">func (me *Controller) MoveRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveUp">func (me *Controller) MoveUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeMove">func (me *Controller) StepSizeMove() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeTurn">func (me *Controller) StepSizeTurn() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDown">func (me *Controller) TurnDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeft">func (me *Controller) TurnLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRight">func (me *Controller) TurnRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUp">func (me *Controller) TurnUp()</a></dd>
				
			
				
				<dd><a href="#EngineCore">type EngineCore</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineCore.SyncUpdates">func (me *EngineCore) SyncUpdates()</a></dd>
				
			
				
				<dd><a href="#EngineLoop">type EngineLoop</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Loop">func (me *EngineLoop) Loop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Stop">func (me *EngineLoop) Stop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Time">func (me *EngineLoop) Time() float64</a></dd>
				
			
				
				<dd><a href="#EngineOptions">type EngineOptions</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEngineOptions">func NewEngineOptions(assetRootDirPath string, winWidth, winHeight, winSwapInterval int, winFullScreen bool) (me *EngineOptions)</a></dd>
				
				
			
				
				<dd><a href="#EngineStats">type EngineStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.AverageFps">func (me *EngineStats) AverageFps() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.TotalFrames">func (me *EngineStats) TotalFrames() float64</a></dd>
				
			
				
				<dd><a href="#EngineUserIO">type EngineUserIO</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.IifKeyF">func (me *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressed">func (me *EngineUserIO) KeyPressed(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressedWhich">func (me *EngineUserIO) KeyPressedWhich(keys ...int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyToggled">func (me *EngineUserIO) KeyToggled(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll2">func (me *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll3">func (me *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny2">func (me *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny3">func (me *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.SetWinTitle">func (me *EngineUserIO) SetWinTitle(newTitle string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.WinHeight">func (me *EngineUserIO) WinHeight() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.WinWidth">func (me *EngineUserIO) WinWidth() int</a></dd>
				
			
				
				<dd><a href="#FxColorOrTexture">type FxColorOrTexture</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxColor">func NewFxColor(rgba ...float64) (me *FxColorOrTexture)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxTexture">func NewFxTexture(image2ID string, sampler *FxSampler) (me *FxColorOrTexture)</a></dd>
				
				
			
				
				<dd><a href="#FxEffect">type FxEffect</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxEffect">func NewFxEffect() (me *FxEffect)</a></dd>
				
				
			
				
				<dd><a href="#FxImage">type FxImage</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage.GpuDelete">func (me *FxImage) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage.GpuSynced">func (me *FxImage) GpuSynced() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage.NoAutoMips">func (me *FxImage) NoAutoMips()</a></dd>
				
			
				
				<dd><a href="#FxImage2D">type FxImage2D</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxImage2D">func NewFxImage2D() (me *FxImage2D)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.GpuSync">func (me *FxImage2D) GpuSync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.IsRemote">func (me *FxImage2D) IsRemote() (remote bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Load">func (me *FxImage2D) Load()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Loaded">func (me *FxImage2D) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Unload">func (me *FxImage2D) Unload()</a></dd>
				
			
				
				<dd><a href="#FxImageOnLoad">type FxImageOnLoad</a></dd>
				
				
			
				
				<dd><a href="#FxMaterial">type FxMaterial</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxMaterial">func NewFxMaterial() (me *FxMaterial)</a></dd>
				
				
			
				
				<dd><a href="#FxSampler">type FxSampler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSampler">func NewFxSampler(filtering *FxSamplerFiltering, wrapping *ugfx.SamplerWrapping) (me *FxSampler)</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerFiltering">type FxSamplerFiltering</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSamplerFiltering">func NewFxSamplerFiltering(aniso float64, mag, min, mip bool) (me *FxSamplerFiltering)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxSamplerFiltering.Anisotropy">func (me *FxSamplerFiltering) Anisotropy() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxSamplerFiltering.Filtering">func (me *FxSamplerFiltering) Filtering() (mag, min, mip bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxSamplerFiltering.SetAnisotropy">func (me *FxSamplerFiltering) SetAnisotropy(aniso float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxSamplerFiltering.SetFiltering">func (me *FxSamplerFiltering) SetFiltering(mag, min, mip bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxSamplerFiltering.SetFilteringMag">func (me *FxSamplerFiltering) SetFilteringMag(filter bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxSamplerFiltering.SetFilteringMin">func (me *FxSamplerFiltering) SetFilteringMin(min, mip bool)</a></dd>
				
			
				
				<dd><a href="#LibCameras">type LibCameras</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameras.AddNew">func (me LibCameras) AddNew(id string) (obj *Camera)</a></dd>
				
			
				
				<dd><a href="#LibFxEffects">type LibFxEffects</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffects.AddNew">func (me LibFxEffects) AddNew(id string) (obj *FxEffect)</a></dd>
				
			
				
				<dd><a href="#LibFxImage2Ds">type LibFxImage2Ds</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImage2Ds.AddNew">func (me LibFxImage2Ds) AddNew(id string) (obj *FxImage2D)</a></dd>
				
			
				
				<dd><a href="#LibFxMaterials">type LibFxMaterials</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterials.AddNew">func (me LibFxMaterials) AddNew(id string) (obj *FxMaterial)</a></dd>
				
			
				
				<dd><a href="#Mesh">type Mesh</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuDelete">func (me *Mesh) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUpload">func (me *Mesh) GpuUpload() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUploaded">func (me *Mesh) GpuUploaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Loaded">func (me *Mesh) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Unload">func (me *Mesh) Unload()</a></dd>
				
			
				
				<dd><a href="#MeshBuffer">type MeshBuffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Add">func (me *MeshBuffer) Add(mesh *Mesh) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Remove">func (me *MeshBuffer) Remove(mesh *Mesh)</a></dd>
				
			
				
				<dd><a href="#MeshBuffers">type MeshBuffers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.Add">func (me *MeshBuffers) Add(id string, params *meshBufferParams) (buf *MeshBuffer, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.FloatsPerVertex">func (me *MeshBuffers) FloatsPerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.MemSizePerIndex">func (me *MeshBuffers) MemSizePerIndex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.MemSizePerVertex">func (me *MeshBuffers) MemSizePerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.NewParams">func (me *MeshBuffers) NewParams(numVerts, numIndices int32) (params *meshBufferParams)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.Remove">func (me *MeshBuffers) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#Meshes">type Meshes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Meshes.Add">func (me Meshes) Add(mesh *Mesh) *Mesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Meshes.AddRange">func (me Meshes) AddRange(meshes ...*Mesh)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Meshes.Load">func (me Meshes) Load(id string, provider MeshProvider, args ...interface{}) (mesh *Mesh, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Meshes.New">func (me Meshes) New(id string) (mesh *Mesh)</a></dd>
				
			
				
				<dd><a href="#Model">type Model</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.Clone">func (me *Model) Clone(newModelID string) (clonedModel *Model)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.MatID">func (me *Model) MatID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.SetMatID">func (me *Model) SetMatID(newMatID string)</a></dd>
				
			
				
				<dd><a href="#Models">type Models</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Models.Default">func (me Models) Default() *Model</a></dd>
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MatName">func (me *Node) MatName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.Material">func (me *Node) Material() *FxMaterial</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MeshModelName">func (me *Node) MeshModelName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MeshName">func (me *Node) MeshName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMatID">func (me *Node) SetMatID(newMatName string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMeshModelName">func (me *Node) SetMeshModelName(meshName, modelName string)</a></dd>
				
			
				
				<dd><a href="#NodeTransforms">type NodeTransforms</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.ApplyMatrices">func (me *NodeTransforms) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnAnyChanged">func (me *NodeTransforms) OnAnyChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosChanged">func (me *NodeTransforms) OnPosChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosRotChanged">func (me *NodeTransforms) OnPosRotChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosScaleChanged">func (me *NodeTransforms) OnPosScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotChanged">func (me *NodeTransforms) OnRotChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotScaleChanged">func (me *NodeTransforms) OnRotScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotXChanged">func (me *NodeTransforms) OnRotXChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotYChanged">func (me *NodeTransforms) OnRotYChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotZChanged">func (me *NodeTransforms) OnRotZChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnScaleChanged">func (me *NodeTransforms) OnScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnSomeChanged">func (me *NodeTransforms) OnSomeChanged(scale, pos, rotX, rotY, rotZ bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPos">func (me *NodeTransforms) SetPos(pos *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosX">func (me *NodeTransforms) SetPosX(posX float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosXYZ">func (me *NodeTransforms) SetPosXYZ(posX, posY, posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosY">func (me *NodeTransforms) SetPosY(posY float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosZ">func (me *NodeTransforms) SetPosZ(posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRot">func (me *NodeTransforms) SetRot(rot *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotX">func (me *NodeTransforms) SetRotX(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotXYZ">func (me *NodeTransforms) SetRotXYZ(radX, radY, radZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotY">func (me *NodeTransforms) SetRotY(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotZ">func (me *NodeTransforms) SetRotZ(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScale">func (me *NodeTransforms) SetScale(scale *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScaleN">func (me *NodeTransforms) SetScaleN(scale float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScaleXYZ">func (me *NodeTransforms) SetScaleXYZ(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.StepDelta">func (me *NodeTransforms) StepDelta(deltaPerSecond float64) float64</a></dd>
				
			
				
				<dd><a href="#RenderCanvas">type RenderCanvas</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.Dispose">func (me *RenderCanvas) Dispose()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.SetCameraIDs">func (me *RenderCanvas) SetCameraIDs(camIDs ...string)</a></dd>
				
			
				
				<dd><a href="#RenderCanvases">type RenderCanvases</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.Add">func (me *RenderCanvases) Add(canvas *RenderCanvas) *RenderCanvas</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.Index">func (me RenderCanvases) Index(canvas *RenderCanvas) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.New">func (me RenderCanvases) New(viewWidth, viewHeight int) (rc *RenderCanvas)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.Remove">func (me *RenderCanvases) Remove(canvas *RenderCanvas)</a></dd>
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewScene">func NewScene() (me *Scene)</a></dd>
				
				
			
				
				<dd><a href="#Scenes">type Scenes</a></dd>
				
				
			
				
				<dd><a href="#TimingStats">type TimingStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Average">func (me *TimingStats) Average() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Max">func (me *TimingStats) Max() float64</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-gen-glsl-src.go">-gen-glsl-src.go</a>
			
				<a href="/target/camera.gt.go">camera.gt.go</a>
			
				<a href="/target/controller.go">controller.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/fileio.go">fileio.go</a>
			
				<a href="/target/fx-effect.gt.go">fx-effect.gt.go</a>
			
				<a href="/target/fx-image-2d.gt.go">fx-image-2d.gt.go</a>
			
				<a href="/target/fx-image.go">fx-image.go</a>
			
				<a href="/target/fx-material.gt.go">fx-material.gt.go</a>
			
				<a href="/target/fx-sampler.go">fx-sampler.go</a>
			
				<a href="/target/gl-core.go">gl-core.go</a>
			
				<a href="/target/gl-shaders.go">gl-shaders.go</a>
			
				<a href="/target/mesh-buffer.go">mesh-buffer.go</a>
			
				<a href="/target/mesh-data.go">mesh-data.go</a>
			
				<a href="/target/mesh-provider.go">mesh-provider.go</a>
			
				<a href="/target/mesh.go">mesh.go</a>
			
				<a href="/target/model.go">model.go</a>
			
				<a href="/target/ng-core.go">ng-core.go</a>
			
				<a href="/target/ng-loop.go">ng-loop.go</a>
			
				<a href="/target/ng-options.go">ng-options.go</a>
			
				<a href="/target/ng-stats.go">ng-stats.go</a>
			
				<a href="/target/ng-userio.go">ng-userio.go</a>
			
				<a href="/target/ng.go">ng.go</a>
			
				<a href="/target/node-transform.go">node-transform.go</a>
			
				<a href="/target/node.go">node.go</a>
			
				<a href="/target/render-canvas.go">render-canvas.go</a>
			
				<a href="/target/render-technique.go">render-technique.go</a>
			
				<a href="/target/scene.go">scene.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    FxSamplerDefault             = NewFxSampler(FxSamplerFilteringHighMipped, FxSamplerWrappingRepeat)
    FxSamplerFilteringHighMipped = NewFxSamplerFiltering(8, true, true, true)
    FxSamplerWrappingRepeat      = ugfx.NewSamplerWrapping(ugfx.WrapKindRepeat, nil)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	Manages your main-thread&#39;s &#34;game loop&#34;. You&#39;ll need to call it&#39;s Loop() method once after go:ngine initialization (see samples).</span>
    Loop EngineLoop

    <span class="comment">//	The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.</span>
    Core EngineCore

    <span class="comment">//	Tracks various go:ngine performance counters over time.</span>
    Stats EngineStats

    <span class="comment">//	Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).</span>
    UserIO EngineUserIO
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A collection of all &#34;mesh providers&#34; known to go:ngine.</span>
    MeshProviders = &amp;meshProviders{meshProviderPrefabCube, meshProviderPrefabPlane, meshProviderPrefabPyramid, meshProviderPrefabQuad, meshProviderPrefabTri}
)</pre>
				
			
		
		
			
			
			<h2 id="Dispose">func <a href="/target/ng.go?s=656:670#L14">Dispose</a></h2>
			<pre>func Dispose()</pre>
			<p>
Call this to &#34;un-init&#34; go:ngine and to release any and all GPU or RAM resources still allocated.
</p>

			
		
			
			
			<h2 id="Init">func <a href="/target/ng.go?s=877:939#L21">Init</a></h2>
			<pre>func Init(options *EngineOptions, winTitle string) (err error)</pre>
			<p>
Initializes go:ngine; this first attempts to initialize OpenGL and then open a window to your supplied specifications with a GL 3.2-or-higher profile.
</p>

			
		
			
			
			<h2 id="Sfmt">func <a href="/target/ng.go?s=1464:1519#L45">Sfmt</a></h2>
			<pre>func Sfmt(format string, fmtArgs ...interface{}) string</pre>
			<p>
A short-hand for fmt.Sprintf. Feel free to ignore.
</p>

			
		
		
			
			
			<h2 id="Camera">type <a href="/target/camera.gt.go?s=177:1135#L1">Camera</a></h2>
			<pre>type Camera struct {
    <span class="comment">//	If true, this camera is ignored by the rendering runtime.</span>
    Disabled bool

    <span class="comment">//	Optical and imager properties for this camera.</span>
    Params struct {
        <span class="comment">//	Vertical field-of-view. Defaults to 37.8493.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        FovY float64

        <span class="comment">//	Distance of the far-plane from the camera. Defaults to 30000.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        ZFar float64

        <span class="comment">//	Distance of the near-plane from the camera. Defaults to 0.3.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        ZNear float64

        <span class="comment">//	The ID of the Scene (in Core.Libs.Scenes) this camera is looking at.</span>
        SceneID string
    }

    <span class="comment">//	Encapsulates the position and direction of this camera.</span>
    Controller Controller

    <span class="comment">//	The device-relative or absolute view-port for this Camera.</span>
    ViewPort CameraViewPort
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A camera embodies the eye point of the viewer looking at the visual scene.
</p>


			

			

			

			
				
				<h3 id="NewCamera">func <a href="/target/camera.gt.go?s=4343:4372#L141">NewCamera</a></h3>
				<pre>func NewCamera() (me *Camera)</pre>
				<p>
Initializes and returns a new Camera with default parameters.
</p>

				
			

			
				
				<h3 id="Camera.ApplyMatrices">func (*Camera) <a href="/target/camera.gt.go?s=1460:1493#L45">ApplyMatrices</a></h3>
				<pre>func (me *Camera) ApplyMatrices()</pre>
				<p>
Applies changes made to the FovY, ZNear and/or ZFar parameters in me.Params.
</p>

				
				
			
				
				<h3 id="Camera.SetTechnique">func (*Camera) <a href="/target/camera.gt.go?s=2212:2255#L65">SetTechnique</a></h3>
				<pre>func (me *Camera) SetTechnique(name string)</pre>
				
				
				
			
				
				<h3 id="Camera.ToggleTechnique">func (*Camera) <a href="/target/camera.gt.go?s=2354:2389#L71">ToggleTechnique</a></h3>
				<pre>func (me *Camera) ToggleTechnique()</pre>
				
				
				
			
		
			
			
			<h2 id="CameraViewPort">type <a href="/target/camera.gt.go?s=2999:3214#L103">CameraViewPort</a></h2>
			<pre>type CameraViewPort struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a device-relative or absolute camera view-port.
</p>


			

			

			

			

			
				
				<h3 id="CameraViewPort.SetAbs">func (*CameraViewPort) <a href="/target/camera.gt.go?s=3340:3397#L117">SetAbs</a></h3>
				<pre>func (me *CameraViewPort) SetAbs(x, y, width, height int)</pre>
				<p>
Sets the absolute viewport origin and dimensions in pixels.
</p>

				
				
			
				
				<h3 id="CameraViewPort.SetRel">func (*CameraViewPort) <a href="/target/camera.gt.go?s=3648:3709#L124">SetRel</a></h3>
				<pre>func (me *CameraViewPort) SetRel(x, y, width, height float64)</pre>
				<p>
Sets the device-relative viewport origin and dimensions, with the value 1.0
representing the maximum extent of the viewport on that respective axis.
</p>

				
				
			
		
			
			
			<h2 id="Controller">type <a href="/target/controller.go?s=272:1772#L2">Controller</a></h2>
			<pre>type Controller struct {
    <span class="comment">//	The position being manipulated by this Controller.</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    Pos unum.Vec3

    <span class="comment">//	The direction being manipulated by this Controller.</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    Dir unum.Vec3

    <span class="comment">//	Indicates which axis is consider &#34;upward&#34;. This is typically</span>
    <span class="comment">//	the Y-axis, denoted by the default value (0, 1, 0).</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    UpAxis unum.Vec3

    <span class="comment">//	Speed of &#34;moving&#34; in the MoveXyz() methods, in units per second.</span>
    <span class="comment">//	Defaults to 2.</span>
    MoveSpeed float64

    <span class="comment">//	A factor multiplied with MoveSpeed in the MoveXyz() methods. Defaults to 1.</span>
    MoveSpeedupFactor float64

    <span class="comment">//	Speed of &#34;turning&#34; in the TurnXyz() methods, in degrees per second.</span>
    <span class="comment">//	Defaults to 90.</span>
    TurnSpeed float64

    <span class="comment">//	A factor multiplied with TurnSpeed in the TurnXyz() methods. Defaults to 1.</span>
    TurnSpeedupFactor float64

    <span class="comment">//	The maximum degree that TurnUp() allows. Defaults to 90.</span>
    MaxTurnUp float64

    <span class="comment">//	The minimum degree that TurnDown() allows. Defaults to -90.</span>
    MinTurnDown float64
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a position-and-direction and provides methods
manipulating these with respect to each other (e.g. &#34;move forward&#34;
some entity that is rotated facing some arbitrary direction).
</p>


			

			

			

			

			
				
				<h3 id="Controller.BeginUpdate">func (*Controller) <a href="/target/controller.go?s=2771:2806#L76">BeginUpdate</a></h3>
				<pre>func (me *Controller) BeginUpdate()</pre>
				<p>
Temporarily suspends all matrix re-calculations typically occuring inside
the MoveXyz() / TurnXyz() methods. Call this prior to multiple subsequent
calls to any combination of those methods, and/or prior to manually modifying
the Pos, Dir or UpAxis fields of me. Immediately afterwards, be sure to call
EndUpdate() to apply all changes in a final matrix re-calculation.
</p>

				
				
			
				
				<h3 id="Controller.EndUpdate">func (*Controller) <a href="/target/controller.go?s=3140:3173#L84">EndUpdate</a></h3>
				<pre>func (me *Controller) EndUpdate()</pre>
				<p>
Applies all changes made to Pos, Dir or UpAxis since BeginUpdate() was last
called, and recalculates this Controller&#39;s final 4x4 transformation matrix.
Also resumes all matrix re-calculations typically occuring inside the
MoveXyz() / TurnXyz() methods that were suspended since BeginUpdate().
</p>

				
				
			
				
				<h3 id="Controller.MoveBackward">func (*Controller) <a href="/target/controller.go?s=4074:4110#L116">MoveBackward</a></h3>
				<pre>func (me *Controller) MoveBackward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move backward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveDown">func (*Controller) <a href="/target/controller.go?s=4275:4307#L122">MoveDown</a></h3>
				<pre>func (me *Controller) MoveDown()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move downward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveForward">func (*Controller) <a href="/target/controller.go?s=4474:4509#L128">MoveForward</a></h3>
				<pre>func (me *Controller) MoveForward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move forward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveLeft">func (*Controller) <a href="/target/controller.go?s=4675:4707#L134">MoveLeft</a></h3>
				<pre>func (me *Controller) MoveLeft()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move left-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveRight">func (*Controller) <a href="/target/controller.go?s=4901:4934#L140">MoveRight</a></h3>
				<pre>func (me *Controller) MoveRight()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move right-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveUp">func (*Controller) <a href="/target/controller.go?s=5124:5154#L146">MoveUp</a></h3>
				<pre>func (me *Controller) MoveUp()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move upward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.StepSizeMove">func (*Controller) <a href="/target/controller.go?s=5396:5440#L153">StepSizeMove</a></h3>
				<pre>func (me *Controller) StepSizeMove() float64</pre>
				<p>
Returns the current distance that a single MoveXyz() call (per loop iteration) would move.
(Loop.TickDelta * me.MoveSpeed * me.MoveSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.StepSizeTurn">func (*Controller) <a href="/target/controller.go?s=5658:5702#L159">StepSizeTurn</a></h3>
				<pre>func (me *Controller) StepSizeTurn() float64</pre>
				<p>
Returns the current degrees that a single TurnXyz() call (per loop iteration) would turn.
(Loop.TickDelta * me.TurnSpeed * me.TurnSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.TurnDown">func (*Controller) <a href="/target/controller.go?s=5847:5879#L164">TurnDown</a></h3>
				<pre>func (me *Controller) TurnDown()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeft">func (*Controller) <a href="/target/controller.go?s=6075:6107#L173">TurnLeft</a></h3>
				<pre>func (me *Controller) TurnLeft()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.TurnRight">func (*Controller) <a href="/target/controller.go?s=6265:6298#L180">TurnRight</a></h3>
				<pre>func (me *Controller) TurnRight()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.TurnUp">func (*Controller) <a href="/target/controller.go?s=6452:6482#L187">TurnUp</a></h3>
				<pre>func (me *Controller) TurnUp()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34;.
</p>

				
				
			
		
			
			
			<h2 id="EngineCore">type <a href="/target/ng-core.go?s=952:1360#L16">EngineCore</a></h2>
			<pre>type EngineCore struct {
    MeshBuffers *MeshBuffers
    Options     EngineOptions
    Libs        struct {
        Cameras   LibCameras
        Effects   LibFxEffects
        Materials LibFxMaterials
        Images    struct {
            I2D LibFxImage2Ds
        }
        Meshes Meshes
        Scenes Scenes
    }
    Rendering struct {
        Canvases           RenderCanvases
        DefaultCanvasIndex int
        States             ugl.RenderStates
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineCore a &#34;Singleton&#34; type, only valid use is the core.Core global variable.
The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.
</p>


			

			

			

			

			
				
				<h3 id="EngineCore.SyncUpdates">func (*EngineCore) <a href="/target/ng-core.go?s=3179:3214#L113">SyncUpdates</a></h3>
				<pre>func (me *EngineCore) SyncUpdates()</pre>
				
				
				
			
		
			
			
			<h2 id="EngineLoop">type <a href="/target/ng-loop.go?s=218:993#L3">EngineLoop</a></h2>
			<pre>type EngineLoop struct {
    <span class="comment">//	Set to true by EngineLoop.Loop(). Set to false to stop looping.</span>
    IsLooping bool

    <span class="comment">//	The tick-time when the EngineLoop.OnSec() callback was last invoked.</span>
    SecTickLast float64

    <span class="comment">//	While EngineLoop.Loop() is running, is set to the current &#34;tick-time&#34;:</span>
    <span class="comment">//	the time in seconds expired ever since EngineLoop.Loop() was last called.</span>
    TickNow float64

    <span class="comment">//	While EngineLoop.Loop() is running, is set to the previous tick-time.</span>
    TickLast float64

    <span class="comment">//	The delta between TickLast and TickNow.</span>
    TickDelta float64

    <span class="comment">//	While EngineLoop.Loop() is running, this callback is invoked every loop iteration (ie. once per frame).</span>
    OnLoop func()

    <span class="comment">//	While EngineLoop.Loop() is running, this callback is invoked at least and at most once per second.</span>
    OnSec func()
}</pre>
			<p>
Consider EngineLoop a &#34;Singleton&#34; type, only valid use is the core.Loop global variable.
Manages your main-thread&#39;s &#34;game loop&#34;.
</p>


			

			

			

			

			
				
				<h3 id="EngineLoop.Loop">func (*EngineLoop) <a href="/target/ng-loop.go?s=1256:1284#L34">Loop</a></h3>
				<pre>func (me *EngineLoop) Loop()</pre>
				<p>
Initiates a rendering loop. This method returns only when the loop is stopped for whatever reason.
</p>
<p>
(Before entering the loop, this method performs a one-off GC invokation.)
</p>

				
				
			
				
				<h3 id="EngineLoop.Stop">func (*EngineLoop) <a href="/target/ng-loop.go?s=2933:2961#L86">Stop</a></h3>
				<pre>func (me *EngineLoop) Stop()</pre>
				<p>
Stops the currently running EngineLoop.Loop().
</p>

				
				
			
				
				<h3 id="EngineLoop.Time">func (*EngineLoop) <a href="/target/ng-loop.go?s=3076:3112#L91">Time</a></h3>
				<pre>func (me *EngineLoop) Time() float64</pre>
				<p>
Returns the number of seconds expired ever since EngineLoop.Loop() was last called.
</p>

				
				
			
		
			
			
			<h2 id="EngineOptions">type <a href="/target/ng-options.go?s=185:513#L1">EngineOptions</a></h2>
			<pre>type EngineOptions struct {
    <span class="comment">//	The base directory path for asset file paths.</span>
    AssetRootDirPath string

    <span class="comment">//	Name for the default render technique, defaults to the only</span>
    <span class="comment">//	currently supported value &#34;rt_unlit&#34;.</span>
    DefaultRenderTechnique string
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineOptions a &#34;Singleton&#34; type, only valid use is the one instance you created for core.Init().
Various &#34;global&#34; (rather than use-case-specific) options.
</p>


			

			

			

			
				
				<h3 id="NewEngineOptions">func <a href="/target/ng-options.go?s=588:716#L8">NewEngineOptions</a></h3>
				<pre>func NewEngineOptions(assetRootDirPath string, winWidth, winHeight, winSwapInterval int, winFullScreen bool) (me *EngineOptions)</pre>
				<p>
Allocates, initializes and returns a new core.EngineOptions instance.
</p>

				
			

			
		
			
			
			<h2 id="EngineStats">type <a href="/target/ng-stats.go?s=211:2276#L1">EngineStats</a></h2>
			<pre>type EngineStats struct {
    <span class="comment">//	Gives the total number of frames rendered during the &#34;previous&#34; (not the current) second. Good enough for just a simple-minded FPS indicator.</span>
    FpsLastSec int

    <span class="comment">//	This TimingStats instance combines all the individual FrameFoo fields to track over time (both average and maximum) total cost per frame.</span>
    Frame TimingStats

    <span class="comment">//	&#34;Rendering&#34; consists of a CPU-side and a GPU-side cost.</span>
    <span class="comment">//	This TimingStats instance combines both to track over time (both average and maximum) total rendering cost per frame.</span>
    FrameRenderBoth TimingStats

    <span class="comment">//	The CPU-side cost of rendering comprises geometry culling, and batching draw calls to the GPU.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) CPU-side rendering cost per frame.</span>
    FrameRenderCpu TimingStats

    <span class="comment">//	The GPU-side cost of rendering comprises execution of all draw calls sent by the CPU-side, plus waiting for V-sync if enabled.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) GPU-side rendering cost per frame.</span>
    FrameRenderGpu TimingStats

    <span class="comment">//	&#34;Core code&#34; comprises non-rendering go:ngine logic executed every frame.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;core code&#34; cost per frame.</span>
    FrameCoreCode TimingStats

    <span class="comment">//	&#34;User code&#34; comprises user-specific logic executed every frame in your own EngineLoop.OnLoop() callback.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;user code&#34; cost per frame.</span>
    FrameUserCode TimingStats

    <span class="comment">//	During the Loop, the Go Garbge Collector is invoked at least and at most once per second.</span>
    <span class="comment">//	</span>
    <span class="comment">//	Forcing GC &#34;that often&#34; practically guarantees it will almost never have so much work to do as to</span>
    <span class="comment">//	noticably block user interaction --- 99.9% of the time it will complete in less than 10ms (and almost-always under 1ms).</span>
    <span class="comment">//	</span>
    <span class="comment">//	This TimingStats instance over time tracks the maximum and average time spent on that 1x-per-second GC invokation (but does not track any other GC invokations).</span>
    Gc TimingStats
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineStats a &#34;Singleton&#34; type, only valid use is the core.Stats global variable.
Tracks various go:ngine performance indicators over time.
</p>


			

			

			

			

			
				
				<h3 id="EngineStats.AverageFps">func (*EngineStats) <a href="/target/ng-stats.go?s=2364:2407#L39">AverageFps</a></h3>
				<pre>func (me *EngineStats) AverageFps() float64</pre>
				<p>
Returns the average number of frames-per-second since Loop.Loop() was last called.
</p>

				
				
			
				
				<h3 id="EngineStats.TotalFrames">func (*EngineStats) <a href="/target/ng-stats.go?s=2532:2576#L47">TotalFrames</a></h3>
				<pre>func (me *EngineStats) TotalFrames() float64</pre>
				
				
				
			
		
			
			
			<h2 id="EngineUserIO">type <a href="/target/ng-userio.go?s=317:601#L3">EngineUserIO</a></h2>
			<pre>type EngineUserIO struct {
    <span class="comment">//	Minimum delay for EngineUserIO.KeyToggled() method, in seconds. Defaults to 0.25.</span>
    KeyToggleMinDelay float64
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineUserIO a &#34;Singleton&#34; type, only valid use is the core.UserIO global variable.
Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).
</p>


			

			

			

			

			
				
				<h3 id="EngineUserIO.IifKeyF">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2180:2253#L66">IifKeyF</a></h3>
				<pre>func (me *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</pre>
				<p>
Returns ifTrue if the specified key is pressed, otherwise returns ifFalse.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressed">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2368:2416#L74">KeyPressed</a></h3>
				<pre>func (me *EngineUserIO) KeyPressed(key int) bool</pre>
				<p>
Returns true if the specified key is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressedWhich">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2507:2563#L79">KeyPressedWhich</a></h3>
				<pre>func (me *EngineUserIO) KeyPressedWhich(keys ...int) int</pre>
				<p>
Returns the first in keys that is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyToggled">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3529:3577#L109">KeyToggled</a></h3>
				<pre>func (me *EngineUserIO) KeyToggled(key int) bool</pre>
				<p>
Returns true if the specified key has been &#34;toggled&#34;, ie. its pressed-state changed within the last me.KeyToggleMinDelay seconds.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2729:2785#L89">KeysPressedAll2</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</pre>
				<p>
Returns true if both specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2895:2955#L94">KeysPressedAll3</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if all three specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3090:3146#L99">KeysPressedAny2</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</pre>
				<p>
Returns true if any of the two specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3262:3322#L104">KeysPressedAny3</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if any of the three specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.SetWinTitle">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3812:3864#L118">SetWinTitle</a></h3>
				<pre>func (me *EngineUserIO) SetWinTitle(newTitle string)</pre>
				<p>
Sets the window title to newTitle.
</p>

				
				
			
				
				<h3 id="EngineUserIO.WinHeight">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3948:3987#L123">WinHeight</a></h3>
				<pre>func (me *EngineUserIO) WinHeight() int</pre>
				<p>
Returns the height of the window in pixels.
</p>

				
				
			
				
				<h3 id="EngineUserIO.WinWidth">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4070:4108#L128">WinWidth</a></h3>
				<pre>func (me *EngineUserIO) WinWidth() int</pre>
				<p>
Returns the width of the window in pixels.
</p>

				
				
			
		
			
			
			<h2 id="FxColorOrTexture">type <a href="/target/fx-effect.gt.go?s=66:181#L1">FxColorOrTexture</a></h2>
			<pre>type FxColorOrTexture struct {
    Color   *ugfx.Rgba64
    Texture struct {
        Image2ID string
        Sampler  *FxSampler
    }
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxColor">func <a href="/target/fx-effect.gt.go?s=183:238#L5">NewFxColor</a></h3>
				<pre>func NewFxColor(rgba ...float64) (me *FxColorOrTexture)</pre>
				
				
			
				
				<h3 id="NewFxTexture">func <a href="/target/fx-effect.gt.go?s=308:385#L10">NewFxTexture</a></h3>
				<pre>func NewFxTexture(image2ID string, sampler *FxSampler) (me *FxColorOrTexture)</pre>
				
				
			

			
		
			
			
			<h2 id="FxEffect">type <a href="/target/fx-effect.gt.go?s=539:674#L19">FxEffect</a></h2>
			<pre>type FxEffect struct {
    Ambient *FxColorOrTexture

    <span class="comment">//	The source for diffuse color information. Required.</span>
    Diffuse *FxColorOrTexture
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxEffect">func <a href="/target/fx-effect.gt.go?s=846:879#L35">NewFxEffect</a></h3>
				<pre>func NewFxEffect() (me *FxEffect)</pre>
				<p>
Initializes and returns a new FxEffect with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="FxImage">type <a href="/target/fx-image.go?s=91:594#L1">FxImage</a></h2>
			<pre>type FxImage struct {
    OnAsyncDone      func()
    OnLoad           FxImageOnLoad
    AsyncNumAttempts int
    InitFrom         struct {
        RawData []byte
        RefUrl  string
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxImage.GpuDelete">func (*FxImage) <a href="/target/fx-image.go?s=1486:1516#L45">GpuDelete</a></h3>
				<pre>func (me *FxImage) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="FxImage.GpuSynced">func (*FxImage) <a href="/target/fx-image.go?s=1614:1649#L52">GpuSynced</a></h3>
				<pre>func (me *FxImage) GpuSynced() bool</pre>
				
				
				
			
				
				<h3 id="FxImage.NoAutoMips">func (*FxImage) <a href="/target/fx-image.go?s=1675:1706#L56">NoAutoMips</a></h3>
				<pre>func (me *FxImage) NoAutoMips()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImage2D">type <a href="/target/fx-image-2d.gt.go?s=158:210#L5">FxImage2D</a></h2>
			<pre>type FxImage2D struct {
    FxImage
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxImage2D">func <a href="/target/fx-image-2d.gt.go?s=3373:3408#L142">NewFxImage2D</a></h3>
				<pre>func NewFxImage2D() (me *FxImage2D)</pre>
				<p>
Initializes and returns a new FxImage2D with default parameters.
</p>

				
			

			
				
				<h3 id="FxImage2D.GpuSync">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=335:377#L20">GpuSync</a></h3>
				<pre>func (me *FxImage2D) GpuSync() (err error)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.IsRemote">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=2295:2340#L97">IsRemote</a></h3>
				<pre>func (me *FxImage2D) IsRemote() (remote bool)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Load">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=626:653#L27">Load</a></h3>
				<pre>func (me *FxImage2D) Load()</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Loaded">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=1766:1800#L80">Loaded</a></h3>
				<pre>func (me *FxImage2D) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Unload">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=2384:2413#L102">Unload</a></h3>
				<pre>func (me *FxImage2D) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageOnLoad">type <a href="/target/fx-image.go?s=1822:1885#L66">FxImageOnLoad</a></h2>
			<pre>type FxImageOnLoad func(img interface{}, err error, async bool)</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxMaterial">type <a href="/target/fx-material.gt.go?s=14:57#L1">FxMaterial</a></h2>
			<pre>type FxMaterial struct {
    EffectID string
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxMaterial">func <a href="/target/fx-material.gt.go?s=237:274#L6">NewFxMaterial</a></h3>
				<pre>func NewFxMaterial() (me *FxMaterial)</pre>
				<p>
Initializes and returns a new FxMaterial with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="FxSampler">type <a href="/target/fx-sampler.go?s=398:487#L6">FxSampler</a></h2>
			<pre>type FxSampler struct {
    Filtering *FxSamplerFiltering
    Wrapping  *ugfx.SamplerWrapping
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxSampler">func <a href="/target/fx-sampler.go?s=489:585#L11">NewFxSampler</a></h3>
				<pre>func NewFxSampler(filtering *FxSamplerFiltering, wrapping *ugfx.SamplerWrapping) (me *FxSampler)</pre>
				
				
			

			
		
			
			
			<h2 id="FxSamplerFiltering">type <a href="/target/fx-sampler.go?s=658:781#L16">FxSamplerFiltering</a></h2>
			<pre>type FxSamplerFiltering struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxSamplerFiltering">func <a href="/target/fx-sampler.go?s=783:869#L23">NewFxSamplerFiltering</a></h3>
				<pre>func NewFxSamplerFiltering(aniso float64, mag, min, mip bool) (me *FxSamplerFiltering)</pre>
				
				
			

			
				
				<h3 id="FxSamplerFiltering.Anisotropy">func (*FxSamplerFiltering) <a href="/target/fx-sampler.go?s=991:1041#L31">Anisotropy</a></h3>
				<pre>func (me *FxSamplerFiltering) Anisotropy() float64</pre>
				
				
				
			
				
				<h3 id="FxSamplerFiltering.Filtering">func (*FxSamplerFiltering) <a href="/target/fx-sampler.go?s=1064:1126#L35">Filtering</a></h3>
				<pre>func (me *FxSamplerFiltering) Filtering() (mag, min, mip bool)</pre>
				
				
				
			
				
				<h3 id="FxSamplerFiltering.SetAnisotropy">func (*FxSamplerFiltering) <a href="/target/fx-sampler.go?s=1180:1238#L40">SetAnisotropy</a></h3>
				<pre>func (me *FxSamplerFiltering) SetAnisotropy(aniso float64)</pre>
				
				
				
			
				
				<h3 id="FxSamplerFiltering.SetFiltering">func (*FxSamplerFiltering) <a href="/target/fx-sampler.go?s=1400:1462#L50">SetFiltering</a></h3>
				<pre>func (me *FxSamplerFiltering) SetFiltering(mag, min, mip bool)</pre>
				
				
				
			
				
				<h3 id="FxSamplerFiltering.SetFilteringMag">func (*FxSamplerFiltering) <a href="/target/fx-sampler.go?s=1523:1581#L55">SetFilteringMag</a></h3>
				<pre>func (me *FxSamplerFiltering) SetFilteringMag(filter bool)</pre>
				
				
				
			
				
				<h3 id="FxSamplerFiltering.SetFilteringMin">func (*FxSamplerFiltering) <a href="/target/fx-sampler.go?s=1681:1741#L61">SetFilteringMin</a></h3>
				<pre>func (me *FxSamplerFiltering) SetFilteringMin(min, mip bool)</pre>
				
				
				
			
		
			
			
			<h2 id="LibCameras">type <a href="/target/camera.gt.go?s=4486:4520#L148">LibCameras</a></h2>
			<pre>type LibCameras map[string]*Camera</pre>
			<p>
A hash-table of Cameras associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibCameras.AddNew">func (LibCameras) <a href="/target/camera.gt.go?s=4644:4696#L152">AddNew</a></h3>
				<pre>func (me LibCameras) AddNew(id string) (obj *Camera)</pre>
				<p>
Creates and initializes a new Camera with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
		
			
			
			<h2 id="LibFxEffects">type <a href="/target/fx-effect.gt.go?s=997:1035#L42">LibFxEffects</a></h2>
			<pre>type LibFxEffects map[string]*FxEffect</pre>
			<p>
A hash-table of FxEffects associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxEffects.AddNew">func (LibFxEffects) <a href="/target/fx-effect.gt.go?s=1161:1217#L46">AddNew</a></h3>
				<pre>func (me LibFxEffects) AddNew(id string) (obj *FxEffect)</pre>
				<p>
Creates and initializes a new FxEffect with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
		
			
			
			<h2 id="LibFxImage2Ds">type <a href="/target/fx-image-2d.gt.go?s=3528:3568#L149">LibFxImage2Ds</a></h2>
			<pre>type LibFxImage2Ds map[string]*FxImage2D</pre>
			<p>
A hash-table of FxImage2Ds associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxImage2Ds.AddNew">func (LibFxImage2Ds) <a href="/target/fx-image-2d.gt.go?s=3695:3753#L153">AddNew</a></h3>
				<pre>func (me LibFxImage2Ds) AddNew(id string) (obj *FxImage2D)</pre>
				<p>
Creates and initializes a new FxImage2D with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
		
			
			
			<h2 id="LibFxMaterials">type <a href="/target/fx-material.gt.go?s=396:438#L13">LibFxMaterials</a></h2>
			<pre>type LibFxMaterials map[string]*FxMaterial</pre>
			<p>
A hash-table of FxMaterials associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxMaterials.AddNew">func (LibFxMaterials) <a href="/target/fx-material.gt.go?s=566:626#L17">AddNew</a></h3>
				<pre>func (me LibFxMaterials) AddNew(id string) (obj *FxMaterial)</pre>
				<p>
Creates and initializes a new FxMaterial with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
		
			
			
			<h2 id="Mesh">type <a href="/target/mesh.go?s=793:1198#L40">Mesh</a></h2>
			<pre>type Mesh struct {
    Models Models
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Mesh.GpuDelete">func (*Mesh) <a href="/target/mesh.go?s=1200:1227#L50">GpuDelete</a></h3>
				<pre>func (me *Mesh) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUpload">func (*Mesh) <a href="/target/mesh.go?s=1278:1317#L56">GpuUpload</a></h3>
				<pre>func (me *Mesh) GpuUpload() (err error)</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUploaded">func (*Mesh) <a href="/target/mesh.go?s=2918:2952#L83">GpuUploaded</a></h3>
				<pre>func (me *Mesh) GpuUploaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Loaded">func (*Mesh) <a href="/target/mesh.go?s=4824:4853#L130">Loaded</a></h3>
				<pre>func (me *Mesh) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Unload">func (*Mesh) <a href="/target/mesh.go?s=5272:5296#L143">Unload</a></h3>
				<pre>func (me *Mesh) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffer">type <a href="/target/mesh-buffer.go?s=1728:2117#L63">MeshBuffer</a></h2>
			<pre>type MeshBuffer struct {
    MemSizeIndices, MemSizeVertices int32
    Params                          *meshBufferParams
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffer.Add">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=3621:3670#L112">Add</a></h3>
				<pre>func (me *MeshBuffer) Add(mesh *Mesh) (err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffer.Remove">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=4424:4464#L140">Remove</a></h3>
				<pre>func (me *MeshBuffer) Remove(mesh *Mesh)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffers">type <a href="/target/mesh-buffer.go?s=361:417#L6">MeshBuffers</a></h2>
			<pre>type MeshBuffers struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffers.Add">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=529:621#L16">Add</a></h3>
				<pre>func (me *MeshBuffers) Add(id string, params *meshBufferParams) (buf *MeshBuffer, err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.FloatsPerVertex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1015:1061#L37">FloatsPerVertex</a></h3>
				<pre>func (me *MeshBuffers) FloatsPerVertex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.MemSizePerIndex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1222:1268#L42">MemSizePerIndex</a></h3>
				<pre>func (me *MeshBuffers) MemSizePerIndex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.MemSizePerVertex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1284:1331#L46">MemSizePerVertex</a></h3>
				<pre>func (me *MeshBuffers) MemSizePerVertex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.NewParams">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1411:1498#L51">NewParams</a></h3>
				<pre>func (me *MeshBuffers) NewParams(numVerts, numIndices int32) (params *meshBufferParams)</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.Remove">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1604:1644#L56">Remove</a></h3>
				<pre>func (me *MeshBuffers) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshData">type <a href="/target/mesh-data.go?s=1164:1390#L42">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="NewMeshData">func <a href="/target/mesh-data.go?s=1446:1479#L57">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/mesh-data.go?s=39:101#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Temporary concoction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Meshes">type <a href="/target/mesh.go?s=100:128#L1">Meshes</a></h2>
			<pre>type Meshes map[string]*Mesh</pre>
			

			

			

			

			

			
				
				<h3 id="Meshes.Add">func (Meshes) <a href="/target/mesh.go?s=130:168#L3">Add</a></h3>
				<pre>func (me Meshes) Add(mesh *Mesh) *Mesh</pre>
				
				
				
			
				
				<h3 id="Meshes.AddRange">func (Meshes) <a href="/target/mesh.go?s=249:291#L11">AddRange</a></h3>
				<pre>func (me Meshes) AddRange(meshes ...*Mesh)</pre>
				
				
				
			
				
				<h3 id="Meshes.Load">func (Meshes) <a href="/target/mesh.go?s=433:533#L24">Load</a></h3>
				<pre>func (me Meshes) Load(id string, provider MeshProvider, args ...interface{}) (mesh *Mesh, err error)</pre>
				
				
				
			
				
				<h3 id="Meshes.New">func (Meshes) <a href="/target/mesh.go?s=690:734#L35">New</a></h3>
				<pre>func (me Meshes) New(id string) (mesh *Mesh)</pre>
				
				
				
			
		
			
			
			<h2 id="Model">type <a href="/target/model.go?s=593:674#L8">Model</a></h2>
			<pre>type Model struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Model is a parameterized instantiation of its parent Mesh geometry
with unique appearance, material or other properties.
</p>
<p>
Each Mesh provides at least one Model, the &#34;default model&#34; (with ID &#34;&#34;),
accessible via someMesh.Models.Default(). To create new models for a Mesh,
call someMesh.Models[&#34;sourceModelID&#34;].Clone(&#34;newModelID&#34;).
</p>


			

			

			

			

			
				
				<h3 id="Model.Clone">func (*Model) <a href="/target/model.go?s=881:943#L22">Clone</a></h3>
				<pre>func (me *Model) Clone(newModelID string) (clonedModel *Model)</pre>
				<p>
Creates a copy of me and adds it to the parent Mesh&#39;s Models
hash-table under the specified newModelID.
</p>

				
				
			
				
				<h3 id="Model.MatID">func (*Model) <a href="/target/model.go?s=1116:1147#L30">MatID</a></h3>
				<pre>func (me *Model) MatID() string</pre>
				
				
				
			
				
				<h3 id="Model.SetMatID">func (*Model) <a href="/target/model.go?s=1253:1295#L39">SetMatID</a></h3>
				<pre>func (me *Model) SetMatID(newMatID string)</pre>
				
				
				
			
		
			
			
			<h2 id="Models">type <a href="/target/model.go?s=96:125#L1">Models</a></h2>
			<pre>type Models map[string]*Model</pre>
			<p>
A hash-table of Models associated with their ID.
Used only for Mesh.Models.
</p>


			

			

			

			

			
				
				<h3 id="Models.Default">func (Models) <a href="/target/model.go?s=190:223#L1">Default</a></h3>
				<pre>func (me Models) Default() *Model</pre>
				<p>
Returns the default Model (with ID &#34;&#34;) for the parent Mesh.
</p>

				
				
			
		
			
			
			<h2 id="Node">type <a href="/target/node.go?s=1148:1545#L44">Node</a></h2>
			<pre>type Node struct {
    Disabled  bool
    SubNodes  *subNodes
    Transform *NodeTransforms
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Node.MatName">func (*Node) <a href="/target/node.go?s=1899:1931#L74">MatName</a></h3>
				<pre>func (me *Node) MatName() string</pre>
				
				
				
			
				
				<h3 id="Node.Material">func (*Node) <a href="/target/node.go?s=1795:1833#L67">Material</a></h3>
				<pre>func (me *Node) Material() *FxMaterial</pre>
				
				
				
			
				
				<h3 id="Node.MeshModelName">func (*Node) <a href="/target/node.go?s=2015:2053#L82">MeshModelName</a></h3>
				<pre>func (me *Node) MeshModelName() string</pre>
				
				
				
			
				
				<h3 id="Node.MeshName">func (*Node) <a href="/target/node.go?s=1956:1989#L78">MeshName</a></h3>
				<pre>func (me *Node) MeshName() string</pre>
				
				
				
			
				
				<h3 id="Node.SetMatID">func (*Node) <a href="/target/node.go?s=2567:2610#L102">SetMatID</a></h3>
				<pre>func (me *Node) SetMatID(newMatName string)</pre>
				
				
				
			
				
				<h3 id="Node.SetMeshModelName">func (*Node) <a href="/target/node.go?s=2717:2777#L108">SetMeshModelName</a></h3>
				<pre>func (me *Node) SetMeshModelName(meshName, modelName string)</pre>
				
				
				
			
		
			
			
			<h2 id="NodeTransforms">type <a href="/target/node-transform.go?s=613:1168#L6">NodeTransforms</a></h2>
			<pre>type NodeTransforms struct {
    <span class="comment">//	Translation of the from origin, if any.</span>
    Pos unum.Vec3

    <span class="comment">//	Rotation for each axis in radians, if any.</span>
    Rot unum.Vec3

    <span class="comment">//	Scaling of this node, if any. Defaults to (1, 1, 1) for no scaling.</span>
    Scale unum.Vec3

    <span class="comment">//	An arbitrary additional transformation to apply. Defaults to the 4x4 identity matrix for &#39;none&#39;.</span>
    <span class="comment">//	Must not be nil.</span>
    Other unum.Mat4
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents one or more transformations of a Node.
This is only used by Node objects, which initialize their NodeTransforms with the
proper defaults and associate themselves with their NodeTransforms. (Any other
NodeTransforms are invalid.)
</p>
<p>
A single NodeTransforms encapsulates a number of private 4x4 matrices that are
set from its exported fields via the SetFoo() or OnFooChanged() methods, and
are multiplied together into a final single 4x4 transformation matrix via the
ApplyMatrices() (or OnFooChanged()) methods.
</p>


			

			

			

			

			
				
				<h3 id="NodeTransforms.ApplyMatrices">func (*NodeTransforms) <a href="/target/node-transform.go?s=1673:1714#L39">ApplyMatrices</a></h3>
				<pre>func (me *NodeTransforms) ApplyMatrices()</pre>
				<p>
Creates a final single 4x4 transformation matrix for all transformations
in me. It is onlx this matrix that is used by the rendering runtime.
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnAnyChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=2338:2378#L55">OnAnyChanged</a></h3>
				<pre>func (me *NodeTransforms) OnAnyChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the scaling matrix from the current me.Scale value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=2645:2685#L68">OnPosChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosRotChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=2906:2949#L76">OnPosRotChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosRotChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3172:3217#L85">OnPosScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosScaleChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the scaling matrix from the current me.Scale value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3500:3540#L99">OnRotChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotChanged()</pre>
				<p>
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3759:3804#L107">OnRotScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotScaleChanged()</pre>
				<p>
Updates the scaling matrix from the current me.Scale value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotXChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4051:4092#L119">OnRotXChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotXChanged()</pre>
				<p>
Updates the X-axis rotation matrix from the current me.Rot.X value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotYChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4319:4360#L130">OnRotYChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotYChanged()</pre>
				<p>
Updates the Y-axis rotation matrix from the current me.Rot.Y value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotZChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4587:4628#L141">OnRotZChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotZChanged()</pre>
				<p>
Updates the Z-axis rotation matrix from the current me.Rot.Z value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4848:4890#L152">OnScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnScaleChanged()</pre>
				<p>
Updates the scaling matrix from the current me.Scale value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnSomeChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=5394:5468#L163">OnSomeChanged</a></h3>
				<pre>func (me *NodeTransforms) OnSomeChanged(scale, pos, rotX, rotY, rotZ bool)</pre>
				<p>
If pos is true, updates the translation matrix from the current me.Pos value.
If scale is true, updates the scaling matrix from the current me.Scale value.
If rotX is true, updates the X-axis rotation matrix from the current me.Rot.X value.
If rotY is true, updates the Y-axis rotation matrix from the current me.Rot.Y value.
If rotZ is true, updates the Z-axis rotation matrix from the current me.Rot.Z value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPos">func (*NodeTransforms) <a href="/target/node-transform.go?s=5710:5758#L183">SetPos</a></h3>
				<pre>func (me *NodeTransforms) SetPos(pos *unum.Vec3)</pre>
				<p>
Sets me.Pos and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosX">func (*NodeTransforms) <a href="/target/node-transform.go?s=5897:5944#L193">SetPosX</a></h3>
				<pre>func (me *NodeTransforms) SetPosX(posX float64)</pre>
				<p>
Sets me.Pos.X and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6027:6088#L199">SetPosXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetPosXYZ(posX, posY, posZ float64)</pre>
				<p>
Sets me.Pos and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosY">func (*NodeTransforms) <a href="/target/node-transform.go?s=6205:6252#L205">SetPosY</a></h3>
				<pre>func (me *NodeTransforms) SetPosY(posY float64)</pre>
				<p>
Sets me.Pos.Y and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6337:6384#L211">SetPosZ</a></h3>
				<pre>func (me *NodeTransforms) SetPosZ(posZ float64)</pre>
				<p>
Sets me.Pos.Z and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRot">func (*NodeTransforms) <a href="/target/node-transform.go?s=6467:6515#L217">SetRot</a></h3>
				<pre>func (me *NodeTransforms) SetRot(rot *unum.Vec3)</pre>
				<p>
Sets me.Rot and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotX">func (*NodeTransforms) <a href="/target/node-transform.go?s=6654:6700#L227">SetRotX</a></h3>
				<pre>func (me *NodeTransforms) SetRotX(rad float64)</pre>
				<p>
Sets me.Rot.X and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6783:6844#L233">SetRotXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetRotXYZ(radX, radY, radZ float64)</pre>
				<p>
Sets me.Rot and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotY">func (*NodeTransforms) <a href="/target/node-transform.go?s=6961:7007#L239">SetRotY</a></h3>
				<pre>func (me *NodeTransforms) SetRotY(rad float64)</pre>
				<p>
Sets me.Rot.Y and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=7092:7138#L245">SetRotZ</a></h3>
				<pre>func (me *NodeTransforms) SetRotZ(rad float64)</pre>
				<p>
Sets me.Rot.Z and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScale">func (*NodeTransforms) <a href="/target/node-transform.go?s=7225:7277#L251">SetScale</a></h3>
				<pre>func (me *NodeTransforms) SetScale(scale *unum.Vec3)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScaleN">func (*NodeTransforms) <a href="/target/node-transform.go?s=7420:7470#L261">SetScaleN</a></h3>
				<pre>func (me *NodeTransforms) SetScaleN(scale float64)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScaleXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=7558:7612#L266">SetScaleXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetScaleXYZ(x, y, z float64)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.StepDelta">func (*NodeTransforms) <a href="/target/node-transform.go?s=7764:7831#L272">StepDelta</a></h3>
				<pre>func (me *NodeTransforms) StepDelta(deltaPerSecond float64) float64</pre>
				<p>
Returns the result of multiplying deltaPerSecond with EngineLoop.TickDelta.
</p>

				
				
			
		
			
			
			<h2 id="RenderCanvas">type <a href="/target/render-canvas.go?s=1256:1460#L49">RenderCanvas</a></h2>
			<pre>type RenderCanvas struct {
    <span class="comment">//	If true, this RenderCanvas is ignored by the rendering runtime.</span>
    Disabled bool
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents a surface that can be rendered to, ie. either the
screen or a render texture. Equivalent to a &#34;framebuffer object&#34;
in OpenGL.
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvas.Dispose">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1617:1650#L64">Dispose</a></h3>
				<pre>func (me *RenderCanvas) Dispose()</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.SetCameraIDs">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1777:1831#L75">SetCameraIDs</a></h3>
				<pre>func (me *RenderCanvas) SetCameraIDs(camIDs ...string)</pre>
				
				
				
			
		
			
			
			<h2 id="RenderCanvases">type <a href="/target/render-canvas.go?s=364:399#L12">RenderCanvases</a></h2>
			<pre>type RenderCanvases []*RenderCanvas</pre>
			

			

			

			

			

			
				
				<h3 id="RenderCanvases.Add">func (*RenderCanvases) <a href="/target/render-canvas.go?s=641:706#L26">Add</a></h3>
				<pre>func (me *RenderCanvases) Add(canvas *RenderCanvas) *RenderCanvas</pre>
				
				
				
			
				
				<h3 id="RenderCanvases.Index">func (RenderCanvases) <a href="/target/render-canvas.go?s=754:810#L31">Index</a></h3>
				<pre>func (me RenderCanvases) Index(canvas *RenderCanvas) int</pre>
				
				
				
			
				
				<h3 id="RenderCanvases.New">func (RenderCanvases) <a href="/target/render-canvas.go?s=401:475#L14">New</a></h3>
				<pre>func (me RenderCanvases) New(viewWidth, viewHeight int) (rc *RenderCanvas)</pre>
				
				
				
			
				
				<h3 id="RenderCanvases.Remove">func (*RenderCanvases) <a href="/target/render-canvas.go?s=926:980#L40">Remove</a></h3>
				<pre>func (me *RenderCanvases) Remove(canvas *RenderCanvas)</pre>
				
				
				
			
		
			
			
			<h2 id="Scene">type <a href="/target/scene.go?s=162:238#L1">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	The root Node for this scene graph.</span>
    RootNode Node
}</pre>
			<p>
Represents a scene graph.
</p>


			

			

			

			
				
				<h3 id="NewScene">func <a href="/target/scene.go?s=287:314#L4">NewScene</a></h3>
				<pre>func NewScene() (me *Scene)</pre>
				<p>
Initializes and returns a new, empty Scene.
</p>

				
			

			
		
			
			
			<h2 id="Scenes">type <a href="/target/scene.go?s=102:131#L1">Scenes</a></h2>
			<pre>type Scenes map[string]*Scene</pre>
			<p>
A hash-table of Scenes associated with their IDs.
Only used for Core.Libs.Scenes.
</p>


			

			

			

			

			
		
			
			
			<h2 id="TimingStats">type <a href="/target/ng-stats.go?s=2681:2853#L52">TimingStats</a></h2>
			<pre>type TimingStats struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Helps track average and maximum cost for a variety of performance indicators.
</p>


			

			

			

			

			
				
				<h3 id="TimingStats.Average">func (*TimingStats) <a href="/target/ng-stats.go?s=2922:2962#L58">Average</a></h3>
				<pre>func (me *TimingStats) Average() float64</pre>
				<p>
Returns the average cost tracked by this performance indicator.
</p>

				
				
			
				
				<h3 id="TimingStats.Max">func (*TimingStats) <a href="/target/ng-stats.go?s=3554:3590#L81">Max</a></h3>
				<pre>func (me *TimingStats) Max() float64</pre>
				<p>
Returns the maximum cost tracked by this performance indicator.
</p>

				
				
			
		
		</div>
	

	








		</div></div>
	</body>
</html>