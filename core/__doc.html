<html>
	<head>
		<title>Package github.com/go3d/go-ngine/core</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/core</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/core"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *core* package provides go:ngine client-side core functionality such as rendering and user I/O.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Dispose">func Dispose()</a></dd>
			
				
				<dd><a href="#Init">func Init(options *EngineOptions, initialWinTitle string) (err error)</a></dd>
			
			
				
				<dd><a href="#Camera">type Camera</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCamera2D">func NewCamera2D(depth bool) (me *Camera)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCamera3D">func NewCamera3D() (me *Camera)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.ApplyMatrices">func (me *Camera) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.SetTechnique">func (me *Camera) SetTechnique(name string)</a></dd>
				
			
				
				<dd><a href="#CameraViewPort">type CameraViewPort</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewPort.SetAbs">func (me *CameraViewPort) SetAbs(x, y, width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewPort.SetRel">func (me *CameraViewPort) SetRel(x, y, width, height float64)</a></dd>
				
			
				
				<dd><a href="#Cameras">type Cameras</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Cameras.Add">func (me *Cameras) Add(camera *Camera) *Camera</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Cameras.Insert">func (me *Cameras) Insert(camera *Camera, index int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Cameras.Remove">func (me *Cameras) Remove(camera *Camera)</a></dd>
				
			
				
				<dd><a href="#Controller">type Controller</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.BeginUpdate">func (me *Controller) BeginUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.EndUpdate">func (me *Controller) EndUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveBackward">func (me *Controller) MoveBackward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveDown">func (me *Controller) MoveDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveForward">func (me *Controller) MoveForward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveLeft">func (me *Controller) MoveLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveRight">func (me *Controller) MoveRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveUp">func (me *Controller) MoveUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeMove">func (me *Controller) StepSizeMove() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeTurn">func (me *Controller) StepSizeTurn() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDown">func (me *Controller) TurnDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDownBy">func (me *Controller) TurnDownBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeft">func (me *Controller) TurnLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeftBy">func (me *Controller) TurnLeftBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRight">func (me *Controller) TurnRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRightBy">func (me *Controller) TurnRightBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUp">func (me *Controller) TurnUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUpBy">func (me *Controller) TurnUpBy(deg float64)</a></dd>
				
			
				
				<dd><a href="#EngineCore">type EngineCore</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineCore.SyncUpdates">func (me *EngineCore) SyncUpdates()</a></dd>
				
			
				
				<dd><a href="#EngineDiagnostics">type EngineDiagnostics</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiagnostics.Log">func (me *EngineDiagnostics) Log(cat LogCategory, fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiagnostics.LogErr">func (me *EngineDiagnostics) LogErr(err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiagnostics.LogMeshes">func (me *EngineDiagnostics) LogMeshes(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiagnostics.LogMisc">func (me *EngineDiagnostics) LogMisc(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiagnostics.LogShaders">func (me *EngineDiagnostics) LogShaders(fmt string, fmtArgs ...interface{})</a></dd>
				
			
				
				<dd><a href="#EngineLoop">type EngineLoop</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Loop">func (me *EngineLoop) Loop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Stop">func (me *EngineLoop) Stop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Time">func (me *EngineLoop) Time() float64</a></dd>
				
			
				
				<dd><a href="#EngineOptions">type EngineOptions</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEngineOptions">func NewEngineOptions(assetRootDirPath string, winWidth, winHeight, winSwapInterval int, winFullScreen bool) (me *EngineOptions)</a></dd>
				
				
			
				
				<dd><a href="#EngineStats">type EngineStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.AverageFps">func (me *EngineStats) AverageFps() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.TotalFrames">func (me *EngineStats) TotalFrames() float64</a></dd>
				
			
				
				<dd><a href="#EngineUserIO">type EngineUserIO</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.IifKeyF">func (me *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressed">func (me *EngineUserIO) KeyPressed(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressedWhich">func (me *EngineUserIO) KeyPressedWhich(keys ...int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyToggled">func (me *EngineUserIO) KeyToggled(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll2">func (me *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll3">func (me *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny2">func (me *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny3">func (me *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.SetWinTitle">func (me *EngineUserIO) SetWinTitle(newTitle string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.WinHeight">func (me *EngineUserIO) WinHeight() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.WinWidth">func (me *EngineUserIO) WinWidth() int</a></dd>
				
			
				
				<dd><a href="#FxColorOrTexture">type FxColorOrTexture</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxColor">func NewFxColor(rgba ...float64) (me *FxColorOrTexture)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxTexture">func NewFxTexture(image2ID string, sampler *ugl.Sampler) (me *FxColorOrTexture)</a></dd>
				
				
			
				
				<dd><a href="#FxEffect">type FxEffect</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxEffect">func NewFxEffect() (me *FxEffect)</a></dd>
				
				
			
				
				<dd><a href="#FxImage2D">type FxImage2D</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxImage2D">func NewFxImage2D() (me *FxImage2D)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.GpuSync">func (me *FxImage2D) GpuSync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.IsRemote">func (me *FxImage2D) IsRemote() (remote bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Load">func (me *FxImage2D) Load()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Loaded">func (me *FxImage2D) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Unload">func (me *FxImage2D) Unload()</a></dd>
				
			
				
				<dd><a href="#FxImageBase">type FxImageBase</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.GpuDelete">func (me *FxImageBase) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.GpuSynced">func (me *FxImageBase) GpuSynced() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.NoAutoMips">func (me *FxImageBase) NoAutoMips()</a></dd>
				
			
				
				<dd><a href="#FxImageOnLoad">type FxImageOnLoad</a></dd>
				
				
			
				
				<dd><a href="#FxMaterial">type FxMaterial</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxMaterial">func NewFxMaterial() (me *FxMaterial)</a></dd>
				
				
			
				
				<dd><a href="#LibFxEffects">type LibFxEffects</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffects.AddNew">func (me LibFxEffects) AddNew(id string) (obj *FxEffect)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffects.Remove">func (me LibFxEffects) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibFxImage2Ds">type LibFxImage2Ds</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImage2Ds.AddNew">func (me LibFxImage2Ds) AddNew(id string) (obj *FxImage2D)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImage2Ds.Remove">func (me LibFxImage2Ds) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibFxMaterials">type LibFxMaterials</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterials.AddNew">func (me LibFxMaterials) AddNew(id string) (obj *FxMaterial)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterials.Remove">func (me LibFxMaterials) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibMeshes">type LibMeshes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMeshes.AddLoad">func (me LibMeshes) AddLoad(id string, meshProvider MeshProvider, args ...interface{}) (mesh *Mesh, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMeshes.AddNew">func (me LibMeshes) AddNew(id string) (obj *Mesh)</a></dd>
				
			
				
				<dd><a href="#LibScenes">type LibScenes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibScenes.AddNew">func (me LibScenes) AddNew(id string) (obj *Scene)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibScenes.Remove">func (me LibScenes) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LogCategory">type LogCategory</a></dd>
				
				
			
				
				<dd><a href="#Mesh">type Mesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMesh">func NewMesh(id string) (me *Mesh)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuDelete">func (me *Mesh) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUpload">func (me *Mesh) GpuUpload() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUploaded">func (me *Mesh) GpuUploaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Load">func (me *Mesh) Load(provider MeshProvider, args ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Loaded">func (me *Mesh) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Unload">func (me *Mesh) Unload()</a></dd>
				
			
				
				<dd><a href="#MeshBuffer">type MeshBuffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Add">func (me *MeshBuffer) Add(mesh *Mesh) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Remove">func (me *MeshBuffer) Remove(mesh *Mesh)</a></dd>
				
			
				
				<dd><a href="#MeshBuffers">type MeshBuffers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.Add">func (me *MeshBuffers) Add(id string, params *meshBufferParams) (buf *MeshBuffer, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.FloatsPerVertex">func (me *MeshBuffers) FloatsPerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.MemSizePerIndex">func (me *MeshBuffers) MemSizePerIndex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.MemSizePerVertex">func (me *MeshBuffers) MemSizePerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.NewParams">func (me *MeshBuffers) NewParams(numVerts, numIndices int32) (params *meshBufferParams)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.Remove">func (me *MeshBuffers) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabCube">func MeshProviderPrefabCube(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabPlane">func MeshProviderPrefabPlane(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabPyramid">func MeshProviderPrefabPyramid(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabQuad">func MeshProviderPrefabQuad(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabTri">func MeshProviderPrefabTri(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddFaces">func (me *MeshData) AddFaces(faces ...*MeshFace3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddNormals">func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddPositions">func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddTexCoords">func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</a></dd>
				
			
				
				<dd><a href="#MeshFace3">type MeshFace3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshFace3">func NewMeshFace3(tags, id string, verts ...MeshVert) (me *MeshFace3)</a></dd>
				
				
			
				
				<dd><a href="#MeshFaceBase">type MeshFaceBase</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#MeshVert">type MeshVert</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt2">type MeshVertAtt2</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt3">type MeshVertAtt3</a></dd>
				
				
			
				
				<dd><a href="#Model">type Model</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.Clone">func (me *Model) Clone(newModelID string) (clonedModel *Model)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.MatID">func (me *Model) MatID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.SetMatID">func (me *Model) SetMatID(newMatID string)</a></dd>
				
			
				
				<dd><a href="#Models">type Models</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Models.Default">func (me Models) Default() *Model</a></dd>
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.EffectiveMaterial">func (me *Node) EffectiveMaterial() *FxMaterial</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MatID">func (me *Node) MatID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MeshID">func (me *Node) MeshID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.ModelID">func (me *Node) ModelID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMatID">func (me *Node) SetMatID(newMatID string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMeshModelID">func (me *Node) SetMeshModelID(meshID, modelID string)</a></dd>
				
			
				
				<dd><a href="#NodeTransforms">type NodeTransforms</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.ApplyMatrices">func (me *NodeTransforms) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnAnyChanged">func (me *NodeTransforms) OnAnyChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosChanged">func (me *NodeTransforms) OnPosChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosRotChanged">func (me *NodeTransforms) OnPosRotChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosScaleChanged">func (me *NodeTransforms) OnPosScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotChanged">func (me *NodeTransforms) OnRotChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotScaleChanged">func (me *NodeTransforms) OnRotScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotXChanged">func (me *NodeTransforms) OnRotXChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotYChanged">func (me *NodeTransforms) OnRotYChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotZChanged">func (me *NodeTransforms) OnRotZChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnScaleChanged">func (me *NodeTransforms) OnScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnSomeChanged">func (me *NodeTransforms) OnSomeChanged(scale, pos, rotX, rotY, rotZ bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPos">func (me *NodeTransforms) SetPos(pos *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosX">func (me *NodeTransforms) SetPosX(posX float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosXYZ">func (me *NodeTransforms) SetPosXYZ(posX, posY, posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosY">func (me *NodeTransforms) SetPosY(posY float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosZ">func (me *NodeTransforms) SetPosZ(posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRot">func (me *NodeTransforms) SetRot(rot *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotX">func (me *NodeTransforms) SetRotX(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotXYZ">func (me *NodeTransforms) SetRotXYZ(radX, radY, radZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotY">func (me *NodeTransforms) SetRotY(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotZ">func (me *NodeTransforms) SetRotZ(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScale">func (me *NodeTransforms) SetScale(scale *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScaleN">func (me *NodeTransforms) SetScaleN(scale float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScaleXYZ">func (me *NodeTransforms) SetScaleXYZ(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.StepDelta">func (me *NodeTransforms) StepDelta(deltaPerSecond float64) float64</a></dd>
				
			
				
				<dd><a href="#Nodes">type Nodes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.Add">func (me *Nodes) Add(node *Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.AddNew">func (me *Nodes) AddNew(id, meshID, modelID string) (node *Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.Remove">func (me *Nodes) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#PostFx">type PostFx</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PostFx.ApplyEffects">func (me *PostFx) ApplyEffects() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PostFx.DisableEffect">func (me *PostFx) DisableEffect(name string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PostFx.EnableEffect">func (me *PostFx) EnableEffect(name string) (effect *PostFxEffect)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PostFx.ToggleEffect">func (me *PostFx) ToggleEffect(name string) (enabled bool)</a></dd>
				
			
				
				<dd><a href="#PostFxEffect">type PostFxEffect</a></dd>
				
				
			
				
				<dd><a href="#RenderCanvas">type RenderCanvas</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.Main">func (me *RenderCanvas) Main() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.Remove">func (me *RenderCanvas) Remove()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.SetMain">func (me *RenderCanvas) SetMain()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.SetSize">func (me *RenderCanvas) SetSize(relative bool, width, height float64)</a></dd>
				
			
				
				<dd><a href="#RenderCanvases">type RenderCanvases</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.AddNew">func (me *RenderCanvases) AddNew(isMain bool, relative bool, width, height float64) (rc *RenderCanvas)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.Main">func (me RenderCanvases) Main() (main *RenderCanvas)</a></dd>
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewScene">func NewScene() (me *Scene)</a></dd>
				
				
			
				
				<dd><a href="#TimingStats">type TimingStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Average">func (me *TimingStats) Average() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Max">func (me *TimingStats) Max() float64</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-gen-glsl-src.go">-gen-glsl-src.go</a>
			
				<a href="/target/camera.go">camera.go</a>
			
				<a href="/target/controller.go">controller.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/fileio.go">fileio.go</a>
			
				<a href="/target/fx-effect.gt.go">fx-effect.gt.go</a>
			
				<a href="/target/fx-image-2d.gt.go">fx-image-2d.gt.go</a>
			
				<a href="/target/fx-image.go">fx-image.go</a>
			
				<a href="/target/fx-material.gt.go">fx-material.gt.go</a>
			
				<a href="/target/gl-core.go">gl-core.go</a>
			
				<a href="/target/mesh-buffer.go">mesh-buffer.go</a>
			
				<a href="/target/mesh-data.go">mesh-data.go</a>
			
				<a href="/target/mesh-provider.go">mesh-provider.go</a>
			
				<a href="/target/mesh.go">mesh.go</a>
			
				<a href="/target/model.go">model.go</a>
			
				<a href="/target/ng-core.go">ng-core.go</a>
			
				<a href="/target/ng-diag.go">ng-diag.go</a>
			
				<a href="/target/ng-loop.go">ng-loop.go</a>
			
				<a href="/target/ng-options.go">ng-options.go</a>
			
				<a href="/target/ng-stats.go">ng-stats.go</a>
			
				<a href="/target/ng-userio.go">ng-userio.go</a>
			
				<a href="/target/ng.go">ng.go</a>
			
				<a href="/target/node-transform.go">node-transform.go</a>
			
				<a href="/target/node.go">node.go</a>
			
				<a href="/target/nodes.go">nodes.go</a>
			
				<a href="/target/postfx.go">postfx.go</a>
			
				<a href="/target/prerender.go">prerender.go</a>
			
				<a href="/target/render-batch.go">render-batch.go</a>
			
				<a href="/target/render-canvas.go">render-canvas.go</a>
			
				<a href="/target/render-technique.go">render-technique.go</a>
			
				<a href="/target/render.go">render.go</a>
			
				<a href="/target/scene.gt.go">scene.gt.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="Dispose">func <a href="/target/ng.go?s=216:230#L4">Dispose</a></h2>
			<pre>func Dispose()</pre>
			<p>
Call this to &#34;un-init&#34; go:ngine and to release any and all GPU or RAM resources still allocated.
</p>

			
		
			
			
			<h2 id="Init">func <a href="/target/ng.go?s=437:506#L11">Init</a></h2>
			<pre>func Init(options *EngineOptions, initialWinTitle string) (err error)</pre>
			<p>
Initializes go:ngine; this first attempts to initialize OpenGL and then open a window to your supplied specifications with a GL 3.3-or-higher profile.
</p>

			
		
		
			
			
			<h2 id="Camera">type <a href="/target/camera.go?s=209:1347#L1">Camera</a></h2>
			<pre>type Camera struct {
    <span class="comment">//	Optical and imager properties for this camera.</span>
    Perspective struct {
        <span class="comment">//	Whether this is a perspective-projection camera. Defaults to true.</span>
        <span class="comment">//	If false, no projection transformation is applied.</span>
        Use bool

        <span class="comment">//	Vertical field-of-view. Defaults to 37.8493.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        FovY float64

        <span class="comment">//	Distance of the far-plane from the camera. Defaults to 30000.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        ZFar float64

        <span class="comment">//	Distance of the near-plane from the camera. Defaults to 0.3.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        ZNear float64
    }

    <span class="comment">//	Encapsulates the position and direction of this camera.</span>
    Controller Controller

    Rendering struct {
        Enabled bool

        <span class="comment">//	The device-relative or absolute view-port for this Camera.</span>
        ViewPort CameraViewPort

        <span class="comment">//	The ID of the Scene (in Core.Libs.Scenes) this camera is looking at.</span>
        SceneID string

        States struct {
            ugl.RenderStatesBag
            ClearFlags gl.Bitfield
        }
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A camera embodies the eye point of the viewer looking at the visual scene.
</p>


			

			

			

			
				
				<h3 id="NewCamera2D">func <a href="/target/camera.go?s=1413:1454#L43">NewCamera2D</a></h3>
				<pre>func NewCamera2D(depth bool) (me *Camera)</pre>
				<p>
Initializes and returns a new Camera without any projection.
</p>

				
			
				
				<h3 id="NewCamera3D">func <a href="/target/camera.go?s=1576:1607#L50">NewCamera3D</a></h3>
				<pre>func NewCamera3D() (me *Camera)</pre>
				<p>
Initializes and returns a new Camera with perspective projection.
</p>

				
			

			
				
				<h3 id="Camera.ApplyMatrices">func (*Camera) <a href="/target/camera.go?s=2430:2463#L79">ApplyMatrices</a></h3>
				<pre>func (me *Camera) ApplyMatrices()</pre>
				<p>
Applies changes made to the FovY, ZNear and/or ZFar parameters in me.Perspective.
</p>

				
				
			
				
				<h3 id="Camera.SetTechnique">func (*Camera) <a href="/target/camera.go?s=2620:2663#L86">SetTechnique</a></h3>
				<pre>func (me *Camera) SetTechnique(name string)</pre>
				
				
				
			
		
			
			
			<h2 id="CameraViewPort">type <a href="/target/camera.go?s=3455:3670#L128">CameraViewPort</a></h2>
			<pre>type CameraViewPort struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a device-relative or absolute camera view-port.
</p>


			

			

			

			

			
				
				<h3 id="CameraViewPort.SetAbs">func (*CameraViewPort) <a href="/target/camera.go?s=3796:3853#L142">SetAbs</a></h3>
				<pre>func (me *CameraViewPort) SetAbs(x, y, width, height int)</pre>
				<p>
Sets the absolute viewport origin and dimensions in pixels.
</p>

				
				
			
				
				<h3 id="CameraViewPort.SetRel">func (*CameraViewPort) <a href="/target/camera.go?s=4104:4165#L149">SetRel</a></h3>
				<pre>func (me *CameraViewPort) SetRel(x, y, width, height float64)</pre>
				<p>
Sets the device-relative viewport origin and dimensions, with the value 1.0
representing the maximum extent of the viewport on that respective axis.
</p>

				
				
			
		
			
			
			<h2 id="Cameras">type <a href="/target/camera.go?s=2762:2784#L92">Cameras</a></h2>
			<pre>type Cameras []*Camera</pre>
			

			

			

			

			

			
				
				<h3 id="Cameras.Add">func (*Cameras) <a href="/target/camera.go?s=2786:2832#L94">Add</a></h3>
				<pre>func (me *Cameras) Add(camera *Camera) *Camera</pre>
				
				
				
			
				
				<h3 id="Cameras.Insert">func (*Cameras) <a href="/target/camera.go?s=2949:3001#L104">Insert</a></h3>
				<pre>func (me *Cameras) Insert(camera *Camera, index int)</pre>
				
				
				
			
				
				<h3 id="Cameras.Remove">func (*Cameras) <a href="/target/camera.go?s=3220:3261#L118">Remove</a></h3>
				<pre>func (me *Cameras) Remove(camera *Camera)</pre>
				
				
				
			
		
			
			
			<h2 id="Controller">type <a href="/target/controller.go?s=272:1772#L2">Controller</a></h2>
			<pre>type Controller struct {
    <span class="comment">//	The position being manipulated by this Controller.</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    Pos unum.Vec3

    <span class="comment">//	The direction being manipulated by this Controller.</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    Dir unum.Vec3

    <span class="comment">//	Indicates which axis is consider &#34;upward&#34;. This is typically</span>
    <span class="comment">//	the Y-axis, denoted by the default value (0, 1, 0).</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    UpAxis unum.Vec3

    <span class="comment">//	Speed of &#34;moving&#34; in the MoveXyz() methods, in units per second.</span>
    <span class="comment">//	Defaults to 2.</span>
    MoveSpeed float64

    <span class="comment">//	A factor multiplied with MoveSpeed in the MoveXyz() methods. Defaults to 1.</span>
    MoveSpeedupFactor float64

    <span class="comment">//	Speed of &#34;turning&#34; in the TurnXyz() methods, in degrees per second.</span>
    <span class="comment">//	Defaults to 90.</span>
    TurnSpeed float64

    <span class="comment">//	A factor multiplied with TurnSpeed in the TurnXyz() methods. Defaults to 1.</span>
    TurnSpeedupFactor float64

    <span class="comment">//	The maximum degree that TurnUp() allows. Defaults to 90.</span>
    MaxTurnUp float64

    <span class="comment">//	The minimum degree that TurnDown() allows. Defaults to -90.</span>
    MinTurnDown float64
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a position-and-direction and provides methods
manipulating these with respect to each other (e.g. &#34;move forward&#34;
some entity that is rotated facing some arbitrary direction).
</p>


			

			

			

			

			
				
				<h3 id="Controller.BeginUpdate">func (*Controller) <a href="/target/controller.go?s=2774:2809#L76">BeginUpdate</a></h3>
				<pre>func (me *Controller) BeginUpdate()</pre>
				<p>
Temporarily suspends all matrix re-calculations typically occuring inside
the MoveXyz() / TurnXyz() methods. Call this prior to multiple subsequent
calls to any combination of those methods, and/or prior to manually modifying
the Pos, Dir or UpAxis fields of me. Immediately afterwards, be sure to call
EndUpdate() to apply all changes in a final matrix re-calculation.
</p>

				
				
			
				
				<h3 id="Controller.EndUpdate">func (*Controller) <a href="/target/controller.go?s=3143:3176#L84">EndUpdate</a></h3>
				<pre>func (me *Controller) EndUpdate()</pre>
				<p>
Applies all changes made to Pos, Dir or UpAxis since BeginUpdate() was last
called, and recalculates this Controller&#39;s final 4x4 transformation matrix.
Also resumes all matrix re-calculations typically occuring inside the
MoveXyz() / TurnXyz() methods that were suspended since BeginUpdate().
</p>

				
				
			
				
				<h3 id="Controller.MoveBackward">func (*Controller) <a href="/target/controller.go?s=4083:4119#L116">MoveBackward</a></h3>
				<pre>func (me *Controller) MoveBackward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move backward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveDown">func (*Controller) <a href="/target/controller.go?s=4287:4319#L122">MoveDown</a></h3>
				<pre>func (me *Controller) MoveDown()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move downward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveForward">func (*Controller) <a href="/target/controller.go?s=4489:4524#L128">MoveForward</a></h3>
				<pre>func (me *Controller) MoveForward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move forward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveLeft">func (*Controller) <a href="/target/controller.go?s=4693:4725#L134">MoveLeft</a></h3>
				<pre>func (me *Controller) MoveLeft()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move left-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveRight">func (*Controller) <a href="/target/controller.go?s=4922:4955#L140">MoveRight</a></h3>
				<pre>func (me *Controller) MoveRight()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move right-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveUp">func (*Controller) <a href="/target/controller.go?s=5148:5178#L146">MoveUp</a></h3>
				<pre>func (me *Controller) MoveUp()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move upward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.StepSizeMove">func (*Controller) <a href="/target/controller.go?s=5635:5679#L165">StepSizeMove</a></h3>
				<pre>func (me *Controller) StepSizeMove() float64</pre>
				<p>
Returns the current distance that a single MoveXyz() call (per loop iteration) would move.
(Loop.TickDelta * me.MoveSpeed * me.MoveSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.StepSizeTurn">func (*Controller) <a href="/target/controller.go?s=5897:5941#L171">StepSizeTurn</a></h3>
				<pre>func (me *Controller) StepSizeTurn() float64</pre>
				<p>
Returns the current degrees that a single TurnXyz() call (per loop iteration) would turn.
(Loop.TickDelta * me.TurnSpeed * me.TurnSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.TurnDown">func (*Controller) <a href="/target/controller.go?s=6115:6147#L176">TurnDown</a></h3>
				<pre>func (me *Controller) TurnDown()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnDownBy">func (*Controller) <a href="/target/controller.go?s=6290:6335#L181">TurnDownBy</a></h3>
				<pre>func (me *Controller) TurnDownBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeft">func (*Controller) <a href="/target/controller.go?s=6501:6533#L188">TurnLeft</a></h3>
				<pre>func (me *Controller) TurnLeft()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeftBy">func (*Controller) <a href="/target/controller.go?s=6677:6722#L193">TurnLeftBy</a></h3>
				<pre>func (me *Controller) TurnLeftBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnRight">func (*Controller) <a href="/target/controller.go?s=6851:6884#L198">TurnRight</a></h3>
				<pre>func (me *Controller) TurnRight()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnRightBy">func (*Controller) <a href="/target/controller.go?s=7030:7076#L203">TurnRightBy</a></h3>
				<pre>func (me *Controller) TurnRightBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnUp">func (*Controller) <a href="/target/controller.go?s=7202:7232#L208">TurnUp</a></h3>
				<pre>func (me *Controller) TurnUp()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnUpBy">func (*Controller) <a href="/target/controller.go?s=7371:7414#L213">TurnUpBy</a></h3>
				<pre>func (me *Controller) TurnUpBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34; by the specified degress.
</p>

				
				
			
		
			
			
			<h2 id="EngineCore">type <a href="/target/ng-core.go?s=778:1234#L18">EngineCore</a></h2>
			<pre>type EngineCore struct {
    MeshBuffers *MeshBuffers
    Options     EngineOptions
    Libs        struct {
        Effects   LibFxEffects
        Materials LibFxMaterials
        Images    struct {
            I2D LibFxImage2Ds
        }
        Meshes LibMeshes
        Scenes LibScenes
    }
    Rendering struct {
        Canvases RenderCanvases
        PostFx   PostFx
        Samplers struct {
            NoFilteringClamp    ugl.Sampler
            FullFilteringRepeat ugl.Sampler
        }
        <span class="comment">// contains filtered or unexported fields</span>
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineCore a &#34;Singleton&#34; type, only valid use is the core.Core global variable.
The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.
</p>


			

			
				<pre>var (
    <span class="comment">//	The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.</span>
    Core EngineCore
)</pre>
				
			

			

			

			
				
				<h3 id="EngineCore.SyncUpdates">func (*EngineCore) <a href="/target/ng-core.go?s=3031:3066#L107">SyncUpdates</a></h3>
				<pre>func (me *EngineCore) SyncUpdates()</pre>
				
				
				
			
		
			
			
			<h2 id="EngineDiagnostics">type <a href="/target/ng-diag.go?s=299:359#L12">EngineDiagnostics</a></h2>
			<pre>type EngineDiagnostics struct {
    LogCategories LogCategory
}</pre>
			

			

			
				<pre>var (
    Diag EngineDiagnostics
)</pre>
				
			

			

			

			
				
				<h3 id="EngineDiagnostics.Log">func (*EngineDiagnostics) <a href="/target/ng-diag.go?s=361:446#L16">Log</a></h3>
				<pre>func (me *EngineDiagnostics) Log(cat LogCategory, fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiagnostics.LogErr">func (*EngineDiagnostics) <a href="/target/ng-diag.go?s=523:569#L22">LogErr</a></h3>
				<pre>func (me *EngineDiagnostics) LogErr(err error)</pre>
				
				
				
			
				
				<h3 id="EngineDiagnostics.LogMeshes">func (*EngineDiagnostics) <a href="/target/ng-diag.go?s=594:668#L26">LogMeshes</a></h3>
				<pre>func (me *EngineDiagnostics) LogMeshes(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiagnostics.LogMisc">func (*EngineDiagnostics) <a href="/target/ng-diag.go?s=713:785#L30">LogMisc</a></h3>
				<pre>func (me *EngineDiagnostics) LogMisc(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiagnostics.LogShaders">func (*EngineDiagnostics) <a href="/target/ng-diag.go?s=828:903#L34">LogShaders</a></h3>
				<pre>func (me *EngineDiagnostics) LogShaders(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
		
			
			
			<h2 id="EngineLoop">type <a href="/target/ng-loop.go?s=403:1178#L8">EngineLoop</a></h2>
			<pre>type EngineLoop struct {
    <span class="comment">//	Set to true by EngineLoop.Loop(). Set to false to stop looping.</span>
    IsLooping bool

    <span class="comment">//	The tick-time when the EngineLoop.OnSec() callback was last invoked.</span>
    SecTickLast float64

    <span class="comment">//	While EngineLoop.Loop() is running, is set to the current &#34;tick-time&#34;:</span>
    <span class="comment">//	the time in seconds expired ever since EngineLoop.Loop() was last called.</span>
    TickNow float64

    <span class="comment">//	While EngineLoop.Loop() is running, is set to the previous tick-time.</span>
    TickLast float64

    <span class="comment">//	The delta between TickLast and TickNow.</span>
    TickDelta float64

    <span class="comment">//	While EngineLoop.Loop() is running, this callback is invoked every loop iteration (ie. once per frame).</span>
    OnLoop func()

    <span class="comment">//	While EngineLoop.Loop() is running, this callback is invoked at least and at most once per second.</span>
    OnSec func()
}</pre>
			<p>
Consider EngineLoop a &#34;Singleton&#34; type, only valid use is the core.Loop global variable.
Manages your main-thread&#39;s &#34;game loop&#34;.
</p>


			

			
				<pre>var (
    <span class="comment">//	Manages your main-thread&#39;s &#34;game loop&#34;. You&#39;ll need to call it&#39;s Loop() method once after go:ngine initialization (see samples).</span>
    Loop EngineLoop
)</pre>
				
			

			

			

			
				
				<h3 id="EngineLoop.Loop">func (*EngineLoop) <a href="/target/ng-loop.go?s=1441:1469#L39">Loop</a></h3>
				<pre>func (me *EngineLoop) Loop()</pre>
				<p>
Initiates a rendering loop. This method returns only when the loop is stopped for whatever reason.
</p>
<p>
(Before entering the loop, this method performs a one-off GC invokation.)
</p>

				
				
			
				
				<h3 id="EngineLoop.Stop">func (*EngineLoop) <a href="/target/ng-loop.go?s=3432:3460#L97">Stop</a></h3>
				<pre>func (me *EngineLoop) Stop()</pre>
				<p>
Stops the currently running EngineLoop.Loop().
</p>

				
				
			
				
				<h3 id="EngineLoop.Time">func (*EngineLoop) <a href="/target/ng-loop.go?s=3575:3611#L102">Time</a></h3>
				<pre>func (me *EngineLoop) Time() float64</pre>
				<p>
Returns the number of seconds expired ever since EngineLoop.Loop() was last called.
</p>

				
				
			
		
			
			
			<h2 id="EngineOptions">type <a href="/target/ng-options.go?s=242:839#L1">EngineOptions</a></h2>
			<pre>type EngineOptions struct {
    <span class="comment">//	The base directory path for asset file paths.</span>
    AssetRootDirPath string

    Initialization struct {
        GlCoreContext bool
    }

    Rendering struct {
        DefaultClearColor ugl.GlVec4

        <span class="comment">//	Name for the default render technique of a Camera2D,</span>
        <span class="comment">//	defaults to the currently only implementation &#34;rt_unlit3&#34;.</span>
        DefaultTechnique2D string

        <span class="comment">//	Name for the default render technique of a Camera3D,</span>
        <span class="comment">//	defaults to the currently only implementation &#34;rt_unlit3&#34;.</span>
        DefaultTechnique3D string
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineOptions a &#34;Singleton&#34; type, only valid use is the one instance you created for core.Init().
Various &#34;global&#34; (rather than use-case-specific) options.
</p>


			

			

			

			
				
				<h3 id="NewEngineOptions">func <a href="/target/ng-options.go?s=914:1042#L26">NewEngineOptions</a></h3>
				<pre>func NewEngineOptions(assetRootDirPath string, winWidth, winHeight, winSwapInterval int, winFullScreen bool) (me *EngineOptions)</pre>
				<p>
Allocates, initializes and returns a new core.EngineOptions instance.
</p>

				
			

			
		
			
			
			<h2 id="EngineStats">type <a href="/target/ng-stats.go?s=299:2364#L4">EngineStats</a></h2>
			<pre>type EngineStats struct {
    <span class="comment">//	Gives the total number of frames rendered during the &#34;previous&#34; (not the current) second. Good enough for just a simple-minded FPS indicator.</span>
    FpsLastSec int

    <span class="comment">//	This TimingStats instance combines all the individual FrameFoo fields to track over time (both average and maximum) total cost per frame.</span>
    Frame TimingStats

    <span class="comment">//	&#34;Rendering&#34; consists of a CPU-side and a GPU-side cost.</span>
    <span class="comment">//	This TimingStats instance combines both to track over time (both average and maximum) total rendering cost per frame.</span>
    FrameRenderBoth TimingStats

    <span class="comment">//	The CPU-side cost of rendering comprises geometry culling, and batching draw calls to the GPU.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) CPU-side rendering cost per frame.</span>
    FrameRenderCpu TimingStats

    <span class="comment">//	The GPU-side cost of rendering comprises execution of all draw calls sent by the CPU-side, plus waiting for V-sync if enabled.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) GPU-side rendering cost per frame.</span>
    FrameRenderGpu TimingStats

    <span class="comment">//	&#34;Core code&#34; comprises non-rendering go:ngine logic executed every frame.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;core code&#34; cost per frame.</span>
    FrameCoreCode TimingStats

    <span class="comment">//	&#34;User code&#34; comprises user-specific logic executed every frame in your own EngineLoop.OnLoop() callback.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;user code&#34; cost per frame.</span>
    FrameUserCode TimingStats

    <span class="comment">//	During the Loop, the Go Garbge Collector is invoked at least and at most once per second.</span>
    <span class="comment">//	</span>
    <span class="comment">//	Forcing GC &#34;that often&#34; practically guarantees it will almost never have so much work to do as to</span>
    <span class="comment">//	noticably block user interaction --- 99.9% of the time it will complete in less than 10ms (and almost-always under 1ms).</span>
    <span class="comment">//	</span>
    <span class="comment">//	This TimingStats instance over time tracks the maximum and average time spent on that 1x-per-second GC invokation (but does not track any other GC invokations).</span>
    Gc TimingStats
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineStats a &#34;Singleton&#34; type, only valid use is the core.Stats global variable.
Tracks various go:ngine performance indicators over time.
</p>


			

			
				<pre>var (
    <span class="comment">//	Tracks various go:ngine performance counters over time.</span>
    Stats EngineStats
)</pre>
				
			

			

			

			
				
				<h3 id="EngineStats.AverageFps">func (*EngineStats) <a href="/target/ng-stats.go?s=2452:2495#L44">AverageFps</a></h3>
				<pre>func (me *EngineStats) AverageFps() float64</pre>
				<p>
Returns the average number of frames-per-second since Loop.Loop() was last called.
</p>

				
				
			
				
				<h3 id="EngineStats.TotalFrames">func (*EngineStats) <a href="/target/ng-stats.go?s=2620:2664#L52">TotalFrames</a></h3>
				<pre>func (me *EngineStats) TotalFrames() float64</pre>
				
				
				
			
		
			
			
			<h2 id="EngineUserIO">type <a href="/target/ng-userio.go?s=495:1044#L8">EngineUserIO</a></h2>
			<pre>type EngineUserIO struct {
    <span class="comment">//	Minimum delay for EngineUserIO.KeyToggled() method, in seconds. Defaults to 0.25.</span>
    KeyToggleMinDelay float64

    <span class="comment">//	Minimum delay, in seconds, to wait after the last window-resize event received from</span>
    <span class="comment">//	the OS before notifying the rendering runtime of the new window dimensions.</span>
    <span class="comment">//	Defaults to 0.25.</span>
    WinResizeMinDelay float64
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineUserIO a &#34;Singleton&#34; type, only valid use is the core.UserIO global variable.
Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).
</p>


			

			
				<pre>var (
    <span class="comment">//	Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).</span>
    UserIO EngineUserIO
)</pre>
				
			

			

			

			
				
				<h3 id="EngineUserIO.IifKeyF">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2808:2881#L79">IifKeyF</a></h3>
				<pre>func (me *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</pre>
				<p>
Returns ifTrue if the specified key is pressed, otherwise returns ifFalse.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressed">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2996:3044#L87">KeyPressed</a></h3>
				<pre>func (me *EngineUserIO) KeyPressed(key int) bool</pre>
				<p>
Returns true if the specified key is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressedWhich">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3135:3191#L92">KeyPressedWhich</a></h3>
				<pre>func (me *EngineUserIO) KeyPressedWhich(keys ...int) int</pre>
				<p>
Returns the first in keys that is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyToggled">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4157:4205#L122">KeyToggled</a></h3>
				<pre>func (me *EngineUserIO) KeyToggled(key int) bool</pre>
				<p>
Returns true if the specified key has been &#34;toggled&#34;, ie. its pressed-state changed within the last me.KeyToggleMinDelay seconds.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3357:3413#L102">KeysPressedAll2</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</pre>
				<p>
Returns true if both specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3523:3583#L107">KeysPressedAll3</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if all three specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3718:3774#L112">KeysPressedAny2</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</pre>
				<p>
Returns true if any of the two specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3890:3950#L117">KeysPressedAny3</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if any of the three specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.SetWinTitle">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4440:4492#L131">SetWinTitle</a></h3>
				<pre>func (me *EngineUserIO) SetWinTitle(newTitle string)</pre>
				<p>
Sets the window title to newTitle.
</p>

				
				
			
				
				<h3 id="EngineUserIO.WinHeight">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4576:4615#L136">WinHeight</a></h3>
				<pre>func (me *EngineUserIO) WinHeight() int</pre>
				<p>
Returns the height of the window in pixels.
</p>

				
				
			
				
				<h3 id="EngineUserIO.WinWidth">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4698:4736#L141">WinWidth</a></h3>
				<pre>func (me *EngineUserIO) WinWidth() int</pre>
				<p>
Returns the width of the window in pixels.
</p>

				
				
			
		
			
			
			<h2 id="FxColorOrTexture">type <a href="/target/fx-effect.gt.go?s=201:620#L1">FxColorOrTexture</a></h2>
			<pre>type FxColorOrTexture struct {
    <span class="comment">//	If set, the color is sourced from this value.</span>
    Color *ugfx.Rgba64

    <span class="comment">//	If Color is nil, the color is sourced from a 2D texture image.</span>
    Texture struct {
        <span class="comment">//	The ID of the FxImage2D in Core.Libs.Images.I2D</span>
        Image2ID string

        <span class="comment">//	Describes filtering and wrapping when sampling the texture image.</span>
        <span class="comment">//	Defaults to Core.Rendering.Samplers.FullFilteringRepeat.</span>
        Sampler *ugl.Sampler
    }
}</pre>
			<p>
Declares a source of color information:
either pointing to an FxImage2D or a 64-bit RGBA color.
</p>


			

			

			

			
				
				<h3 id="NewFxColor">func <a href="/target/fx-effect.gt.go?s=704:759#L16">NewFxColor</a></h3>
				<pre>func NewFxColor(rgba ...float64) (me *FxColorOrTexture)</pre>
				<p>
Creates and returns a new FxColorOrTexture that points to the specified color.
</p>

				
			
				
				<h3 id="NewFxTexture">func <a href="/target/fx-effect.gt.go?s=1017:1096#L23">NewFxTexture</a></h3>
				<pre>func NewFxTexture(image2ID string, sampler *ugl.Sampler) (me *FxColorOrTexture)</pre>
				<p>
Creates and returns a new FxColorOrTexture that points to the specified texture image.
If sampler is nil, Core.Rendering.Samplers.FullFilteringRepeat is used for me.Texture.Sampler.
</p>

				
			

			
		
			
			
			<h2 id="FxEffect">type <a href="/target/fx-effect.gt.go?s=1278:1385#L32">FxEffect</a></h2>
			<pre>type FxEffect struct {
    <span class="comment">//	The source for diffuse color information. Required.</span>
    Diffuse *FxColorOrTexture
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxEffect">func <a href="/target/fx-effect.gt.go?s=1557:1590#L46">NewFxEffect</a></h3>
				<pre>func NewFxEffect() (me *FxEffect)</pre>
				<p>
Initializes and returns a new FxEffect with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="FxImage2D">type <a href="/target/fx-image-2d.gt.go?s=126:205#L4">FxImage2D</a></h2>
			<pre>type FxImage2D struct {
    FxImageBase
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxImage2D">func <a href="/target/fx-image-2d.gt.go?s=3217:3252#L140">NewFxImage2D</a></h3>
				<pre>func NewFxImage2D() (me *FxImage2D)</pre>
				<p>
Initializes and returns a new FxImage2D with default parameters.
</p>

				
			

			
				
				<h3 id="FxImage2D.GpuSync">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=376:418#L21">GpuSync</a></h3>
				<pre>func (me *FxImage2D) GpuSync() (err error)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.IsRemote">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=2138:2183#L94">IsRemote</a></h3>
				<pre>func (me *FxImage2D) IsRemote() (remote bool)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Load">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=513:540#L28">Load</a></h3>
				<pre>func (me *FxImage2D) Load()</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Loaded">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=1609:1643#L77">Loaded</a></h3>
				<pre>func (me *FxImage2D) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Unload">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=2227:2256#L99">Unload</a></h3>
				<pre>func (me *FxImage2D) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageBase">type <a href="/target/fx-image.go?s=59:272#L1">FxImageBase</a></h2>
			<pre>type FxImageBase struct {
    OnAsyncDone      func()
    OnLoad           FxImageOnLoad
    AsyncNumAttempts int
    InitFrom         struct {
        RawData []byte
        RefUrl  string
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxImageBase.GpuDelete">func (*FxImageBase) <a href="/target/fx-image.go?s=492:526#L23">GpuDelete</a></h3>
				<pre>func (me *FxImageBase) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="FxImageBase.GpuSynced">func (*FxImageBase) <a href="/target/fx-image.go?s=573:612#L28">GpuSynced</a></h3>
				<pre>func (me *FxImageBase) GpuSynced() bool</pre>
				
				
				
			
				
				<h3 id="FxImageBase.NoAutoMips">func (*FxImageBase) <a href="/target/fx-image.go?s=638:673#L32">NoAutoMips</a></h3>
				<pre>func (me *FxImageBase) NoAutoMips()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageOnLoad">type <a href="/target/fx-image.go?s=804:867#L42">FxImageOnLoad</a></h2>
			<pre>type FxImageOnLoad func(img interface{}, err error, async bool)</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxMaterial">type <a href="/target/fx-material.gt.go?s=103:538#L1">FxMaterial</a></h2>
			<pre>type FxMaterial struct {
    <span class="comment">//	This effect is used by default for all faces that do not fall</span>
    <span class="comment">//	under any of the associations in the FaceEffects field.</span>
    DefaultEffectID string

    <span class="comment">//	Associates certain individual faces or tags of faces</span>
    <span class="comment">//	with specific effect IDs.</span>
    FaceEffects struct {
        <span class="comment">//	Associates face tags with effect IDs.</span>
        ByTag map[string]string

        <span class="comment">//	Associates specific face IDs with effect IDs.</span>
        ByID map[string]string
    }
}</pre>
			<p>
A material binds effects (FxEffect in Core.Libs.Effects) to geometry (Model or Node).
</p>


			

			

			

			
				
				<h3 id="NewFxMaterial">func <a href="/target/fx-material.gt.go?s=805:842#L21">NewFxMaterial</a></h3>
				<pre>func NewFxMaterial() (me *FxMaterial)</pre>
				<p>
Initializes and returns a new FxMaterial with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="LibFxEffects">type <a href="/target/fx-effect.gt.go?s=1708:1746#L53">LibFxEffects</a></h2>
			<pre>type LibFxEffects map[string]*FxEffect</pre>
			<p>
A hash-table of FxEffects associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxEffects.AddNew">func (LibFxEffects) <a href="/target/fx-effect.gt.go?s=1872:1928#L57">AddNew</a></h3>
				<pre>func (me LibFxEffects) AddNew(id string) (obj *FxEffect)</pre>
				<p>
Creates and initializes a new FxEffect with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxEffects.Remove">func (LibFxEffects) <a href="/target/fx-effect.gt.go?s=2127:2167#L74">Remove</a></h3>
				<pre>func (me LibFxEffects) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibFxImage2Ds">type <a href="/target/fx-image-2d.gt.go?s=3372:3412#L147">LibFxImage2Ds</a></h2>
			<pre>type LibFxImage2Ds map[string]*FxImage2D</pre>
			<p>
A hash-table of FxImage2Ds associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxImage2Ds.AddNew">func (LibFxImage2Ds) <a href="/target/fx-image-2d.gt.go?s=3539:3597#L151">AddNew</a></h3>
				<pre>func (me LibFxImage2Ds) AddNew(id string) (obj *FxImage2D)</pre>
				<p>
Creates and initializes a new FxImage2D with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxImage2Ds.Remove">func (LibFxImage2Ds) <a href="/target/fx-image-2d.gt.go?s=3800:3841#L168">Remove</a></h3>
				<pre>func (me LibFxImage2Ds) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibFxMaterials">type <a href="/target/fx-material.gt.go?s=964:1006#L28">LibFxMaterials</a></h2>
			<pre>type LibFxMaterials map[string]*FxMaterial</pre>
			<p>
A hash-table of FxMaterials associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxMaterials.AddNew">func (LibFxMaterials) <a href="/target/fx-material.gt.go?s=1134:1194#L32">AddNew</a></h3>
				<pre>func (me LibFxMaterials) AddNew(id string) (obj *FxMaterial)</pre>
				<p>
Creates and initializes a new FxMaterial with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxMaterials.Remove">func (LibFxMaterials) <a href="/target/fx-material.gt.go?s=1401:1443#L49">Remove</a></h3>
				<pre>func (me LibFxMaterials) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibMeshes">type <a href="/target/mesh.go?s=5101:5132#L127">LibMeshes</a></h2>
			<pre>type LibMeshes map[string]*Mesh</pre>
			<p>
A hash-table of Meshs associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibMeshes.AddLoad">func (LibMeshes) <a href="/target/mesh.go?s=5350:5460#L137">AddLoad</a></h3>
				<pre>func (me LibMeshes) AddLoad(id string, meshProvider MeshProvider, args ...interface{}) (mesh *Mesh, err error)</pre>
				
				
				
			
				
				<h3 id="LibMeshes.AddNew">func (LibMeshes) <a href="/target/mesh.go?s=5254:5303#L131">AddNew</a></h3>
				<pre>func (me LibMeshes) AddNew(id string) (obj *Mesh)</pre>
				<p>
Creates and initializes a new Mesh with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
		
			
			
			<h2 id="LibScenes">type <a href="/target/scene.gt.go?s=459:491#L16">LibScenes</a></h2>
			<pre>type LibScenes map[string]*Scene</pre>
			<p>
A hash-table of Scenes associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibScenes.AddNew">func (LibScenes) <a href="/target/scene.gt.go?s=614:664#L20">AddNew</a></h3>
				<pre>func (me LibScenes) AddNew(id string) (obj *Scene)</pre>
				<p>
Creates and initializes a new Scene with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibScenes.Remove">func (LibScenes) <a href="/target/scene.gt.go?s=851:888#L37">Remove</a></h3>
				<pre>func (me LibScenes) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LogCategory">type <a href="/target/ng-diag.go?s=69:89#L1">LogCategory</a></h2>
			<pre>type LogCategory int</pre>
			

			
				<pre>const (
    LogCatMisc    LogCategory = 1
    LogCatMeshes  LogCategory = 2
    LogCatShaders LogCategory = 4
    LogCatAll     LogCategory = LogCatMeshes | LogCatMisc | LogCatShaders
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="Mesh">type <a href="/target/mesh.go?s=92:497#L1">Mesh</a></h2>
			<pre>type Mesh struct {
    Models Models
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewMesh">func <a href="/target/mesh.go?s=4951:4985#L120">NewMesh</a></h3>
				<pre>func NewMesh(id string) (me *Mesh)</pre>
				<p>
Initializes and returns a new Mesh with default parameters.
</p>

				
			

			
				
				<h3 id="Mesh.GpuDelete">func (*Mesh) <a href="/target/mesh.go?s=629:656#L18">GpuDelete</a></h3>
				<pre>func (me *Mesh) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUpload">func (*Mesh) <a href="/target/mesh.go?s=707:746#L24">GpuUpload</a></h3>
				<pre>func (me *Mesh) GpuUpload() (err error)</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUploaded">func (*Mesh) <a href="/target/mesh.go?s=2697:2731#L57">GpuUploaded</a></h3>
				<pre>func (me *Mesh) GpuUploaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Load">func (*Mesh) <a href="/target/mesh.go?s=2758:2834#L61">Load</a></h3>
				<pre>func (me *Mesh) Load(provider MeshProvider, args ...interface{}) (err error)</pre>
				
				
				
			
				
				<h3 id="Mesh.Loaded">func (*Mesh) <a href="/target/mesh.go?s=4787:4816#L111">Loaded</a></h3>
				<pre>func (me *Mesh) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Unload">func (*Mesh) <a href="/target/mesh.go?s=4844:4868#L115">Unload</a></h3>
				<pre>func (me *Mesh) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffer">type <a href="/target/mesh-buffer.go?s=1716:2125#L61">MeshBuffer</a></h2>
			<pre>type MeshBuffer struct {
    MemSizeIndices, MemSizeVertices int32
    Params                          *meshBufferParams
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffer.Add">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=3216:3265#L98">Add</a></h3>
				<pre>func (me *MeshBuffer) Add(mesh *Mesh) (err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffer.Remove">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=3997:4037#L128">Remove</a></h3>
				<pre>func (me *MeshBuffer) Remove(mesh *Mesh)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffers">type <a href="/target/mesh-buffer.go?s=353:409#L4">MeshBuffers</a></h2>
			<pre>type MeshBuffers struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffers.Add">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=521:613#L14">Add</a></h3>
				<pre>func (me *MeshBuffers) Add(id string, params *meshBufferParams) (buf *MeshBuffer, err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.FloatsPerVertex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1003:1049#L35">FloatsPerVertex</a></h3>
				<pre>func (me *MeshBuffers) FloatsPerVertex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.MemSizePerIndex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1210:1256#L40">MemSizePerIndex</a></h3>
				<pre>func (me *MeshBuffers) MemSizePerIndex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.MemSizePerVertex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1272:1319#L44">MemSizePerVertex</a></h3>
				<pre>func (me *MeshBuffers) MemSizePerVertex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.NewParams">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1399:1486#L49">NewParams</a></h3>
				<pre>func (me *MeshBuffers) NewParams(numVerts, numIndices int32) (params *meshBufferParams)</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.Remove">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1592:1632#L54">Remove</a></h3>
				<pre>func (me *MeshBuffers) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshData">type <a href="/target/mesh-data.go?s=2089:2315#L78">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">//	Vertex positions</span>
    Positions []MeshVertAtt3

    <span class="comment">//	Vertex texture coordinates</span>
    TexCoords []MeshVertAtt2

    <span class="comment">//	Vertex normals</span>
    Normals []MeshVertAtt3

    <span class="comment">//	Indexed triangle definitions</span>
    Faces []MeshFace3
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="MeshProviderPrefabCube">func <a href="/target/mesh-provider.go?s=306:386#L1">MeshProviderPrefabCube</a></h3>
				<pre>func MeshProviderPrefabCube(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a cube with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 12 triangle faces with IDs &#34;t0&#34; through &#34;t11&#34;.
These faces are classified in 6 distinct tags: &#34;front&#34;,&#34;back&#34;,&#34;top&#34;,&#34;bottom&#34;,&#34;right&#34;,&#34;left&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabPlane">func <a href="/target/mesh-provider.go?s=2237:2318#L19">MeshProviderPrefabPlane</a></h3>
				<pre>func MeshProviderPrefabPlane(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a flat ground plane with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 2 triangle faces with IDs &#34;t0&#34; through &#34;t1&#34;.
These faces are all classified with tag: &#34;plane&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabPyramid">func <a href="/target/mesh-provider.go?s=3080:3163#L34">MeshProviderPrefabPyramid</a></h3>
				<pre>func MeshProviderPrefabPyramid(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a pyramid with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 4 triangle faces with IDs &#34;t0&#34; through &#34;t3&#34;.
These faces are all classified with tag: &#34;pyr&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabQuad">func <a href="/target/mesh-provider.go?s=4177:4257#L51">MeshProviderPrefabQuad</a></h3>
				<pre>func MeshProviderPrefabQuad(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a quad with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 2 triangle faces with IDs &#34;t0&#34; through &#34;t1&#34;.
These faces are all classified with tag: &#34;quad&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabTri">func <a href="/target/mesh-provider.go?s=4954:5033#L65">MeshProviderPrefabTri</a></h3>
				<pre>func MeshProviderPrefabTri(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a triangle with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 1 triangle face with ID &#34;t0&#34; and tag &#34;tri&#34;.
</p>

				
			
				
				<h3 id="NewMeshData">func <a href="/target/mesh-data.go?s=2371:2404#L93">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
				
				<h3 id="MeshData.AddFaces">func (*MeshData) <a href="/target/mesh-data.go?s=2482:2531#L99">AddFaces</a></h3>
				<pre>func (me *MeshData) AddFaces(faces ...*MeshFace3)</pre>
				<p>
Adds all specified Faces to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddNormals">func (*MeshData) <a href="/target/mesh-data.go?s=2819:2874#L111">AddNormals</a></h3>
				<pre>func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</pre>
				<p>
Adds all the specified Normals to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddPositions">func (*MeshData) <a href="/target/mesh-data.go?s=2651:2710#L106">AddPositions</a></h3>
				<pre>func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</pre>
				<p>
Adds all specified Positions to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddTexCoords">func (*MeshData) <a href="/target/mesh-data.go?s=2979:3038#L116">AddTexCoords</a></h3>
				<pre>func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</pre>
				<p>
Adds all the specified TexCoords to this MeshData.
</p>

				
				
			
		
			
			
			<h2 id="MeshFace3">type <a href="/target/mesh-data.go?s=435:553#L11">MeshFace3</a></h2>
			<pre>type MeshFace3 struct {
    <span class="comment">//	The indexed vertices making up this triangle.</span>
    V [3]MeshVert

    <span class="comment">//	ID, Tags</span>
    MeshFaceBase
}</pre>
			<p>
Represents an indexed triangle.
</p>


			

			

			

			
				
				<h3 id="NewMeshFace3">func <a href="/target/mesh-data.go?s=768:837#L22">NewMeshFace3</a></h3>
				<pre>func NewMeshFace3(tags, id string, verts ...MeshVert) (me *MeshFace3)</pre>
				<p>
Creates and initializes a new MeshVert with the specified tags,
ID and verts, and returns it. tags may be empty or contain multiple
classification tags separated by spaces, which will be split into Tags.
</p>

				
			

			
		
			
			
			<h2 id="MeshFaceBase">type <a href="/target/mesh-data.go?s=252:398#L2">MeshFaceBase</a></h2>
			<pre>type MeshFaceBase struct {
    <span class="comment">//	Mesh-unique identifier for this face.</span>
    ID string

    <span class="comment">//	Arbitrary classification tags for this face.</span>
    Tags []string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/mesh-data.go?s=188:250#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Provides MeshData for constructing a Mesh. An implementation
might load a certain file format or procedurally generate
the returned MeshData.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVert">type <a href="/target/mesh-data.go?s=1588:1775#L58">MeshVert</a></h2>
			<pre>type MeshVert struct {
    <span class="comment">//	Index of the vertex position</span>
    PosIndex uint32

    <span class="comment">//	Index of the texture-coordinate.</span>
    TexCoordIndex uint32

    <span class="comment">//	Index of the vertex normal.</span>
    NormalIndex uint32
}</pre>
			<p>
Represents an indexed vertex in a MeshFace3.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt2">type <a href="/target/mesh-data.go?s=1882:1910#L71">MeshVertAtt2</a></h2>
			<pre>type MeshVertAtt2 [2]float32</pre>
			<p>
Represents a 2-component vertex attribute in a MeshData.
(such as for example texture-coordinates)
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt3">type <a href="/target/mesh-data.go?s=2011:2039#L75">MeshVertAtt3</a></h2>
			<pre>type MeshVertAtt3 [3]float32</pre>
			<p>
Represents a 3-component vertex attribute in a MeshData
(such as for example vertex-normals)
</p>


			

			

			

			

			
		
			
			
			<h2 id="Model">type <a href="/target/model.go?s=593:674#L8">Model</a></h2>
			<pre>type Model struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Model is a parameterized instantiation of its parent Mesh geometry
with unique appearance, material or other properties.
</p>
<p>
Each Mesh provides at least one Model, the &#34;default model&#34; (with ID &#34;&#34;),
accessible via someMesh.Models.Default(). To create new models for a Mesh,
call someMesh.Models[&#34;sourceModelID&#34;].Clone(&#34;newModelID&#34;).
</p>


			

			

			

			

			
				
				<h3 id="Model.Clone">func (*Model) <a href="/target/model.go?s=881:943#L22">Clone</a></h3>
				<pre>func (me *Model) Clone(newModelID string) (clonedModel *Model)</pre>
				<p>
Creates a copy of me and adds it to the parent Mesh&#39;s Models
hash-table under the specified newModelID.
</p>

				
				
			
				
				<h3 id="Model.MatID">func (*Model) <a href="/target/model.go?s=1116:1147#L30">MatID</a></h3>
				<pre>func (me *Model) MatID() string</pre>
				
				
				
			
				
				<h3 id="Model.SetMatID">func (*Model) <a href="/target/model.go?s=1170:1212#L34">SetMatID</a></h3>
				<pre>func (me *Model) SetMatID(newMatID string)</pre>
				
				
				
			
		
			
			
			<h2 id="Models">type <a href="/target/model.go?s=96:125#L1">Models</a></h2>
			<pre>type Models map[string]*Model</pre>
			<p>
A hash-table of Models associated with their ID.
Used only for Mesh.Models.
</p>


			

			

			

			

			
				
				<h3 id="Models.Default">func (Models) <a href="/target/model.go?s=190:223#L1">Default</a></h3>
				<pre>func (me Models) Default() *Model</pre>
				<p>
Returns the default Model (with ID &#34;&#34;) for the parent Mesh.
</p>

				
				
			
		
			
			
			<h2 id="Node">type <a href="/target/node.go?s=143:678#L1">Node</a></h2>
			<pre>type Node struct {

    <span class="comment">//	If true, this Node is ignored by the rendering runtime.</span>
    Disabled bool

    <span class="comment">//	Allows the Node to recursively define hierarchy.</span>
    ChildNodes Nodes

    <span class="comment">//	Encapsulates all parent-relative transformations for this Node.</span>
    Transform NodeTransforms
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Declares a point of interest in a Scene.
</p>


			

			

			

			

			
				
				<h3 id="Node.EffectiveMaterial">func (*Node) <a href="/target/node.go?s=882:929#L27">EffectiveMaterial</a></h3>
				<pre>func (me *Node) EffectiveMaterial() *FxMaterial</pre>
				
				
				
			
				
				<h3 id="Node.MatID">func (*Node) <a href="/target/node.go?s=995:1025#L34">MatID</a></h3>
				<pre>func (me *Node) MatID() string</pre>
				
				
				
			
				
				<h3 id="Node.MeshID">func (*Node) <a href="/target/node.go?s=1048:1079#L38">MeshID</a></h3>
				<pre>func (me *Node) MeshID() string</pre>
				
				
				
			
				
				<h3 id="Node.ModelID">func (*Node) <a href="/target/node.go?s=1103:1135#L42">ModelID</a></h3>
				<pre>func (me *Node) ModelID() string</pre>
				
				
				
			
				
				<h3 id="Node.SetMatID">func (*Node) <a href="/target/node.go?s=1160:1201#L46">SetMatID</a></h3>
				<pre>func (me *Node) SetMatID(newMatID string)</pre>
				
				
				
			
				
				<h3 id="Node.SetMeshModelID">func (*Node) <a href="/target/node.go?s=1298:1352#L52">SetMeshModelID</a></h3>
				<pre>func (me *Node) SetMeshModelID(meshID, modelID string)</pre>
				
				
				
			
		
			
			
			<h2 id="NodeTransforms">type <a href="/target/node-transform.go?s=613:1147#L6">NodeTransforms</a></h2>
			<pre>type NodeTransforms struct {
    <span class="comment">//	Translation of the from origin, if any.</span>
    Pos unum.Vec3

    <span class="comment">//	Rotation for each axis in radians, if any.</span>
    Rot unum.Vec3

    <span class="comment">//	Scaling of this node, if any. Defaults to (1, 1, 1) for no scaling.</span>
    Scale unum.Vec3

    <span class="comment">//	An arbitrary additional transformation to apply. Defaults to the 4x4 identity matrix for &#39;none&#39;.</span>
    Other unum.Mat4
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents one or more transformations of a Node.
This is only used by Node objects, which initialize their NodeTransforms with the
proper defaults and associate themselves with their NodeTransforms. (Any other
NodeTransforms are invalid.)
</p>
<p>
A single NodeTransforms encapsulates a number of private 4x4 matrices that are
set from its exported fields via the SetFoo() or OnFooChanged() methods, and
are multiplied together into a final single 4x4 transformation matrix via the
ApplyMatrices() (or OnFooChanged()) methods.
</p>


			

			

			

			

			
				
				<h3 id="NodeTransforms.ApplyMatrices">func (*NodeTransforms) <a href="/target/node-transform.go?s=1679:1720#L38">ApplyMatrices</a></h3>
				<pre>func (me *NodeTransforms) ApplyMatrices()</pre>
				<p>
Creates a final single 4x4 transformation matrix for all transformations
in me. It is onlx this matrix that is used by the rendering runtime.
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnAnyChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=2346:2386#L54">OnAnyChanged</a></h3>
				<pre>func (me *NodeTransforms) OnAnyChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the scaling matrix from the current me.Scale value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=2653:2693#L67">OnPosChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosRotChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=2914:2957#L75">OnPosRotChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosRotChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3180:3225#L84">OnPosScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosScaleChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the scaling matrix from the current me.Scale value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3508:3548#L98">OnRotChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotChanged()</pre>
				<p>
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3767:3812#L106">OnRotScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotScaleChanged()</pre>
				<p>
Updates the scaling matrix from the current me.Scale value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotXChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4059:4100#L118">OnRotXChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotXChanged()</pre>
				<p>
Updates the X-axis rotation matrix from the current me.Rot.X value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotYChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4327:4368#L129">OnRotYChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotYChanged()</pre>
				<p>
Updates the Y-axis rotation matrix from the current me.Rot.Y value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotZChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4595:4636#L140">OnRotZChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotZChanged()</pre>
				<p>
Updates the Z-axis rotation matrix from the current me.Rot.Z value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4856:4898#L151">OnScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnScaleChanged()</pre>
				<p>
Updates the scaling matrix from the current me.Scale value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnSomeChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=5402:5476#L162">OnSomeChanged</a></h3>
				<pre>func (me *NodeTransforms) OnSomeChanged(scale, pos, rotX, rotY, rotZ bool)</pre>
				<p>
If pos is true, updates the translation matrix from the current me.Pos value.
If scale is true, updates the scaling matrix from the current me.Scale value.
If rotX is true, updates the X-axis rotation matrix from the current me.Rot.X value.
If rotY is true, updates the Y-axis rotation matrix from the current me.Rot.Y value.
If rotZ is true, updates the Z-axis rotation matrix from the current me.Rot.Z value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPos">func (*NodeTransforms) <a href="/target/node-transform.go?s=5718:5766#L182">SetPos</a></h3>
				<pre>func (me *NodeTransforms) SetPos(pos *unum.Vec3)</pre>
				<p>
Sets me.Pos and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosX">func (*NodeTransforms) <a href="/target/node-transform.go?s=5905:5952#L192">SetPosX</a></h3>
				<pre>func (me *NodeTransforms) SetPosX(posX float64)</pre>
				<p>
Sets me.Pos.X and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6035:6096#L198">SetPosXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetPosXYZ(posX, posY, posZ float64)</pre>
				<p>
Sets me.Pos and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosY">func (*NodeTransforms) <a href="/target/node-transform.go?s=6213:6260#L204">SetPosY</a></h3>
				<pre>func (me *NodeTransforms) SetPosY(posY float64)</pre>
				<p>
Sets me.Pos.Y and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6345:6392#L210">SetPosZ</a></h3>
				<pre>func (me *NodeTransforms) SetPosZ(posZ float64)</pre>
				<p>
Sets me.Pos.Z and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRot">func (*NodeTransforms) <a href="/target/node-transform.go?s=6475:6523#L216">SetRot</a></h3>
				<pre>func (me *NodeTransforms) SetRot(rot *unum.Vec3)</pre>
				<p>
Sets me.Rot and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotX">func (*NodeTransforms) <a href="/target/node-transform.go?s=6662:6708#L226">SetRotX</a></h3>
				<pre>func (me *NodeTransforms) SetRotX(rad float64)</pre>
				<p>
Sets me.Rot.X and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6791:6852#L232">SetRotXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetRotXYZ(radX, radY, radZ float64)</pre>
				<p>
Sets me.Rot and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotY">func (*NodeTransforms) <a href="/target/node-transform.go?s=6969:7015#L238">SetRotY</a></h3>
				<pre>func (me *NodeTransforms) SetRotY(rad float64)</pre>
				<p>
Sets me.Rot.Y and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=7100:7146#L244">SetRotZ</a></h3>
				<pre>func (me *NodeTransforms) SetRotZ(rad float64)</pre>
				<p>
Sets me.Rot.Z and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScale">func (*NodeTransforms) <a href="/target/node-transform.go?s=7233:7285#L250">SetScale</a></h3>
				<pre>func (me *NodeTransforms) SetScale(scale *unum.Vec3)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScaleN">func (*NodeTransforms) <a href="/target/node-transform.go?s=7428:7478#L260">SetScaleN</a></h3>
				<pre>func (me *NodeTransforms) SetScaleN(scale float64)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScaleXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=7566:7620#L265">SetScaleXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetScaleXYZ(x, y, z float64)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.StepDelta">func (*NodeTransforms) <a href="/target/node-transform.go?s=7772:7839#L271">StepDelta</a></h3>
				<pre>func (me *NodeTransforms) StepDelta(deltaPerSecond float64) float64</pre>
				<p>
Returns the result of multiplying deltaPerSecond with EngineLoop.TickDelta.
</p>

				
				
			
		
			
			
			<h2 id="Nodes">type <a href="/target/nodes.go?s=77:277#L1">Nodes</a></h2>
			<pre>type Nodes struct {
    <span class="comment">//	The underlying hash-table. NOT to be modified directly.</span>
    <span class="comment">//	ONLY use the methods defined on the Nodes type to add,</span>
    <span class="comment">//	remove or move nodes.</span>
    M map[string]*Node
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A hash-table of child nodes. Only used for Node.ChildNodes.
</p>


			

			

			

			

			
				
				<h3 id="Nodes.Add">func (*Nodes) <a href="/target/nodes.go?s=456:488#L10">Add</a></h3>
				<pre>func (me *Nodes) Add(node *Node)</pre>
				<p>
Removes node from its previous parent Node (if any)
and adds it to me.M under its ID.
</p>

				
				
			
				
				<h3 id="Nodes.AddNew">func (*Nodes) <a href="/target/nodes.go?s=743:807#L20">AddNew</a></h3>
				<pre>func (me *Nodes) AddNew(id, meshID, modelID string) (node *Node)</pre>
				<p>
Creates a new Node with the specified ID, binds it to the
specified Mesh and Model, adds it to me.M and returns it.
</p>

				
				
			
				
				<h3 id="Nodes.Remove">func (*Nodes) <a href="/target/nodes.go?s=935:969#L27">Remove</a></h3>
				<pre>func (me *Nodes) Remove(id string)</pre>
				<p>
Removes the Node with the specified ID from me.M.
</p>

				
				
			
		
			
			
			<h2 id="PostFx">type <a href="/target/postfx.go?s=538:699#L11">PostFx</a></h2>
			<pre>type PostFx struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ONLY used for Core.Rendering.PostFx.
Represents the final shading stage in a rendered frame and is always used, but initially all effects are disabled.
Always takes the image produced by the Core.Rendering.Canvases.Main render canvas and blits it to the screen,
applying the currently enabled effects, if any.
</p>


			

			

			

			

			
				
				<h3 id="PostFx.ApplyEffects">func (*PostFx) <a href="/target/postfx.go?s=1048:1092#L25">ApplyEffects</a></h3>
				<pre>func (me *PostFx) ApplyEffects() (err error)</pre>
				<p>
Switches me to a postfx shader program that has all effects enabled as specified
by all previous DisableEffect() / EnableEffect() / ToggleEffect() calls since the last ApplyEffects() call.
If that shader program does not yet exist, builds it. If that fails, a non-nil err is returned.
</p>

				
				
			
				
				<h3 id="PostFx.DisableEffect">func (*PostFx) <a href="/target/postfx.go?s=1840:1884#L52">DisableEffect</a></h3>
				<pre>func (me *PostFx) DisableEffect(name string)</pre>
				<p>
Deactivates the specified post-processing full-screen effect.
After all necessary calls to DisableEffect() / EnableEffect() / ToggleEffect(), be sure to call ApplyEffects() once.
</p>

				
				
			
				
				<h3 id="PostFx.EnableEffect">func (*PostFx) <a href="/target/postfx.go?s=2099:2165#L58">EnableEffect</a></h3>
				<pre>func (me *PostFx) EnableEffect(name string) (effect *PostFxEffect)</pre>
				<p>
Activates the specified post-processing full-screen effect.
After all necessary calls to DisableEffect() / EnableEffect() / ToggleEffect(), be sure to call ApplyEffects() once.
</p>

				
				
			
				
				<h3 id="PostFx.ToggleEffect">func (*PostFx) <a href="/target/postfx.go?s=2828:2886#L80">ToggleEffect</a></h3>
				<pre>func (me *PostFx) ToggleEffect(name string) (enabled bool)</pre>
				<p>
Activates or deactivates the specified post-processing full-screen effect.
After all necessary calls to DisableEffect() / EnableEffect() / ToggleEffect(), be sure to call ApplyEffects() once.
Returns whether this call has activated (true) or deactivated (false) the specified effect.
</p>

				
				
			
		
			
			
			<h2 id="PostFxEffect">type <a href="/target/postfx.go?s=144:214#L3">PostFxEffect</a></h2>
			<pre>type PostFxEffect struct {
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderCanvas">type <a href="/target/render-canvas.go?s=206:705#L5">RenderCanvas</a></h2>
			<pre>type RenderCanvas struct {
    <span class="comment">//	This should be an non-negative integer, it&#39;s a float64 just to avoid a</span>
    <span class="comment">//	type conversion. How often this RenderCanvas is included in rendering:</span>
    <span class="comment">//	1 = every frame (this is the default value)</span>
    <span class="comment">//	2 = every 2nd frame</span>
    <span class="comment">//	8 = every 8th frame</span>
    <span class="comment">//	0 = this RenderCanvas is disabled for rendering</span>
    EveryNthFrame float64

    Cameras Cameras
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents a surface (texture framebuffer) that can be rendered to.
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvas.Main">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1514:1549#L40">Main</a></h3>
				<pre>func (me *RenderCanvas) Main() bool</pre>
				<p>
Returns whether me is the primary / &#34;main&#34; render canvas (if multiple render canvases are present).
The &#34;main&#34; render canvas is the one whose output image is blitted to the screen / window by Core.Rendering.PostFx.
</p>

				
				
			
				
				<h3 id="RenderCanvas.Remove">func (*RenderCanvas) <a href="/target/render-canvas.go?s=2073:2105#L57">Remove</a></h3>
				<pre>func (me *RenderCanvas) Remove()</pre>
				<p>
Removes me from Core.Rendering.Canvases and deletes its associated GPU resources.
This renders me invalid for further use.
</p>

				
				
			
				
				<h3 id="RenderCanvas.SetMain">func (*RenderCanvas) <a href="/target/render-canvas.go?s=2678:2711#L74">SetMain</a></h3>
				<pre>func (me *RenderCanvas) SetMain()</pre>
				<p>
Declares me the primary / &#34;main&#34; render canvas (if multiple render canvases are present).
The &#34;main&#34; render canvas is the one whose output image is blitted to the screen / window by Core.Rendering.PostFx.
</p>

				
				
			
				
				<h3 id="RenderCanvas.SetSize">func (*RenderCanvas) <a href="/target/render-canvas.go?s=3098:3167#L85">SetSize</a></h3>
				<pre>func (me *RenderCanvas) SetSize(relative bool, width, height float64)</pre>
				<p>
Sets the 2 dimensions of this render canvas.
If relative is true, width and height are interpreted relative to the resolution of the OpenGL context&#39;s default framebuffer, with 1 being 100%.
Otherwise, width and height are absolute pixel dimensions.
</p>

				
				
			
		
			
			
			<h2 id="RenderCanvases">type <a href="/target/render-canvas.go?s=3400:3435#L94">RenderCanvases</a></h2>
			<pre>type RenderCanvases []*RenderCanvas</pre>
			<p>
Only used for Core.Rendering.Canvases.
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvases.AddNew">func (*RenderCanvases) <a href="/target/render-canvas.go?s=3663:3765#L105">AddNew</a></h3>
				<pre>func (me *RenderCanvases) AddNew(isMain bool, relative bool, width, height float64) (rc *RenderCanvas)</pre>
				<p>
Adds a new RenderCanvas and returns it.
The relative, width and height values are passed to a call to SetSize().
</p>

				
				
			
				
				<h3 id="RenderCanvases.Main">func (RenderCanvases) <a href="/target/render-canvas.go?s=4215:4267#L119">Main</a></h3>
				<pre>func (me RenderCanvases) Main() (main *RenderCanvas)</pre>
				<p>
Returns whatever RenderCanvas in me is currently declared the primary / &#34;main&#34; render canvas (if multiple render canvases are present).
The &#34;main&#34; render canvas is the one whose output image is blitted to the screen / window by Core.Rendering.PostFx.
</p>

				
				
			
		
			
			
			<h2 id="Scene">type <a href="/target/scene.gt.go?s=43:119#L1">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	The root Node for this scene graph.</span>
    RootNode Node
}</pre>
			<p>
Represents a scene graph.
</p>


			

			

			

			
				
				<h3 id="NewScene">func <a href="/target/scene.gt.go?s=320:347#L9">NewScene</a></h3>
				<pre>func NewScene() (me *Scene)</pre>
				<p>
Initializes and returns a new Scene with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="TimingStats">type <a href="/target/ng-stats.go?s=2769:2941#L57">TimingStats</a></h2>
			<pre>type TimingStats struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Helps track average and maximum cost for a variety of performance indicators.
</p>


			

			

			

			

			
				
				<h3 id="TimingStats.Average">func (*TimingStats) <a href="/target/ng-stats.go?s=3010:3050#L63">Average</a></h3>
				<pre>func (me *TimingStats) Average() float64</pre>
				<p>
Returns the average cost tracked by this performance indicator.
</p>

				
				
			
				
				<h3 id="TimingStats.Max">func (*TimingStats) <a href="/target/ng-stats.go?s=3642:3678#L86">Max</a></h3>
				<pre>func (me *TimingStats) Max() float64</pre>
				<p>
Returns the maximum cost tracked by this performance indicator.
</p>

				
				
			
		
		</div>
	

	








		</div></div>
	</body>
</html>