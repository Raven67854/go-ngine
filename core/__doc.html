<html>
	<head>
		<title>Package github.com/go3d/go-ngine/core</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/core</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/core"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *core* package provides go:ngine client-side core functionality such as rendering and user I/O.
</p>
<p>
________
</p>
<p>
First off, the go:ngine 3 RULES of bugless(er) development:
</p>
<p>
1. you do NOT set exported fields directly, those are provided for simplified read-access. If a field is
meant to be modifiable, there will be a *SetFoo()* method or it will be documented explicitly as directly
modifiable, but such instances will be rare.
</p>
<p>
2. you do NOT instantiate exported struct types directly, as in &#34;new(Material)&#34; or &#34;&amp;Material {}&#34;. Many of
those are exported only for documentation, but are to be instantiated only inside the go:ngine package.
For types to be instantiated by package-external code (ie. your code), go:ngine packages provide constructor
functions -- often in collections, ie. mat := Materials.New(&#34;arg&#34;) instead of, say, mat := NewMaterial(&#34;arg&#34;).
</p>
<p>
3. Those 2 are *default* assumptions and modes of operation -- there are a few &#34;if you know what you&#39;re
doing&#34; exemptions and those are (or will be) explicitly documented as such.
</p>
<p>
________
</p>
<p>
TODO pkg doc
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Dispose">func Dispose()</a></dd>
			
				
				<dd><a href="#Init">func Init(options *EngineOptions, winTitle string) (err error)</a></dd>
			
				
				<dd><a href="#Sfmt">func Sfmt(format string, fmtArgs ...interface{}) string</a></dd>
			
			
				
				<dd><a href="#Camera">type Camera</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.SetTechnique">func (me *Camera) SetTechnique(name string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.ToggleTechnique">func (me *Camera) ToggleTechnique()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.UpdatePerspective">func (me *Camera) UpdatePerspective()</a></dd>
				
			
				
				<dd><a href="#CameraOptions">type CameraOptions</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraOptions.ToggleGlBackfaceCulling">func (me *CameraOptions) ToggleGlBackfaceCulling()</a></dd>
				
			
				
				<dd><a href="#CameraViewPort">type CameraViewPort</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewPort.SetAbs">func (me *CameraViewPort) SetAbs(x, y, width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewPort.SetRel">func (me *CameraViewPort) SetRel(x, y, width, height float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewPort.Update">func (me *CameraViewPort) Update()</a></dd>
				
			
				
				<dd><a href="#Controller">type Controller</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.BeginUpdate">func (me *Controller) BeginUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.EndUpdate">func (me *Controller) EndUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveBackward">func (me *Controller) MoveBackward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveDown">func (me *Controller) MoveDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveForward">func (me *Controller) MoveForward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveLeft">func (me *Controller) MoveLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveRight">func (me *Controller) MoveRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveUp">func (me *Controller) MoveUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeMove">func (me *Controller) StepSizeMove() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeTurn">func (me *Controller) StepSizeTurn() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDown">func (me *Controller) TurnDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeft">func (me *Controller) TurnLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRight">func (me *Controller) TurnRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUp">func (me *Controller) TurnUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.UpdateMatrix">func (me *Controller) UpdateMatrix()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.UpdateMatrixRot">func (me *Controller) UpdateMatrixRot()</a></dd>
				
			
				
				<dd><a href="#EngineCore">type EngineCore</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineCore.SyncUpdates">func (me *EngineCore) SyncUpdates()</a></dd>
				
			
				
				<dd><a href="#EngineLoop">type EngineLoop</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Loop">func (me *EngineLoop) Loop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Stop">func (me *EngineLoop) Stop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Time">func (me *EngineLoop) Time() float64</a></dd>
				
			
				
				<dd><a href="#EngineOptions">type EngineOptions</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEngineOptions">func NewEngineOptions(assetRootDirPath string, winWidth, winHeight, winSwapInterval int, winFullScreen bool) (me *EngineOptions)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineOptions.GlClearColor">func (me *EngineOptions) GlClearColor() ugl.GlVec4</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineOptions.SetGlClearColor">func (me *EngineOptions) SetGlClearColor(col ugl.GlVec4)</a></dd>
				
			
				
				<dd><a href="#EngineStats">type EngineStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.AverageFps">func (me *EngineStats) AverageFps() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.TotalFrames">func (me *EngineStats) TotalFrames() float64</a></dd>
				
			
				
				<dd><a href="#EngineUserIO">type EngineUserIO</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.IifKeyF">func (me *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressed">func (me *EngineUserIO) KeyPressed(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressedWhich">func (me *EngineUserIO) KeyPressedWhich(keys ...int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyToggled">func (me *EngineUserIO) KeyToggled(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll2">func (me *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll3">func (me *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny2">func (me *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny3">func (me *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.SetWinTitle">func (me *EngineUserIO) SetWinTitle(newTitle string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.WinHeight">func (me *EngineUserIO) WinHeight() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.WinWidth">func (me *EngineUserIO) WinWidth() int</a></dd>
				
			
				
				<dd><a href="#Material">type Material</a></dd>
				
				
			
				
				<dd><a href="#Mesh">type Mesh</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuDelete">func (me *Mesh) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUpload">func (me *Mesh) GpuUpload() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUploaded">func (me *Mesh) GpuUploaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Loaded">func (me *Mesh) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Unload">func (me *Mesh) Unload()</a></dd>
				
			
				
				<dd><a href="#MeshBuffer">type MeshBuffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Add">func (me *MeshBuffer) Add(mesh *Mesh) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Remove">func (me *MeshBuffer) Remove(mesh *Mesh)</a></dd>
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#Model">type Model</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.Clone">func (me *Model) Clone(modelName string) (clonedModel *Model)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.MatName">func (me *Model) MatName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.SetMatName">func (me *Model) SetMatName(newMatName string)</a></dd>
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MatName">func (me *Node) MatName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.Material">func (me *Node) Material() *Material</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MeshModelName">func (me *Node) MeshModelName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MeshName">func (me *Node) MeshName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMatName">func (me *Node) SetMatName(newMatName string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMeshModelName">func (me *Node) SetMeshModelName(meshName, modelName string)</a></dd>
				
			
				
				<dd><a href="#NodeTransforms">type NodeTransforms</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.ApplyMatrices">func (me *NodeTransforms) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnAnyChanged">func (me *NodeTransforms) OnAnyChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosChanged">func (me *NodeTransforms) OnPosChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosRotChanged">func (me *NodeTransforms) OnPosRotChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnPosScaleChanged">func (me *NodeTransforms) OnPosScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotChanged">func (me *NodeTransforms) OnRotChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotScaleChanged">func (me *NodeTransforms) OnRotScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotXChanged">func (me *NodeTransforms) OnRotXChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotYChanged">func (me *NodeTransforms) OnRotYChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnRotZChanged">func (me *NodeTransforms) OnRotZChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnScaleChanged">func (me *NodeTransforms) OnScaleChanged()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.OnSomeChanged">func (me *NodeTransforms) OnSomeChanged(scale, pos, rotX, rotY, rotZ bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPos">func (me *NodeTransforms) SetPos(pos *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosX">func (me *NodeTransforms) SetPosX(posX float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosXYZ">func (me *NodeTransforms) SetPosXYZ(posX, posY, posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosY">func (me *NodeTransforms) SetPosY(posY float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetPosZ">func (me *NodeTransforms) SetPosZ(posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRot">func (me *NodeTransforms) SetRot(rot *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotX">func (me *NodeTransforms) SetRotX(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotXYZ">func (me *NodeTransforms) SetRotXYZ(radX, radY, radZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotY">func (me *NodeTransforms) SetRotY(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetRotZ">func (me *NodeTransforms) SetRotZ(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScale">func (me *NodeTransforms) SetScale(scale *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScaleN">func (me *NodeTransforms) SetScaleN(scale float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.SetScaleXYZ">func (me *NodeTransforms) SetScaleXYZ(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransforms.StepDelta">func (me *NodeTransforms) StepDelta(deltaPerSecond float64) float64</a></dd>
				
			
				
				<dd><a href="#RenderCanvas">type RenderCanvas</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.Dispose">func (me *RenderCanvas) Dispose()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.SetCameraIDs">func (me *RenderCanvas) SetCameraIDs(camIDs ...string)</a></dd>
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewScene">func NewScene() (me *Scene)</a></dd>
				
				
			
				
				<dd><a href="#Texture">type Texture</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Texture.GpuDelete">func (me *Texture) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Texture.GpuSync">func (me *Texture) GpuSync()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Texture.GpuSynced">func (me *Texture) GpuSynced() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Texture.Loaded">func (me *Texture) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Texture.SuppressMipMaps">func (me *Texture) SuppressMipMaps()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Texture.Unload">func (me *Texture) Unload()</a></dd>
				
			
				
				<dd><a href="#TextureProvider">type TextureProvider</a></dd>
				
				
			
				
				<dd><a href="#TimingStats">type TimingStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Average">func (me *TimingStats) Average() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Max">func (me *TimingStats) Max() float64</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-auto-generated-glsl-src.go">-auto-generated-glsl-src.go</a>
			
				<a href="/target/camera-options.go">camera-options.go</a>
			
				<a href="/target/camera.go">camera.go</a>
			
				<a href="/target/controller.go">controller.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/fileio.go">fileio.go</a>
			
				<a href="/target/gl-core.go">gl-core.go</a>
			
				<a href="/target/gl-shaders.go">gl-shaders.go</a>
			
				<a href="/target/material.go">material.go</a>
			
				<a href="/target/mesh-buffer.go">mesh-buffer.go</a>
			
				<a href="/target/mesh-data.go">mesh-data.go</a>
			
				<a href="/target/mesh-provider.go">mesh-provider.go</a>
			
				<a href="/target/mesh.go">mesh.go</a>
			
				<a href="/target/model.go">model.go</a>
			
				<a href="/target/ng-core.go">ng-core.go</a>
			
				<a href="/target/ng-loop.go">ng-loop.go</a>
			
				<a href="/target/ng-options.go">ng-options.go</a>
			
				<a href="/target/ng-stats.go">ng-stats.go</a>
			
				<a href="/target/ng-userio.go">ng-userio.go</a>
			
				<a href="/target/ng.go">ng.go</a>
			
				<a href="/target/node-transform.go">node-transform.go</a>
			
				<a href="/target/node.go">node.go</a>
			
				<a href="/target/render-canvas.go">render-canvas.go</a>
			
				<a href="/target/render-technique.go">render-technique.go</a>
			
				<a href="/target/scene.go">scene.go</a>
			
				<a href="/target/texture-params.go">texture-params.go</a>
			
				<a href="/target/texture-provider.go">texture-provider.go</a>
			
				<a href="/target/texture.go">texture.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">//	Manages your main-thread&#39;s &#34;game loop&#34;. You&#39;ll need to call it&#39;s Loop() method once after go:ngine initialization (see samples).</span>
    Loop *EngineLoop

    <span class="comment">//	The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.</span>
    Core *EngineCore

    <span class="comment">//	Tracks various go:ngine performance counters over time.</span>
    Stats *EngineStats

    <span class="comment">//	Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).</span>
    UserIO = newUserIO()
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A collection of all &#34;mesh providers&#34; known to go:ngine.</span>
    MeshProviders = &amp;meshProviders{meshProviderPrefabCube, meshProviderPrefabPlane, meshProviderPrefabPyramid, meshProviderPrefabQuad, meshProviderPrefabTri}
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A collection of all &#34;texture providers&#34; known to go:ngine.</span>
    <span class="comment">//	Usage: core.TextureProviders.IoReader, core.TextureProviders.LocalFile, or core.TextureProviders.RemoteFile</span>
    TextureProviders = &amp;textureProviders{textureProviderIoReader, textureProviderLocalFile, textureProviderRemoteFile}
)</pre>
				
			
		
		
			
			
			<h2 id="Dispose">func <a href="/target/ng.go?s=660:674#L14">Dispose</a></h2>
			<pre>func Dispose()</pre>
			<p>
Call this to &#34;un-init&#34; go:ngine and to release any and all GPU or RAM resources still allocated.
</p>

			
		
			
			
			<h2 id="Init">func <a href="/target/ng.go?s=938:1000#L24">Init</a></h2>
			<pre>func Init(options *EngineOptions, winTitle string) (err error)</pre>
			<p>
Initializes go:ngine; this first attempts to initialize OpenGL and then open a window to your supplied specifications with a GL 3.2-or-higher profile.
</p>

			
		
			
			
			<h2 id="Sfmt">func <a href="/target/ng.go?s=1548:1603#L47">Sfmt</a></h2>
			<pre>func Sfmt(format string, fmtArgs ...interface{}) string</pre>
			<p>
A short-hand for fmt.Sprintf. Feel free to ignore.
</p>

			
		
		
			
			
			<h2 id="Camera">type <a href="/target/camera.go?s=315:526#L12">Camera</a></h2>
			<pre>type Camera struct {
    ViewPort   *CameraViewPort
    MatProj    *unum.Mat4
    Options    *CameraOptions
    Controller *Controller
    Disabled   bool
    SceneName  string
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Camera.SetTechnique">func (*Camera) <a href="/target/camera.go?s=1379:1422#L51">SetTechnique</a></h3>
				<pre>func (me *Camera) SetTechnique(name string)</pre>
				
				
				
			
				
				<h3 id="Camera.ToggleTechnique">func (*Camera) <a href="/target/camera.go?s=1521:1556#L57">ToggleTechnique</a></h3>
				<pre>func (me *Camera) ToggleTechnique()</pre>
				
				
				
			
				
				<h3 id="Camera.UpdatePerspective">func (*Camera) <a href="/target/camera.go?s=2105:2142#L88">UpdatePerspective</a></h3>
				<pre>func (me *Camera) UpdatePerspective()</pre>
				
				
				
			
		
			
			
			<h2 id="CameraOptions">type <a href="/target/camera-options.go?s=14:94#L1">CameraOptions</a></h2>
			<pre>type CameraOptions struct {
    BackfaceCulling   bool
    FovY, ZFar, ZNear float64
}</pre>
			

			

			

			

			

			
				
				<h3 id="CameraOptions.ToggleGlBackfaceCulling">func (*CameraOptions) <a href="/target/camera-options.go?s=228:278#L6">ToggleGlBackfaceCulling</a></h3>
				<pre>func (me *CameraOptions) ToggleGlBackfaceCulling()</pre>
				
				
				
			
		
			
			
			<h2 id="CameraViewPort">type <a href="/target/camera.go?s=2275:2522#L93">CameraViewPort</a></h2>
			<pre>type CameraViewPort struct {
    Absolute               bool
    RelX, RelY, RelW, RelH float64
    AbsX, AbsY, AbsW, AbsH int
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="CameraViewPort.SetAbs">func (*CameraViewPort) <a href="/target/camera.go?s=2649:2706#L109">SetAbs</a></h3>
				<pre>func (me *CameraViewPort) SetAbs(x, y, width, height int)</pre>
				
				
				
			
				
				<h3 id="CameraViewPort.SetRel">func (*CameraViewPort) <a href="/target/camera.go?s=2802:2863#L114">SetRel</a></h3>
				<pre>func (me *CameraViewPort) SetRel(x, y, width, height float64)</pre>
				
				
				
			
				
				<h3 id="CameraViewPort.Update">func (*CameraViewPort) <a href="/target/camera.go?s=2960:2994#L119">Update</a></h3>
				<pre>func (me *CameraViewPort) Update()</pre>
				
				
				
			
		
			
			
			<h2 id="Controller">type <a href="/target/controller.go?s=108:439#L1">Controller</a></h2>
			<pre>type Controller struct {
    Pos, Dir, UpAxis             *unum.Vec3
    MoveSpeed, MoveSpeedupFactor float64
    TurnSpeed, TurnSpeedupFactor float64
    MaxTurnUp, MinTurnDown       float64
    Mat, MatTrans, MatLook       *unum.Mat4
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Controller.BeginUpdate">func (*Controller) <a href="/target/controller.go?s=1436:1471#L42">BeginUpdate</a></h3>
				<pre>func (me *Controller) BeginUpdate()</pre>
				
				
				
			
				
				<h3 id="Controller.EndUpdate">func (*Controller) <a href="/target/controller.go?s=1500:1533#L46">EndUpdate</a></h3>
				<pre>func (me *Controller) EndUpdate()</pre>
				
				
				
			
				
				<h3 id="Controller.MoveBackward">func (*Controller) <a href="/target/controller.go?s=1602:1638#L52">MoveBackward</a></h3>
				<pre>func (me *Controller) MoveBackward()</pre>
				
				
				
			
				
				<h3 id="Controller.MoveDown">func (*Controller) <a href="/target/controller.go?s=1722:1754#L57">MoveDown</a></h3>
				<pre>func (me *Controller) MoveDown()</pre>
				
				
				
			
				
				<h3 id="Controller.MoveForward">func (*Controller) <a href="/target/controller.go?s=1841:1876#L62">MoveForward</a></h3>
				<pre>func (me *Controller) MoveForward()</pre>
				
				
				
			
				
				<h3 id="Controller.MoveLeft">func (*Controller) <a href="/target/controller.go?s=1960:1992#L67">MoveLeft</a></h3>
				<pre>func (me *Controller) MoveLeft()</pre>
				
				
				
			
				
				<h3 id="Controller.MoveRight">func (*Controller) <a href="/target/controller.go?s=2103:2136#L72">MoveRight</a></h3>
				<pre>func (me *Controller) MoveRight()</pre>
				
				
				
			
				
				<h3 id="Controller.MoveUp">func (*Controller) <a href="/target/controller.go?s=2247:2277#L77">MoveUp</a></h3>
				<pre>func (me *Controller) MoveUp()</pre>
				
				
				
			
				
				<h3 id="Controller.StepSizeMove">func (*Controller) <a href="/target/controller.go?s=2364:2408#L82">StepSizeMove</a></h3>
				<pre>func (me *Controller) StepSizeMove() float64</pre>
				
				
				
			
				
				<h3 id="Controller.StepSizeTurn">func (*Controller) <a href="/target/controller.go?s=2475:2519#L86">StepSizeTurn</a></h3>
				<pre>func (me *Controller) StepSizeTurn() float64</pre>
				
				
				
			
				
				<h3 id="Controller.TurnDown">func (*Controller) <a href="/target/controller.go?s=2586:2618#L90">TurnDown</a></h3>
				<pre>func (me *Controller) TurnDown()</pre>
				
				
				
			
				
				<h3 id="Controller.TurnLeft">func (*Controller) <a href="/target/controller.go?s=2736:2768#L98">TurnLeft</a></h3>
				<pre>func (me *Controller) TurnLeft()</pre>
				
				
				
			
				
				<h3 id="Controller.TurnRight">func (*Controller) <a href="/target/controller.go?s=2847:2880#L104">TurnRight</a></h3>
				<pre>func (me *Controller) TurnRight()</pre>
				
				
				
			
				
				<h3 id="Controller.TurnUp">func (*Controller) <a href="/target/controller.go?s=2959:2989#L110">TurnUp</a></h3>
				<pre>func (me *Controller) TurnUp()</pre>
				
				
				
			
				
				<h3 id="Controller.UpdateMatrix">func (*Controller) <a href="/target/controller.go?s=3105:3141#L118">UpdateMatrix</a></h3>
				<pre>func (me *Controller) UpdateMatrix()</pre>
				
				
				
			
				
				<h3 id="Controller.UpdateMatrixRot">func (*Controller) <a href="/target/controller.go?s=3348:3387#L128">UpdateMatrixRot</a></h3>
				<pre>func (me *Controller) UpdateMatrixRot()</pre>
				
				
				
			
		
			
			
			<h2 id="EngineCore">type <a href="/target/ng-core.go?s=884:1206#L15">EngineCore</a></h2>
			<pre>type EngineCore struct {
    Cameras            cameras
    Canvases           renderCanvases
    DefaultCanvasIndex int
    Materials          materials
    MeshBuffers        *meshBuffers
    Meshes             meshes
    Options            *EngineOptions
    Scenes             scenes
    Textures           textures
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineCore a &#34;Singleton&#34; type, only valid use is the core.Core global variable.
The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.
</p>


			

			

			

			

			
				
				<h3 id="EngineCore.SyncUpdates">func (*EngineCore) <a href="/target/ng-core.go?s=2759:2794#L94">SyncUpdates</a></h3>
				<pre>func (me *EngineCore) SyncUpdates()</pre>
				
				
				
			
		
			
			
			<h2 id="EngineLoop">type <a href="/target/ng-loop.go?s=218:993#L3">EngineLoop</a></h2>
			<pre>type EngineLoop struct {
    <span class="comment">//	Set to true by EngineLoop.Loop(). Set to false to stop looping.</span>
    IsLooping bool

    <span class="comment">//	The tick-time when the EngineLoop.OnSec() callback was last invoked.</span>
    SecTickLast float64

    <span class="comment">//	While EngineLoop.Loop() is running, is set to the current &#34;tick-time&#34;:</span>
    <span class="comment">//	the time in seconds expired ever since EngineLoop.Loop() was last called.</span>
    TickNow float64

    <span class="comment">//	While EngineLoop.Loop() is running, is set to the previous tick-time.</span>
    TickLast float64

    <span class="comment">//	The delta between TickLast and TickNow.</span>
    TickDelta float64

    <span class="comment">//	While EngineLoop.Loop() is running, this callback is invoked every loop iteration (ie. once per frame).</span>
    OnLoop func()

    <span class="comment">//	While EngineLoop.Loop() is running, this callback is invoked at least and at most once per second.</span>
    OnSec func()
}</pre>
			<p>
Consider EngineLoop a &#34;Singleton&#34; type, only valid use is the core.Loop global variable.
Manages your main-thread&#39;s &#34;game loop&#34;.
</p>


			

			

			

			

			
				
				<h3 id="EngineLoop.Loop">func (*EngineLoop) <a href="/target/ng-loop.go?s=1284:1312#L35">Loop</a></h3>
				<pre>func (me *EngineLoop) Loop()</pre>
				<p>
Initiates a rendering loop. This method returns only when the loop is stopped for whatever reason.
</p>
<p>
(Before entering the loop, this method performs a one-off GC invokation.)
</p>

				
				
			
				
				<h3 id="EngineLoop.Stop">func (*EngineLoop) <a href="/target/ng-loop.go?s=2959:2987#L87">Stop</a></h3>
				<pre>func (me *EngineLoop) Stop()</pre>
				<p>
Stops the currently running EngineLoop.Loop().
</p>

				
				
			
				
				<h3 id="EngineLoop.Time">func (*EngineLoop) <a href="/target/ng-loop.go?s=3102:3138#L92">Time</a></h3>
				<pre>func (me *EngineLoop) Time() float64</pre>
				<p>
Returns the number of seconds expired ever since EngineLoop.Loop() was last called.
</p>

				
				
			
		
			
			
			<h2 id="EngineOptions">type <a href="/target/ng-options.go?s=263:724#L1">EngineOptions</a></h2>
			<pre>type EngineOptions struct {
    <span class="comment">//	The base directory path for asset file paths.</span>
    AssetRootDirPath string

    <span class="comment">//	Name for the default render technique, currently &#34;rt_unlit_colored&#34;</span>
    DefaultRenderTechnique string

    <span class="comment">//	All textures default to these params unless they have their own params set.</span>
    DefaultTextureParams *textureParams
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineOptions a &#34;Singleton&#34; type, only valid use is the one instance you created for core.Init().
Various &#34;global&#34; (rather than use-case-specific) options.
</p>


			

			

			

			
				
				<h3 id="NewEngineOptions">func <a href="/target/ng-options.go?s=799:927#L17">NewEngineOptions</a></h3>
				<pre>func NewEngineOptions(assetRootDirPath string, winWidth, winHeight, winSwapInterval int, winFullScreen bool) (me *EngineOptions)</pre>
				<p>
Allocates, initializes and returns a new core.EngineOptions instance.
</p>

				
			

			
				
				<h3 id="EngineOptions.GlClearColor">func (*EngineOptions) <a href="/target/ng-options.go?s=1301:1351#L26">GlClearColor</a></h3>
				<pre>func (me *EngineOptions) GlClearColor() ugl.GlVec4</pre>
				<p>
Returns the current OpenGL &#34;clear color&#34;.
</p>

				
				
			
				
				<h3 id="EngineOptions.SetGlClearColor">func (*EngineOptions) <a href="/target/ng-options.go?s=1425:1481#L31">SetGlClearColor</a></h3>
				<pre>func (me *EngineOptions) SetGlClearColor(col ugl.GlVec4)</pre>
				<p>
Changes the current OpenGL &#34;clear color&#34;
</p>

				
				
			
		
			
			
			<h2 id="EngineStats">type <a href="/target/ng-stats.go?s=211:2283#L1">EngineStats</a></h2>
			<pre>type EngineStats struct {
    <span class="comment">//	Gives the total number of frames rendered during the &#34;previous&#34; (not the current) second. Good enough for just a simple-minded FPS indicator.</span>
    FpsLastSec int

    <span class="comment">//	This TimingStats instance combines all the individual FrameFoo fields to track over time (both average and maximum) total cost per frame.</span>
    Frame *TimingStats

    <span class="comment">//	&#34;Rendering&#34; consists of a CPU-side and a GPU-side cost.</span>
    <span class="comment">//	This TimingStats instance combines both to track over time (both average and maximum) total rendering cost per frame.</span>
    FrameRenderBoth *TimingStats

    <span class="comment">//	The CPU-side cost of rendering comprises geometry culling, and batching draw calls to the GPU.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) CPU-side rendering cost per frame.</span>
    FrameRenderCpu *TimingStats

    <span class="comment">//	The GPU-side cost of rendering comprises execution of all draw calls sent by the CPU-side, plus waiting for V-sync if enabled.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) GPU-side rendering cost per frame.</span>
    FrameRenderGpu *TimingStats

    <span class="comment">//	&#34;Core code&#34; comprises non-rendering go:ngine logic executed every frame.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;core code&#34; cost per frame.</span>
    FrameCoreCode *TimingStats

    <span class="comment">//	&#34;User code&#34; comprises user-specific logic executed every frame in your own EngineLoop.OnLoop() callback.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;user code&#34; cost per frame.</span>
    FrameUserCode *TimingStats

    <span class="comment">//	During the Loop, the Go Garbge Collector is invoked at least and at most once per second.</span>
    <span class="comment">//	</span>
    <span class="comment">//	Forcing GC &#34;that often&#34; practically guarantees it will almost never have so much work to do as to</span>
    <span class="comment">//	noticably block user interaction --- 99.9% of the time it will complete in less than 10ms (and almost-always under 1ms).</span>
    <span class="comment">//	</span>
    <span class="comment">//	This TimingStats instance over time tracks the maximum and average time spent on that 1x-per-second GC invokation (but does not track any other GC invokations).</span>
    Gc *TimingStats
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineStats a &#34;Singleton&#34; type, only valid use is the core.Stats global variable.
Tracks various go:ngine performance indicators over time.
</p>


			

			

			

			

			
				
				<h3 id="EngineStats.AverageFps">func (*EngineStats) <a href="/target/ng-stats.go?s=2457:2500#L45">AverageFps</a></h3>
				<pre>func (me *EngineStats) AverageFps() float64</pre>
				<p>
Returns the average number of frames-per-second since Loop.Loop() was last called.
</p>

				
				
			
				
				<h3 id="EngineStats.TotalFrames">func (*EngineStats) <a href="/target/ng-stats.go?s=2817:2862#L55">TotalFrames</a></h3>
				<pre>func (me *EngineStats) TotalFrames() float64</pre>
				
				
				
			
		
			
			
			<h2 id="EngineUserIO">type <a href="/target/ng-userio.go?s=317:601#L3">EngineUserIO</a></h2>
			<pre>type EngineUserIO struct {
    <span class="comment">//	Minimum delay for EngineUserIO.KeyToggled() method, in seconds. Defaults to 0.25.</span>
    KeyToggleMinDelay float64
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineUserIO a &#34;Singleton&#34; type, only valid use is the core.UserIO global variable.
Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).
</p>


			

			

			

			

			
				
				<h3 id="EngineUserIO.IifKeyF">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2264:2337#L72">IifKeyF</a></h3>
				<pre>func (me *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</pre>
				<p>
Returns ifTrue if the specified key is pressed, otherwise returns ifFalse.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressed">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2452:2500#L80">KeyPressed</a></h3>
				<pre>func (me *EngineUserIO) KeyPressed(key int) bool</pre>
				<p>
Returns true if the specified key is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressedWhich">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2591:2647#L85">KeyPressedWhich</a></h3>
				<pre>func (me *EngineUserIO) KeyPressedWhich(keys ...int) int</pre>
				<p>
Returns the first in keys that is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyToggled">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3613:3661#L115">KeyToggled</a></h3>
				<pre>func (me *EngineUserIO) KeyToggled(key int) bool</pre>
				<p>
Returns true if the specified key has been &#34;toggled&#34;, ie. its pressed-state changed within the last me.KeyToggleMinDelay seconds.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2813:2869#L95">KeysPressedAll2</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</pre>
				<p>
Returns true if both specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2979:3039#L100">KeysPressedAll3</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if all three specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3174:3230#L105">KeysPressedAny2</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</pre>
				<p>
Returns true if any of the two specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3346:3406#L110">KeysPressedAny3</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if any of the three specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.SetWinTitle">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3896:3948#L124">SetWinTitle</a></h3>
				<pre>func (me *EngineUserIO) SetWinTitle(newTitle string)</pre>
				<p>
Sets the window title to newTitle.
</p>

				
				
			
				
				<h3 id="EngineUserIO.WinHeight">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4032:4071#L129">WinHeight</a></h3>
				<pre>func (me *EngineUserIO) WinHeight() int</pre>
				<p>
Returns the height of the window in pixels.
</p>

				
				
			
				
				<h3 id="EngineUserIO.WinWidth">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4154:4192#L134">WinWidth</a></h3>
				<pre>func (me *EngineUserIO) WinWidth() int</pre>
				<p>
Returns the width of the window in pixels.
</p>

				
				
			
		
			
			
			<h2 id="Material">type <a href="/target/material.go?s=269:309#L6">Material</a></h2>
			<pre>type Material struct {
    TexName string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Mesh">type <a href="/target/mesh.go?s=714:1119#L33">Mesh</a></h2>
			<pre>type Mesh struct {
    Models models
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Mesh.GpuDelete">func (*Mesh) <a href="/target/mesh.go?s=1121:1148#L43">GpuDelete</a></h3>
				<pre>func (me *Mesh) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUpload">func (*Mesh) <a href="/target/mesh.go?s=1199:1238#L49">GpuUpload</a></h3>
				<pre>func (me *Mesh) GpuUpload() (err error)</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUploaded">func (*Mesh) <a href="/target/mesh.go?s=2847:2881#L76">GpuUploaded</a></h3>
				<pre>func (me *Mesh) GpuUploaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Loaded">func (*Mesh) <a href="/target/mesh.go?s=4755:4784#L123">Loaded</a></h3>
				<pre>func (me *Mesh) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Unload">func (*Mesh) <a href="/target/mesh.go?s=5203:5227#L136">Unload</a></h3>
				<pre>func (me *Mesh) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffer">type <a href="/target/mesh-buffer.go?s=1746:2135#L63">MeshBuffer</a></h2>
			<pre>type MeshBuffer struct {
    MemSizeIndices, MemSizeVertices int32
    Params                          *meshBufferParams
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffer.Add">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=3647:3696#L112">Add</a></h3>
				<pre>func (me *MeshBuffer) Add(mesh *Mesh) (err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffer.Remove">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=4462:4502#L140">Remove</a></h3>
				<pre>func (me *MeshBuffer) Remove(mesh *Mesh)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshData">type <a href="/target/mesh-data.go?s=1164:1390#L42">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="NewMeshData">func <a href="/target/mesh-data.go?s=1446:1479#L57">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/mesh-data.go?s=39:101#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Temporary concoction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Model">type <a href="/target/model.go?s=99:186#L1">Model</a></h2>
			<pre>type Model struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Model.Clone">func (*Model) <a href="/target/model.go?s=289:350#L11">Clone</a></h3>
				<pre>func (me *Model) Clone(modelName string) (clonedModel *Model)</pre>
				
				
				
			
				
				<h3 id="Model.MatName">func (*Model) <a href="/target/model.go?s=521:554#L19">MatName</a></h3>
				<pre>func (me *Model) MatName() string</pre>
				
				
				
			
				
				<h3 id="Model.SetMatName">func (*Model) <a href="/target/model.go?s=662:708#L28">SetMatName</a></h3>
				<pre>func (me *Model) SetMatName(newMatName string)</pre>
				
				
				
			
		
			
			
			<h2 id="Node">type <a href="/target/node.go?s=1075:1416#L42">Node</a></h2>
			<pre>type Node struct {
    Disabled  bool
    SubNodes  *subNodes
    Transform *NodeTransforms
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Node.MatName">func (*Node) <a href="/target/node.go?s=1768:1800#L69">MatName</a></h3>
				<pre>func (me *Node) MatName() string</pre>
				
				
				
			
				
				<h3 id="Node.Material">func (*Node) <a href="/target/node.go?s=1666:1702#L62">Material</a></h3>
				<pre>func (me *Node) Material() *Material</pre>
				
				
				
			
				
				<h3 id="Node.MeshModelName">func (*Node) <a href="/target/node.go?s=1884:1922#L77">MeshModelName</a></h3>
				<pre>func (me *Node) MeshModelName() string</pre>
				
				
				
			
				
				<h3 id="Node.MeshName">func (*Node) <a href="/target/node.go?s=1825:1858#L73">MeshName</a></h3>
				<pre>func (me *Node) MeshName() string</pre>
				
				
				
			
				
				<h3 id="Node.SetMatName">func (*Node) <a href="/target/node.go?s=2322:2367#L95">SetMatName</a></h3>
				<pre>func (me *Node) SetMatName(newMatName string)</pre>
				
				
				
			
				
				<h3 id="Node.SetMeshModelName">func (*Node) <a href="/target/node.go?s=2469:2529#L101">SetMeshModelName</a></h3>
				<pre>func (me *Node) SetMeshModelName(meshName, modelName string)</pre>
				
				
				
			
		
			
			
			<h2 id="NodeTransforms">type <a href="/target/node-transform.go?s=646:1290#L7">NodeTransforms</a></h2>
			<pre>type NodeTransforms struct {
    <span class="comment">//	Translation of the from origin, if any.</span>
    Pos unum.Vec3

    <span class="comment">//	Rotation for each axis in radians, if any.</span>
    Rot unum.Vec3

    <span class="comment">//	Scaling of this node, if any. Defaults to (1, 1, 1) for no scaling.</span>
    Scale unum.Vec3

    <span class="comment">//	An arbitrary additional transformation to apply. Defaults to the 4x4 identity matrix for &#39;none&#39;.</span>
    <span class="comment">//	Must not be nil.</span>
    Other unum.Mat4
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents one or more transformations of a Node.
This is only used by Node objects, which initialize their NodeTransforms with the
proper defaults and associate themselves with their NodeTransforms. (Any other
NodeTransforms are invalid.)
</p>
<p>
A single NodeTransforms encapsulates a number of private 4x4 matrices that are
set from its exported fields via the SetFoo() or OnFooChanged() methods, and
are multiplied together into a final single 4x4 transformation matrix via the
ApplyMatrices() (or OnFooChanged()) methods.
</p>


			

			

			

			

			
				
				<h3 id="NodeTransforms.ApplyMatrices">func (*NodeTransforms) <a href="/target/node-transform.go?s=1832:1873#L43">ApplyMatrices</a></h3>
				<pre>func (me *NodeTransforms) ApplyMatrices()</pre>
				<p>
Creates a final single 4x4 transformation matrix for all transformations
in me. It is this matrix that is used by the rendering pipeline.
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnAnyChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=2539:2579#L60">OnAnyChanged</a></h3>
				<pre>func (me *NodeTransforms) OnAnyChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the scaling matrix from the current me.Scale value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=2846:2886#L73">OnPosChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosRotChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3107:3150#L81">OnPosRotChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosRotChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnPosScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3373:3418#L90">OnPosScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnPosScaleChanged()</pre>
				<p>
Updates the translation matrix from the current me.Pos value.
Updates the scaling matrix from the current me.Scale value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3701:3741#L104">OnRotChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotChanged()</pre>
				<p>
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=3960:4005#L112">OnRotScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotScaleChanged()</pre>
				<p>
Updates the scaling matrix from the current me.Scale value.
Updates the X, Y and Z axis rotation matrices from the current me.Rot value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotXChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4252:4293#L124">OnRotXChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotXChanged()</pre>
				<p>
Updates the X-axis rotation matrix from the current me.Rot.X value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotYChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4520:4561#L135">OnRotYChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotYChanged()</pre>
				<p>
Updates the Y-axis rotation matrix from the current me.Rot.Y value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnRotZChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=4788:4829#L146">OnRotZChanged</a></h3>
				<pre>func (me *NodeTransforms) OnRotZChanged()</pre>
				<p>
Updates the Z-axis rotation matrix from the current me.Rot.Z value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnScaleChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=5049:5091#L157">OnScaleChanged</a></h3>
				<pre>func (me *NodeTransforms) OnScaleChanged()</pre>
				<p>
Updates the scaling matrix from the current me.Scale value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.OnSomeChanged">func (*NodeTransforms) <a href="/target/node-transform.go?s=5595:5669#L168">OnSomeChanged</a></h3>
				<pre>func (me *NodeTransforms) OnSomeChanged(scale, pos, rotX, rotY, rotZ bool)</pre>
				<p>
If pos is true, updates the translation matrix from the current me.Pos value.
If scale is true, updates the scaling matrix from the current me.Scale value.
If rotX is true, updates the X-axis rotation matrix from the current me.Rot.X value.
If rotY is true, updates the Y-axis rotation matrix from the current me.Rot.Y value.
If rotZ is true, updates the Z-axis rotation matrix from the current me.Rot.Z value.
Then calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPos">func (*NodeTransforms) <a href="/target/node-transform.go?s=5911:5959#L188">SetPos</a></h3>
				<pre>func (me *NodeTransforms) SetPos(pos *unum.Vec3)</pre>
				<p>
Sets me.Pos and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosX">func (*NodeTransforms) <a href="/target/node-transform.go?s=6098:6145#L198">SetPosX</a></h3>
				<pre>func (me *NodeTransforms) SetPosX(posX float64)</pre>
				<p>
Sets me.Pos.X and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6228:6289#L204">SetPosXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetPosXYZ(posX, posY, posZ float64)</pre>
				<p>
Sets me.Pos and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosY">func (*NodeTransforms) <a href="/target/node-transform.go?s=6406:6453#L210">SetPosY</a></h3>
				<pre>func (me *NodeTransforms) SetPosY(posY float64)</pre>
				<p>
Sets me.Pos.Y and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetPosZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6538:6585#L216">SetPosZ</a></h3>
				<pre>func (me *NodeTransforms) SetPosZ(posZ float64)</pre>
				<p>
Sets me.Pos.Z and calls OnPosChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRot">func (*NodeTransforms) <a href="/target/node-transform.go?s=6668:6716#L222">SetRot</a></h3>
				<pre>func (me *NodeTransforms) SetRot(rot *unum.Vec3)</pre>
				<p>
Sets me.Rot and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotX">func (*NodeTransforms) <a href="/target/node-transform.go?s=6855:6901#L232">SetRotX</a></h3>
				<pre>func (me *NodeTransforms) SetRotX(rad float64)</pre>
				<p>
Sets me.Rot.X and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=6984:7045#L238">SetRotXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetRotXYZ(radX, radY, radZ float64)</pre>
				<p>
Sets me.Rot and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotY">func (*NodeTransforms) <a href="/target/node-transform.go?s=7162:7208#L244">SetRotY</a></h3>
				<pre>func (me *NodeTransforms) SetRotY(rad float64)</pre>
				<p>
Sets me.Rot.Y and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetRotZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=7293:7339#L250">SetRotZ</a></h3>
				<pre>func (me *NodeTransforms) SetRotZ(rad float64)</pre>
				<p>
Sets me.Rot.Z and calls OnRotChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScale">func (*NodeTransforms) <a href="/target/node-transform.go?s=7426:7478#L256">SetScale</a></h3>
				<pre>func (me *NodeTransforms) SetScale(scale *unum.Vec3)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScaleN">func (*NodeTransforms) <a href="/target/node-transform.go?s=7621:7671#L266">SetScaleN</a></h3>
				<pre>func (me *NodeTransforms) SetScaleN(scale float64)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.SetScaleXYZ">func (*NodeTransforms) <a href="/target/node-transform.go?s=7759:7813#L271">SetScaleXYZ</a></h3>
				<pre>func (me *NodeTransforms) SetScaleXYZ(x, y, z float64)</pre>
				<p>
Sets me.Scale and calls OnScaleChanged().
</p>

				
				
			
				
				<h3 id="NodeTransforms.StepDelta">func (*NodeTransforms) <a href="/target/node-transform.go?s=7965:8032#L277">StepDelta</a></h3>
				<pre>func (me *NodeTransforms) StepDelta(deltaPerSecond float64) float64</pre>
				<p>
Returns the result of multiplying deltaPerSecond with EngineLoop.TickDelta.
</p>

				
				
			
		
			
			
			<h2 id="RenderCanvas">type <a href="/target/render-canvas.go?s=1003:1139#L39">RenderCanvas</a></h2>
			<pre>type RenderCanvas struct {
    Disabled bool
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="RenderCanvas.Dispose">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1296:1329#L53">Dispose</a></h3>
				<pre>func (me *RenderCanvas) Dispose()</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.SetCameraIDs">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1456:1510#L64">SetCameraIDs</a></h3>
				<pre>func (me *RenderCanvas) SetCameraIDs(camIDs ...string)</pre>
				
				
				
			
		
			
			
			<h2 id="Scene">type <a href="/target/scene.go?s=45:82#L1">Scene</a></h2>
			<pre>type Scene struct {
    RootNode *Node
}</pre>
			

			

			

			

			
				
				<h3 id="NewScene">func <a href="/target/scene.go?s=84:111#L1">NewScene</a></h3>
				<pre>func NewScene() (me *Scene)</pre>
				
				
			

			
		
			
			
			<h2 id="Texture">type <a href="/target/texture.go?s=525:1056#L22">Texture</a></h2>
			<pre>type Texture struct {
    LastError error
    Params    *textureParams
    InitFrom  struct {
        RawData []byte
        RefUrl  string
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Texture.GpuDelete">func (*Texture) <a href="/target/texture.go?s=1230:1260#L49">GpuDelete</a></h3>
				<pre>func (me *Texture) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="Texture.GpuSync">func (*Texture) <a href="/target/texture.go?s=1338:1366#L56">GpuSync</a></h3>
				<pre>func (me *Texture) GpuSync()</pre>
				
				
				
			
				
				<h3 id="Texture.GpuSynced">func (*Texture) <a href="/target/texture.go?s=2421:2456#L81">GpuSynced</a></h3>
				<pre>func (me *Texture) GpuSynced() bool</pre>
				
				
				
			
				
				<h3 id="Texture.Loaded">func (*Texture) <a href="/target/texture.go?s=3502:3534#L134">Loaded</a></h3>
				<pre>func (me *Texture) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="Texture.SuppressMipMaps">func (*Texture) <a href="/target/texture.go?s=4006:4042#L151">SuppressMipMaps</a></h3>
				<pre>func (me *Texture) SuppressMipMaps()</pre>
				
				
				
			
				
				<h3 id="Texture.Unload">func (*Texture) <a href="/target/texture.go?s=4068:4095#L155">Unload</a></h3>
				<pre>func (me *Texture) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="TextureProvider">type <a href="/target/texture-provider.go?s=103:166#L2">TextureProvider</a></h2>
			<pre>type TextureProvider func(arg interface{}) (image.Image, error)</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="TimingStats">type <a href="/target/ng-stats.go?s=2967:3139#L60">TimingStats</a></h2>
			<pre>type TimingStats struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Helps track average and maximum cost for a variety of performance indicators.
</p>


			

			

			

			

			
				
				<h3 id="TimingStats.Average">func (*TimingStats) <a href="/target/ng-stats.go?s=3282:3322#L71">Average</a></h3>
				<pre>func (me *TimingStats) Average() float64</pre>
				<p>
Returns the average cost tracked by this performance indicator.
</p>

				
				
			
				
				<h3 id="TimingStats.Max">func (*TimingStats) <a href="/target/ng-stats.go?s=3914:3950#L94">Max</a></h3>
				<pre>func (me *TimingStats) Max() float64</pre>
				<p>
Returns the maximum cost tracked by this performance indicator.
</p>

				
				
			
		
		</div>
	

	








		</div></div>
	</body>
</html>