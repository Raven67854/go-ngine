<html>
	<head>
		<title>Package github.com/go3d/go-ngine/core</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/core</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/core"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *core* package provides go:ngine client-side core functionality such as rendering and user I/O.
</p>

			</div>
		</div>
		

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Dispose">func Dispose()</a></dd>
			
				
				<dd><a href="#Init">func Init(fullscreen bool) (err error)</a></dd>
			
			
				
				<dd><a href="#Camera">type Camera</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.Scene">func (me *Camera) Scene() *Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.SetScene">func (me *Camera) SetScene(sceneID int)</a></dd>
				
			
				
				<dd><a href="#Controller">type Controller</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.BeginUpdate">func (me *Controller) BeginUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.CopyFrom">func (me *Controller) CopyFrom(copy Controller)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.Dir">func (me *Controller) Dir() *unum.Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.EndUpdate">func (me *Controller) EndUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveBackward">func (me *Controller) MoveBackward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveDown">func (me *Controller) MoveDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveForward">func (me *Controller) MoveForward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveLeft">func (me *Controller) MoveLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveRight">func (me *Controller) MoveRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveUp">func (me *Controller) MoveUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeMove">func (me *Controller) StepSizeMove() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeTurn">func (me *Controller) StepSizeTurn() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDown">func (me *Controller) TurnDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDownBy">func (me *Controller) TurnDownBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeft">func (me *Controller) TurnLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeftBy">func (me *Controller) TurnLeftBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRight">func (me *Controller) TurnRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRightBy">func (me *Controller) TurnRightBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUp">func (me *Controller) TurnUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUpBy">func (me *Controller) TurnUpBy(deg float64)</a></dd>
				
			
				
				<dd><a href="#ControllerParams">type ControllerParams</a></dd>
				
				
			
				
				<dd><a href="#FxEffect">type FxEffect</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffect.UpdateRoutine">func (me *FxEffect) UpdateRoutine()</a></dd>
				
			
				
				<dd><a href="#FxEffectLib">type FxEffectLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectLib.AddNew">func (me *FxEffectLib) AddNew() (id int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectLib.Compact">func (me *FxEffectLib) Compact()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectLib.IsOk">func (me FxEffectLib) IsOk(id int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectLib.Ok">func (me FxEffectLib) Ok(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectLib.Remove">func (me FxEffectLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectLib.Walk">func (me FxEffectLib) Walk(on func(ref *FxEffect))</a></dd>
				
			
				
				<dd><a href="#FxImage2D">type FxImage2D</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.GpuDelete">func (me *FxImage2D) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.GpuSync">func (me *FxImage2D) GpuSync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Load">func (me *FxImage2D) Load() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Loaded">func (me *FxImage2D) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.NoAutoMips">func (me *FxImage2D) NoAutoMips()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Unload">func (me *FxImage2D) Unload()</a></dd>
				
			
				
				<dd><a href="#FxImage2DLib">type FxImage2DLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2DLib.AddNew">func (me *FxImage2DLib) AddNew() (id int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2DLib.Compact">func (me *FxImage2DLib) Compact()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2DLib.IsOk">func (me FxImage2DLib) IsOk(id int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2DLib.Ok">func (me FxImage2DLib) Ok(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2DLib.Remove">func (me FxImage2DLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2DLib.Walk">func (me FxImage2DLib) Walk(on func(ref *FxImage2D))</a></dd>
				
			
				
				<dd><a href="#FxImageBase">type FxImageBase</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.GpuSynced">func (me *FxImageBase) GpuSynced() bool</a></dd>
				
			
				
				<dd><a href="#FxImageCube">type FxImageCube</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.GpuDelete">func (me *FxImageCube) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.GpuSync">func (me *FxImageCube) GpuSync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.Load">func (me *FxImageCube) Load() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.Loaded">func (me *FxImageCube) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.NoAutoMips">func (me *FxImageCube) NoAutoMips()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.Unload">func (me *FxImageCube) Unload()</a></dd>
				
			
				
				<dd><a href="#FxImageCubeLib">type FxImageCubeLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCubeLib.AddNew">func (me *FxImageCubeLib) AddNew() (id int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCubeLib.Compact">func (me *FxImageCubeLib) Compact()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCubeLib.IsOk">func (me FxImageCubeLib) IsOk(id int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCubeLib.Ok">func (me FxImageCubeLib) Ok(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCubeLib.Remove">func (me FxImageCubeLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCubeLib.Walk">func (me FxImageCubeLib) Walk(on func(ref *FxImageCube))</a></dd>
				
			
				
				<dd><a href="#FxImageInitFrom">type FxImageInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxImagePreprocess">type FxImagePreprocess</a></dd>
				
				
			
				
				<dd><a href="#FxImageStorage">type FxImageStorage</a></dd>
				
				
			
				
				<dd><a href="#FxMaterial">type FxMaterial</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterial.HasFaceEffects">func (me *FxMaterial) HasFaceEffects() bool</a></dd>
				
			
				
				<dd><a href="#FxMaterialLib">type FxMaterialLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialLib.AddNew">func (me *FxMaterialLib) AddNew() (id int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialLib.Compact">func (me *FxMaterialLib) Compact()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialLib.IsOk">func (me FxMaterialLib) IsOk(id int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialLib.Ok">func (me FxMaterialLib) Ok(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialLib.Remove">func (me FxMaterialLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialLib.Walk">func (me FxMaterialLib) Walk(on func(ref *FxMaterial))</a></dd>
				
			
				
				<dd><a href="#FxProc">type FxProc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.Color_SetRgb">func (me *FxProc) Color_SetRgb(rgb ...gl.Float) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.IsColor">func (me *FxProc) IsColor() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.IsCoords">func (me *FxProc) IsCoords() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.IsGamma">func (me *FxProc) IsGamma() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.IsGrayscale">func (me *FxProc) IsGrayscale() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.IsOrangify">func (me *FxProc) IsOrangify() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.IsTex">func (me *FxProc) IsTex() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.IsTex2D">func (me *FxProc) IsTex2D() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.IsTexCube">func (me *FxProc) IsTexCube() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.SetMixWeight">func (me *FxProc) SetMixWeight(weight float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.Tex_SetImageID">func (me *FxProc) Tex_SetImageID(imageID int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProc.Toggle">func (me *FxProc) Toggle()</a></dd>
				
			
				
				<dd><a href="#FxProcs">type FxProcs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.Disable">func (me FxProcs) Disable(procID string, n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.DisableColor">func (me FxProcs) DisableColor(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.DisableCoords">func (me FxProcs) DisableCoords(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.DisableGamma">func (me FxProcs) DisableGamma(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.DisableGrayscale">func (me FxProcs) DisableGrayscale(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.DisableOrangify">func (me FxProcs) DisableOrangify(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.DisableTex2D">func (me FxProcs) DisableTex2D(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.DisableTexCube">func (me FxProcs) DisableTexCube(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.Enable">func (me *FxProcs) Enable(procID string, n int) (proc *FxProc)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.EnableColor">func (me *FxProcs) EnableColor(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.EnableCoords">func (me *FxProcs) EnableCoords(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.EnableGamma">func (me *FxProcs) EnableGamma(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.EnableGrayscale">func (me *FxProcs) EnableGrayscale(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.EnableOrangify">func (me *FxProcs) EnableOrangify(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.EnableTex2D">func (me *FxProcs) EnableTex2D(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.EnableTexCube">func (me *FxProcs) EnableTexCube(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.EnsureLast">func (me FxProcs) EnsureLast(lastProcIDs ...string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.Get">func (me FxProcs) Get(procID string, n int) (proc *FxProc)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.GetColor">func (me FxProcs) GetColor(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.GetCoords">func (me FxProcs) GetCoords(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.GetGamma">func (me FxProcs) GetGamma(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.GetGrayscale">func (me FxProcs) GetGrayscale(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.GetOrangify">func (me FxProcs) GetOrangify(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.GetTex2D">func (me FxProcs) GetTex2D(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.GetTexCube">func (me FxProcs) GetTexCube(n int) *FxProc</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.Toggle">func (me *FxProcs) Toggle(procID string, n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.ToggleColor">func (me *FxProcs) ToggleColor(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.ToggleCoords">func (me *FxProcs) ToggleCoords(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.ToggleGamma">func (me *FxProcs) ToggleGamma(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.ToggleGrayscale">func (me *FxProcs) ToggleGrayscale(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.ToggleOrangify">func (me *FxProcs) ToggleOrangify(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.ToggleTex2D">func (me *FxProcs) ToggleTex2D(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxProcs.ToggleTexCube">func (me *FxProcs) ToggleTexCube(n int)</a></dd>
				
			
				
				<dd><a href="#LibElemIDChangedHandler">type LibElemIDChangedHandler</a></dd>
				
				
			
				
				<dd><a href="#LibElemIDChangedHandlers">type LibElemIDChangedHandlers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibElemIDChangedHandlers.Add">func (me *LibElemIDChangedHandlers) Add(fn LibElemIDChangedHandler)</a></dd>
				
			
				
				<dd><a href="#Mesh">type Mesh</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuDelete">func (me *Mesh) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUpload">func (me *Mesh) GpuUpload() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUploaded">func (me *Mesh) GpuUploaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Load">func (me *Mesh) Load(provider u3d.MeshProvider) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Loaded">func (me *Mesh) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Unload">func (me *Mesh) Unload()</a></dd>
				
			
				
				<dd><a href="#MeshBuffer">type MeshBuffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Add">func (me *MeshBuffer) Add(meshID int) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Remove">func (me *MeshBuffer) Remove(meshID int)</a></dd>
				
			
				
				<dd><a href="#MeshBufferLib">type MeshBufferLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBufferLib.AddNew">func (me *MeshBufferLib) AddNew(name string, capacity int32) (buf *MeshBuffer, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBufferLib.FloatsPerVertex">func (_ MeshBufferLib) FloatsPerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBufferLib.IsOk">func (me MeshBufferLib) IsOk(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBufferLib.MemSizePerIndex">func (_ MeshBufferLib) MemSizePerIndex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBufferLib.MemSizePerVertex">func (_ MeshBufferLib) MemSizePerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBufferLib.Remove">func (me *MeshBufferLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBufferLib.Walk">func (me MeshBufferLib) Walk(on func(ref *MeshBuffer))</a></dd>
				
			
				
				<dd><a href="#MeshLib">type MeshLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.AddNew">func (me *MeshLib) AddNew() (id int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.AddNewAndLoad">func (me *MeshLib) AddNewAndLoad(name string, meshProvider u3d.MeshProvider) (meshID int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.Compact">func (me *MeshLib) Compact()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.GpuSync">func (_ MeshLib) GpuSync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.IsOk">func (me MeshLib) IsOk(id int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.MeshCube">func (_ MeshLib) MeshCube() u3d.MeshProvider</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.MeshPlane">func (_ MeshLib) MeshPlane() u3d.MeshProvider</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.MeshPyramid">func (_ MeshLib) MeshPyramid() u3d.MeshProvider</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.MeshQuad">func (_ MeshLib) MeshQuad() u3d.MeshProvider</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.MeshTri">func (_ MeshLib) MeshTri() u3d.MeshProvider</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.Ok">func (me MeshLib) Ok(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.Remove">func (me MeshLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshLib.Walk">func (me MeshLib) Walk(on func(ref *Mesh))</a></dd>
				
			
				
				<dd><a href="#Model">type Model</a></dd>
				
				
			
				
				<dd><a href="#ModelLib">type ModelLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ModelLib.AddNew">func (me *ModelLib) AddNew() (id int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ModelLib.Compact">func (me *ModelLib) Compact()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ModelLib.IsOk">func (me ModelLib) IsOk(id int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ModelLib.Ok">func (me ModelLib) Ok(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ModelLib.Remove">func (me ModelLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ModelLib.Walk">func (me ModelLib) Walk(on func(ref *Model))</a></dd>
				
			
				
				<dd><a href="#NgCore">type NgCore</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NgCore.GpuSyncImageLibs">func (_ *NgCore) GpuSyncImageLibs() (err error)</a></dd>
				
			
				
				<dd><a href="#NgDiag">type NgDiag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NgDiag.Log">func (_ *NgDiag) Log(cat NgDiagLogCategory, fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgDiag.LogErr">func (_ *NgDiag) LogErr(err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgDiag.LogIfGlErr">func (_ *NgDiag) LogIfGlErr(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgDiag.LogImages">func (_ *NgDiag) LogImages(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgDiag.LogMeshes">func (_ *NgDiag) LogMeshes(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgDiag.LogMisc">func (_ *NgDiag) LogMisc(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgDiag.LogShaders">func (_ *NgDiag) LogShaders(fmt string, fmtArgs ...interface{})</a></dd>
				
			
				
				<dd><a href="#NgDiagLogCategory">type NgDiagLogCategory</a></dd>
				
				
			
				
				<dd><a href="#NgLibs">type NgLibs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NgLibs.UpdateIDRef">func (_ *NgLibs) UpdateIDRef(oldNewIDs map[int]int, ptr *int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgLibs.UpdateIDRefs">func (_ *NgLibs) UpdateIDRefs(oldNewIDs map[int]int, ptrs ...*int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgLibs.UpdateIDRefsIn">func (_ *NgLibs) UpdateIDRefsIn(oldNewIDs map[int]int, slice []int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgLibs.UpdatedIDRef">func (_ *NgLibs) UpdatedIDRef(oldNewIDs map[int]int, in int) (out int)</a></dd>
				
			
				
				<dd><a href="#NgLoop">type NgLoop</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NgLoop.Run">func (_ *NgLoop) Run()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgLoop.Time">func (_ *NgLoop) Time() float64</a></dd>
				
			
				
				<dd><a href="#NgOptions">type NgOptions</a></dd>
				
				
			
				
				<dd><a href="#NgStats">type NgStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NgStats.AverageFps">func (_ *NgStats) AverageFps() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgStats.TotalFrames">func (_ *NgStats) TotalFrames() float64</a></dd>
				
			
				
				<dd><a href="#NgUserIO">type NgUserIO</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NgUserIO.IifKeyF">func (_ *NgUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgUserIO.KeyPressed">func (_ *NgUserIO) KeyPressed(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgUserIO.KeyPressedWhich">func (_ *NgUserIO) KeyPressedWhich(keys ...int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgUserIO.KeyToggled">func (_ *NgUserIO) KeyToggled(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgUserIO.KeysPressedAll2">func (_ *NgUserIO) KeysPressedAll2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgUserIO.KeysPressedAll3">func (_ *NgUserIO) KeysPressedAll3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgUserIO.KeysPressedAny2">func (_ *NgUserIO) KeysPressedAny2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NgUserIO.KeysPressedAny3">func (_ *NgUserIO) KeysPressedAny3(k1, k2, k3 int) bool</a></dd>
				
			
				
				<dd><a href="#RenderBatchCriteria">type RenderBatchCriteria</a></dd>
				
				
			
				
				<dd><a href="#RenderBatcher">type RenderBatcher</a></dd>
				
				
			
				
				<dd><a href="#RenderCanvas">type RenderCanvas</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.AddNewView">func (me *RenderCanvas) AddNewView(renderTechnique string) (view *RenderView)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.CurrentAbsoluteSize">func (me *RenderCanvas) CurrentAbsoluteSize() (width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.SetSize">func (me *RenderCanvas) SetSize(relative bool, width, height float64)</a></dd>
				
			
				
				<dd><a href="#RenderCanvasLib">type RenderCanvasLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvasLib.AddNew">func (me *RenderCanvasLib) AddNew(relative bool, width, height float64) (canv *RenderCanvas)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvasLib.IsOk">func (me RenderCanvasLib) IsOk(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvasLib.Remove">func (me *RenderCanvasLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvasLib.Walk">func (me RenderCanvasLib) Walk(on func(ref *RenderCanvas))</a></dd>
				
			
				
				<dd><a href="#RenderTechnique">type RenderTechnique</a></dd>
				
				
			
				
				<dd><a href="#RenderTechniqueQuad">type RenderTechniqueQuad</a></dd>
				
				
			
				
				<dd><a href="#RenderTechniqueScene">type RenderTechniqueScene</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderTechniqueScene.ApplyCameraPerspective">func (me *RenderTechniqueScene) ApplyCameraPerspective()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderTechniqueScene.NumDrawCalls">func (me *RenderTechniqueScene) NumDrawCalls() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderTechniqueScene.ToggleBatching">func (me *RenderTechniqueScene) ToggleBatching()</a></dd>
				
			
				
				<dd><a href="#RenderView">type RenderView</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderView.Technique_Quad">func (me *RenderView) Technique_Quad() (tech *RenderTechniqueQuad)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderView.Technique_Scene">func (me *RenderView) Technique_Scene() (tech *RenderTechniqueScene)</a></dd>
				
			
				
				<dd><a href="#RenderViewLib">type RenderViewLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderViewLib.IsOk">func (me RenderViewLib) IsOk(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderViewLib.Remove">func (me *RenderViewLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderViewLib.Walk">func (me RenderViewLib) Walk(on func(ref *RenderView))</a></dd>
				
			
				
				<dd><a href="#RenderViewport">type RenderViewport</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderViewport.SetAbsolute">func (me *RenderViewport) SetAbsolute(x, y, width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderViewport.SetRelative">func (me *RenderViewport) SetRelative(x, y, width, height float64)</a></dd>
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.AddNewChildNode">func (me *Scene) AddNewChildNode(parentNodeID, meshID int) (childNodeID int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.ApplyNodeTransforms">func (me *Scene) ApplyNodeTransforms(nodeID int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.Node">func (me *Scene) Node(id int) *SceneNode</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.NumNodes">func (me *Scene) NumNodes() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.ParentNodeID">func (me *Scene) ParentNodeID(childNodeID int) (parentID int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.RemoveNode">func (me *Scene) RemoveNode(fromID int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.Root">func (me *Scene) Root() *SceneNode</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scene.SetNodeMeshID">func (me *Scene) SetNodeMeshID(nodeID, meshID int)</a></dd>
				
			
				
				<dd><a href="#SceneLib">type SceneLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneLib.AddNew">func (me *SceneLib) AddNew() (id int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneLib.Compact">func (me *SceneLib) Compact()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneLib.IsOk">func (me SceneLib) IsOk(id int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneLib.Ok">func (me SceneLib) Ok(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneLib.Remove">func (me SceneLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneLib.Walk">func (me SceneLib) Walk(on func(ref *Scene))</a></dd>
				
			
				
				<dd><a href="#SceneNode">type SceneNode</a></dd>
				
				
			
				
				<dd><a href="#SceneNodeLib">type SceneNodeLib</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeLib.AddNew">func (me *SceneNodeLib) AddNew() (id int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeLib.Compact">func (me *SceneNodeLib) Compact()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeLib.IsOk">func (me SceneNodeLib) IsOk(id int) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeLib.Ok">func (me SceneNodeLib) Ok(id int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeLib.Remove">func (me SceneNodeLib) Remove(fromID, num int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeLib.Walk">func (me SceneNodeLib) Walk(on func(ref *SceneNode))</a></dd>
				
			
				
				<dd><a href="#SceneNodeTransform">type SceneNodeTransform</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeTransform.AddRot">func (me *SceneNodeTransform) AddRot(rot *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeTransform.AddRotXYZ">func (me *SceneNodeTransform) AddRotXYZ(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeTransform.SetPos">func (me *SceneNodeTransform) SetPos(posX, posY, posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeTransform.SetRot">func (me *SceneNodeTransform) SetRot(radX, radY, radZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeTransform.SetScale">func (me *SceneNodeTransform) SetScale(s float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeTransform.SetScaleXyz">func (me *SceneNodeTransform) SetScaleXyz(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneNodeTransform.StepDelta">func (me *SceneNodeTransform) StepDelta(deltaPerSecond float64) float64</a></dd>
				
			
				
				<dd><a href="#TimingStats">type TimingStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Average">func (me *TimingStats) Average() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Max">func (me *TimingStats) Max() float64</a></dd>
				
			
				
				<dd><a href="#WindowOptions">type WindowOptions</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Created">func (me *WindowOptions) Created() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Fullscreen">func (me *WindowOptions) Fullscreen() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Height">func (me *WindowOptions) Height() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.SetSize">func (me *WindowOptions) SetSize(width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.SetSwapInterval">func (me *WindowOptions) SetSwapInterval(newSwap int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.SetTitle">func (me *WindowOptions) SetTitle(newTitle string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.SwapInterval">func (me *WindowOptions) SwapInterval() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Title">func (me *WindowOptions) Title() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Width">func (me *WindowOptions) Width() int</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-gen-embed.go">-gen-embed.go</a>
			
				<a href="/target/camera.go">camera.go</a>
			
				<a href="/target/controller.go">controller.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/fileio.go">fileio.go</a>
			
				<a href="/target/fx-effect.gt.go">fx-effect.gt.go</a>
			
				<a href="/target/fx-image-2d.gt.go">fx-image-2d.gt.go</a>
			
				<a href="/target/fx-image-cached.go">fx-image-cached.go</a>
			
				<a href="/target/fx-image-cube.gt.go">fx-image-cube.gt.go</a>
			
				<a href="/target/fx-image-loading.go">fx-image-loading.go</a>
			
				<a href="/target/fx-image.go">fx-image.go</a>
			
				<a href="/target/fx-material.gt.go">fx-material.gt.go</a>
			
				<a href="/target/fx-procs.gt.go">fx-procs.gt.go</a>
			
				<a href="/target/gl-core.go">gl-core.go</a>
			
				<a href="/target/glsl-ubershaders.go">glsl-ubershaders.go</a>
			
				<a href="/target/mesh-buffer.gt.go">mesh-buffer.gt.go</a>
			
				<a href="/target/mesh.gt.go">mesh.gt.go</a>
			
				<a href="/target/model.gt.go">model.gt.go</a>
			
				<a href="/target/ng-core.go">ng-core.go</a>
			
				<a href="/target/ng-diag.go">ng-diag.go</a>
			
				<a href="/target/ng-libs.go">ng-libs.go</a>
			
				<a href="/target/ng-loop.go">ng-loop.go</a>
			
				<a href="/target/ng-options.go">ng-options.go</a>
			
				<a href="/target/ng-stats.go">ng-stats.go</a>
			
				<a href="/target/ng-userio.go">ng-userio.go</a>
			
				<a href="/target/ng-window.go">ng-window.go</a>
			
				<a href="/target/ng.go">ng.go</a>
			
				<a href="/target/render-batcher.go">render-batcher.go</a>
			
				<a href="/target/render-canvas.gt.go">render-canvas.gt.go</a>
			
				<a href="/target/render-prep.go">render-prep.go</a>
			
				<a href="/target/render-technique-base.go">render-technique-base.go</a>
			
				<a href="/target/render-technique-quad.go">render-technique-quad.go</a>
			
				<a href="/target/render-technique-scene.go">render-technique-scene.go</a>
			
				<a href="/target/render-view.gt.go">render-view.gt.go</a>
			
				<a href="/target/render.go">render.go</a>
			
				<a href="/target/scene-node-transform.go">scene-node-transform.go</a>
			
				<a href="/target/scene-node.go">scene-node.go</a>
			
				<a href="/target/scene-nodes.gt.go">scene-nodes.gt.go</a>
			
				<a href="/target/scene.gt.go">scene.gt.go</a>
			
				<a href="/target/threading.go">threading.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const <span id="DefaultBadVersionMessage">DefaultBadVersionMessage</span> = `
Minimum required OpenGL version is {MINVER}, but your
current {OS} graphics driver only provides
OpenGL version {CURVER}.

Most likely your machine is just
missing some recent system updates.

*HOW TO RESOLVE*:

1. On the web, search for &#34;downloading &amp; installing the
latest {OS} driver for {GPU}&#34;,

2. or simply visit the {VENDOR} website and locate
their &#34;driver downloads&#34; pages to obtain the most
recent driver for {GPU}.
`</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span id="Diag">Diag</span> = <a href="#NgDiag">NgDiag</a>{
        <a href="#LogCategories">LogCategories</a>: <a href="#DiagLogCatAll">DiagLogCatAll</a>,
        <a href="#LogCategoryNames">LogCategoryNames</a>: map[<a href="#NgDiagLogCategory">NgDiagLogCategory</a>]<a href="/pkg/builtin/#string">string</a>{
            <a href="#DiagLogCatMisc">DiagLogCatMisc</a>:    &#34;[INFO]\t\t&#34;,
            <a href="#DiagLogCatShaders">DiagLogCatShaders</a>: &#34;[SHADER]\t&#34;,
            <a href="#DiagLogCatImages">DiagLogCatImages</a>:  &#34;[IMAGES]\t&#34;,
            <a href="#DiagLogCatMeshes">DiagLogCatMeshes</a>:  &#34;[MESHES]\t&#34;,
        },
        <a href="#LogGLErrorsInLoopOnSec">LogGLErrorsInLoopOnSec</a>: <a href="/pkg/builtin/#false">false</a>,
    }
)</pre>
				
			
		
		
			
			
			<h2 id="Dispose">func <a href="/target/ng.go?s=238:252#L3">Dispose</a></h2>
			<pre>func Dispose()</pre>
			<p>
Call this to &#34;un-init&#34; go:ngine and to release any and all GPU or RAM resources still allocated.
</p>

			
		
			
			
			<h2 id="Init">func <a href="/target/ng.go?s=461:499#L10">Init</a></h2>
			<pre>func Init(fullscreen <a href="/pkg/builtin/#bool">bool</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>
Initializes go:ngine; this first attempts to initialize OpenGL and then open a window to your supplied specifications with a GL 3.3-or-higher profile.
</p>

			
		
		
			
			
			<h2 id="Camera">type <a href="/target/camera.go?s=178:794#L1">Camera</a></h2>
			<pre>type Camera struct {
    <span class="comment">//	Optical and imager properties for this camera.</span>
    Perspective <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#Perspective">Perspective</a>

    <span class="comment">//	Encapsulates the position and direction of this camera.</span>
    Controller <a href="#Controller">Controller</a>

    Cull struct {
        Frustum <a href="/pkg/builtin/#bool">bool</a>
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Camera.Scene">func (*Camera) <a href="/target/camera.go?s=2122:2154#L69">Scene</a></h3>
				<pre>func (me *<a href="#Camera">Camera</a>) Scene() *<a href="#Scene">Scene</a></pre>
				
				
				
			
				
				<h3 id="Camera.SetScene">func (*Camera) <a href="/target/camera.go?s=2201:2240#L73">SetScene</a></h3>
				<pre>func (me *<a href="#Camera">Camera</a>) SetScene(sceneID <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="Controller">type <a href="/target/controller.go?s=272:1086#L2">Controller</a></h2>
			<pre>type Controller struct {
    <span class="comment">//	The position being manipulated by this Controller.</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    Pos <a href="/pkg/github.com/metaleap/go-util/num/">unum</a>.<a href="/pkg/github.com/metaleap/go-util/num/#Vec3">Vec3</a>

    <span class="comment">//	Indicates which axis is consider &#34;upward&#34;. This is typically</span>
    <span class="comment">//	the Y-axis, denoted by the default value (0, 1, 0).</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    UpAxis <a href="/pkg/github.com/metaleap/go-util/num/">unum</a>.<a href="/pkg/github.com/metaleap/go-util/num/#Vec3">Vec3</a>

    UpVec <a href="/pkg/github.com/metaleap/go-util/num/">unum</a>.<a href="/pkg/github.com/metaleap/go-util/num/#Vec3">Vec3</a>

    <span class="comment">//	Defaults to a copy of Options.Cameras.DefaultControllerParams</span>
    Params <a href="#ControllerParams">ControllerParams</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a position-and-direction and provides methods
manipulating these with respect to each other (e.g. &#34;move forward&#34;
some entity that is rotated facing some arbitrary direction).
</p>


			

			

			

			

			
				
				<h3 id="Controller.BeginUpdate">func (*Controller) <a href="/target/controller.go?s=2034:2069#L63">BeginUpdate</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) BeginUpdate()</pre>
				<p>
Temporarily suspends all matrix re-calculations typically occuring inside
the MoveXyz() / TurnXyz() methods. Call this prior to multiple subsequent
calls to any combination of those methods, and/or prior to manually modifying
the Pos, Dir or UpAxis fields of me. Immediately afterwards, be sure to call
EndUpdate() to apply all changes in a final matrix re-calculation.
</p>

				
				
			
				
				<h3 id="Controller.CopyFrom">func (*Controller) <a href="/target/controller.go?s=2098:2145#L67">CopyFrom</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) CopyFrom(copy <a href="#Controller">Controller</a>)</pre>
				
				
				
			
				
				<h3 id="Controller.Dir">func (*Controller) <a href="/target/controller.go?s=2411:2449#L75">Dir</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) Dir() *<a href="/pkg/github.com/metaleap/go-util/num/">unum</a>.<a href="/pkg/github.com/metaleap/go-util/num/#Vec3">Vec3</a></pre>
				<p>
The direction being manipulated by this Controller.
NOTE: this returns a pointer to the direction vector to avoid a copy, but it&#39;s
NOT meant to be modified, as the vector is re-computed by the TurnFoo() methods.
</p>

				
				
			
				
				<h3 id="Controller.EndUpdate">func (*Controller) <a href="/target/controller.go?s=2776:2809#L83">EndUpdate</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) EndUpdate()</pre>
				<p>
Applies all changes made to Pos, Dir or UpAxis since BeginUpdate() was last
called, and recalculates this Controller&#39;s final 4x4 transformation matrix.
Also resumes all matrix re-calculations typically occuring inside the
MoveXyz() / TurnXyz() methods that were suspended since BeginUpdate().
</p>

				
				
			
				
				<h3 id="Controller.MoveBackward">func (*Controller) <a href="/target/controller.go?s=3701:3737#L115">MoveBackward</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) MoveBackward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move backward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveDown">func (*Controller) <a href="/target/controller.go?s=3898:3930#L121">MoveDown</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) MoveDown()</pre>
				<p>
Recomputes Pos with regards to UpAxis to effect a &#34;move downward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveForward">func (*Controller) <a href="/target/controller.go?s=4101:4136#L127">MoveForward</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) MoveForward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move forward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveLeft">func (*Controller) <a href="/target/controller.go?s=4306:4338#L133">MoveLeft</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) MoveLeft()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move left-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveRight">func (*Controller) <a href="/target/controller.go?s=4536:4569#L139">MoveRight</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) MoveRight()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move right-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveUp">func (*Controller) <a href="/target/controller.go?s=4755:4785#L145">MoveUp</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) MoveUp()</pre>
				<p>
Recomputes Pos with regards to UpAxis to effect a &#34;move upward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.StepSizeMove">func (*Controller) <a href="/target/controller.go?s=5257:5301#L164">StepSizeMove</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) StepSizeMove() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the current distance that a single MoveXyz() call (per loop iteration) would move.
(Loop.TickDelta * me.Params.MoveSpeed * me.Params.MoveSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.StepSizeTurn">func (*Controller) <a href="/target/controller.go?s=5548:5592#L170">StepSizeTurn</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) StepSizeTurn() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the current degrees that a single TurnXyz() call (per loop iteration) would turn.
(Loop.TickDelta * me.Params.TurnSpeed * me.Params.TurnSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.TurnDown">func (*Controller) <a href="/target/controller.go?s=5781:5813#L175">TurnDown</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) TurnDown()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnDownBy">func (*Controller) <a href="/target/controller.go?s=5956:6001#L180">TurnDownBy</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) TurnDownBy(deg <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeft">func (*Controller) <a href="/target/controller.go?s=6174:6206#L187">TurnLeft</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) TurnLeft()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeftBy">func (*Controller) <a href="/target/controller.go?s=6350:6395#L192">TurnLeftBy</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) TurnLeftBy(deg <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnRight">func (*Controller) <a href="/target/controller.go?s=6524:6557#L197">TurnRight</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) TurnRight()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnRightBy">func (*Controller) <a href="/target/controller.go?s=6703:6749#L202">TurnRightBy</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) TurnRightBy(deg <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnUp">func (*Controller) <a href="/target/controller.go?s=6875:6905#L207">TurnUp</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) TurnUp()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnUpBy">func (*Controller) <a href="/target/controller.go?s=7044:7087#L212">TurnUpBy</a></h3>
				<pre>func (me *<a href="#Controller">Controller</a>) TurnUpBy(deg <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34; by the specified degress.
</p>

				
				
			
		
			
			
			<h2 id="ControllerParams">type <a href="/target/controller.go?s=7149:7783#L218">ControllerParams</a></h2>
			<pre>type ControllerParams struct {
    <span class="comment">//	Speed of &#34;moving&#34; in the MoveXyz() methods, in units per second.</span>
    <span class="comment">//	Defaults to 2.</span>
    MoveSpeed <a href="/pkg/builtin/#float64">float64</a>

    <span class="comment">//	A factor multiplied with MoveSpeed in the MoveXyz() methods. Defaults to 1.</span>
    MoveSpeedupFactor <a href="/pkg/builtin/#float64">float64</a>

    <span class="comment">//	Speed of &#34;turning&#34; in the TurnXyz() methods, in degrees per second.</span>
    <span class="comment">//	Defaults to 90.</span>
    TurnSpeed <a href="/pkg/builtin/#float64">float64</a>

    <span class="comment">//	A factor multiplied with TurnSpeed in the TurnXyz() methods. Defaults to 1.</span>
    TurnSpeedupFactor <a href="/pkg/builtin/#float64">float64</a>

    <span class="comment">//	The maximum degree that TurnUp() allows. Defaults to 90.</span>
    MaxTurnUp <a href="/pkg/builtin/#float64">float64</a>

    <span class="comment">//	The minimum degree that TurnDown() allows. Defaults to -90.</span>
    MinTurnDown <a href="/pkg/builtin/#float64">float64</a>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxEffect">type <a href="/target/fx-effect.gt.go?s=209:718#L1">FxEffect</a></h2>
			<pre>type FxEffect struct {
    <span class="comment">//	An ordered collection of all FxProcs that make up this effect.</span>
    <span class="comment">//	When changing the ordering or disabling, enabling or toggling individual FxProcs,</span>
    <span class="comment">//	you need to call the FxEffect.UpdateRoutine() method to reflect such changes.</span>
    <span class="comment">//	All other dynamic, individual FxProc-specific parameter changes</span>
    <span class="comment">//	(colors, image bindings, weights etc.pp.) do not require this.</span>
    <a href="#FxProcs">FxProcs</a>

    ID <a href="/pkg/builtin/#int">int</a>

    KeepProcIDsLast []<a href="/pkg/builtin/#string">string</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Declares the visual appearance of a surface.
An FxEffect can be reused for multiple surfaces, it is bound to geometry via an FxMaterial.
</p>


			

			

			

			

			
				
				<h3 id="FxEffect.UpdateRoutine">func (*FxEffect) <a href="/target/fx-effect.gt.go?s=896:931#L24">UpdateRoutine</a></h3>
				<pre>func (me *<a href="#FxEffect">FxEffect</a>) UpdateRoutine()</pre>
				
				
				
			
		
			
			
			<h2 id="FxEffectLib">type <a href="/target/fx-effect.gt.go?s=2035:2062#L79">FxEffectLib</a></h2>
			<pre>type FxEffectLib []<a href="#FxEffect">FxEffect</a></pre>
			<p>
Only used for Core.Libs.Effects
</p>


			

			

			

			

			
				
				<h3 id="FxEffectLib.AddNew">func (*FxEffectLib) <a href="/target/fx-effect.gt.go?s=2064:2104#L81">AddNew</a></h3>
				<pre>func (me *<a href="#FxEffectLib">FxEffectLib</a>) AddNew() (id <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="FxEffectLib.Compact">func (*FxEffectLib) <a href="/target/fx-effect.gt.go?s=2433:2465#L103">Compact</a></h3>
				<pre>func (me *<a href="#FxEffectLib">FxEffectLib</a>) Compact()</pre>
				
				
				
			
				
				<h3 id="FxEffectLib.IsOk">func (FxEffectLib) <a href="/target/fx-effect.gt.go?s=3244:3288#L146">IsOk</a></h3>
				<pre>func (me <a href="#FxEffectLib">FxEffectLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="FxEffectLib.Ok">func (FxEffectLib) <a href="/target/fx-effect.gt.go?s=3358:3395#L153">Ok</a></h3>
				<pre>func (me <a href="#FxEffectLib">FxEffectLib</a>) Ok(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxEffectLib.Remove">func (FxEffectLib) <a href="/target/fx-effect.gt.go?s=3425:3470#L157">Remove</a></h3>
				<pre>func (me <a href="#FxEffectLib">FxEffectLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="FxEffectLib.Walk">func (FxEffectLib) <a href="/target/fx-effect.gt.go?s=3758:3808#L171">Walk</a></h3>
				<pre>func (me <a href="#FxEffectLib">FxEffectLib</a>) Walk(on func(ref *<a href="#FxEffect">FxEffect</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="FxImage2D">type <a href="/target/fx-image-2d.gt.go?s=105:210#L1">FxImage2D</a></h2>
			<pre>type FxImage2D struct {
    <a href="#FxImageBase">FxImageBase</a>
    InitFrom <a href="#FxImageInitFrom">FxImageInitFrom</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxImage2D.GpuDelete">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=334:366#L18">GpuDelete</a></h3>
				<pre>func (me *<a href="#FxImage2D">FxImage2D</a>) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="FxImage2D.GpuSync">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=409:451#L22">GpuSync</a></h3>
				<pre>func (me *<a href="#FxImage2D">FxImage2D</a>) GpuSync() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Load">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=598:637#L29">Load</a></h3>
				<pre>func (me *<a href="#FxImage2D">FxImage2D</a>) Load() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Loaded">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=718:752#L35">Loaded</a></h3>
				<pre>func (me *<a href="#FxImage2D">FxImage2D</a>) Loaded() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxImage2D.NoAutoMips">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=780:813#L39">NoAutoMips</a></h3>
				<pre>func (me *<a href="#FxImage2D">FxImage2D</a>) NoAutoMips()</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Unload">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=869:898#L43">Unload</a></h3>
				<pre>func (me *<a href="#FxImage2D">FxImage2D</a>) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImage2DLib">type <a href="/target/fx-image-2d.gt.go?s=1040:1069#L50">FxImage2DLib</a></h2>
			<pre>type FxImage2DLib []<a href="#FxImage2D">FxImage2D</a></pre>
			<p>
Only used for Core.Libs.Images.Tex2D
</p>


			

			

			

			

			
				
				<h3 id="FxImage2DLib.AddNew">func (*FxImage2DLib) <a href="/target/fx-image-2d.gt.go?s=1071:1112#L52">AddNew</a></h3>
				<pre>func (me *<a href="#FxImage2DLib">FxImage2DLib</a>) AddNew() (id <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="FxImage2DLib.Compact">func (*FxImage2DLib) <a href="/target/fx-image-2d.gt.go?s=1443:1476#L74">Compact</a></h3>
				<pre>func (me *<a href="#FxImage2DLib">FxImage2DLib</a>) Compact()</pre>
				
				
				
			
				
				<h3 id="FxImage2DLib.IsOk">func (FxImage2DLib) <a href="/target/fx-image-2d.gt.go?s=2263:2308#L117">IsOk</a></h3>
				<pre>func (me <a href="#FxImage2DLib">FxImage2DLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="FxImage2DLib.Ok">func (FxImage2DLib) <a href="/target/fx-image-2d.gt.go?s=2378:2416#L124">Ok</a></h3>
				<pre>func (me <a href="#FxImage2DLib">FxImage2DLib</a>) Ok(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxImage2DLib.Remove">func (FxImage2DLib) <a href="/target/fx-image-2d.gt.go?s=2446:2492#L128">Remove</a></h3>
				<pre>func (me <a href="#FxImage2DLib">FxImage2DLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="FxImage2DLib.Walk">func (FxImage2DLib) <a href="/target/fx-image-2d.gt.go?s=2781:2833#L142">Walk</a></h3>
				<pre>func (me <a href="#FxImage2DLib">FxImage2DLib</a>) Walk(on func(ref *<a href="#FxImage2D">FxImage2D</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageBase">type <a href="/target/fx-image.go?s=451:567#L23">FxImageBase</a></h2>
			<pre>type FxImageBase struct {
    ID         <a href="/pkg/builtin/#int">int</a>
    Preprocess <a href="#FxImagePreprocess">FxImagePreprocess</a>
    Storage    <a href="#FxImageStorage">FxImageStorage</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxImageBase.GpuSynced">func (*FxImageBase) <a href="/target/fx-image.go?s=975:1014#L48">GpuSynced</a></h3>
				<pre>func (me *<a href="#FxImageBase">FxImageBase</a>) GpuSynced() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
		
			
			
			<h2 id="FxImageCube">type <a href="/target/fx-image-cube.gt.go?s=74:191#L1">FxImageCube</a></h2>
			<pre>type FxImageCube struct {
    <a href="#FxImageBase">FxImageBase</a>
    InitFrom [6]<a href="#FxImageInitFrom">FxImageInitFrom</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxImageCube.GpuDelete">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=348:382#L17">GpuDelete</a></h3>
				<pre>func (me *<a href="#FxImageCube">FxImageCube</a>) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="FxImageCube.GpuSync">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=425:469#L21">GpuSync</a></h3>
				<pre>func (me *<a href="#FxImageCube">FxImageCube</a>) GpuSync() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="FxImageCube.Load">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=626:667#L28">Load</a></h3>
				<pre>func (me *<a href="#FxImageCube">FxImageCube</a>) Load() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="FxImageCube.Loaded">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=817:853#L38">Loaded</a></h3>
				<pre>func (me *<a href="#FxImageCube">FxImageCube</a>) Loaded() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxImageCube.NoAutoMips">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=948:983#L47">NoAutoMips</a></h3>
				<pre>func (me *<a href="#FxImageCube">FxImageCube</a>) NoAutoMips()</pre>
				
				
				
			
				
				<h3 id="FxImageCube.Unload">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=1039:1070#L51">Unload</a></h3>
				<pre>func (me *<a href="#FxImageCube">FxImageCube</a>) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageCubeLib">type <a href="/target/fx-image-cube.gt.go?s=1268:1301#L61">FxImageCubeLib</a></h2>
			<pre>type FxImageCubeLib []<a href="#FxImageCube">FxImageCube</a></pre>
			<p>
Only used for Core.Libs.Images.TexCube
</p>


			

			

			

			

			
				
				<h3 id="FxImageCubeLib.AddNew">func (*FxImageCubeLib) <a href="/target/fx-image-cube.gt.go?s=1303:1346#L63">AddNew</a></h3>
				<pre>func (me *<a href="#FxImageCubeLib">FxImageCubeLib</a>) AddNew() (id <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="FxImageCubeLib.Compact">func (*FxImageCubeLib) <a href="/target/fx-image-cube.gt.go?s=1681:1716#L85">Compact</a></h3>
				<pre>func (me *<a href="#FxImageCubeLib">FxImageCubeLib</a>) Compact()</pre>
				
				
				
			
				
				<h3 id="FxImageCubeLib.IsOk">func (FxImageCubeLib) <a href="/target/fx-image-cube.gt.go?s=2519:2566#L128">IsOk</a></h3>
				<pre>func (me <a href="#FxImageCubeLib">FxImageCubeLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="FxImageCubeLib.Ok">func (FxImageCubeLib) <a href="/target/fx-image-cube.gt.go?s=2636:2676#L135">Ok</a></h3>
				<pre>func (me <a href="#FxImageCubeLib">FxImageCubeLib</a>) Ok(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxImageCubeLib.Remove">func (FxImageCubeLib) <a href="/target/fx-image-cube.gt.go?s=2706:2754#L139">Remove</a></h3>
				<pre>func (me <a href="#FxImageCubeLib">FxImageCubeLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="FxImageCubeLib.Walk">func (FxImageCubeLib) <a href="/target/fx-image-cube.gt.go?s=3045:3101#L153">Walk</a></h3>
				<pre>func (me <a href="#FxImageCubeLib">FxImageCubeLib</a>) Walk(on func(ref *<a href="#FxImageCube">FxImageCube</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageInitFrom">type <a href="/target/fx-image-loading.go?s=116:179#L3">FxImageInitFrom</a></h2>
			<pre>type FxImageInitFrom struct {
    RawData []<a href="/pkg/builtin/#byte">byte</a>
    RefUrl  <a href="/pkg/builtin/#string">string</a>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxImagePreprocess">type <a href="/target/fx-image.go?s=145:223#L5">FxImagePreprocess</a></h2>
			<pre>type FxImagePreprocess struct {
    FlipY    <a href="/pkg/builtin/#bool">bool</a>
    ToLinear <a href="/pkg/builtin/#bool">bool</a>
    ToBgra   <a href="/pkg/builtin/#bool">bool</a>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxImageStorage">type <a href="/target/fx-image.go?s=225:449#L11">FxImageStorage</a></h2>
			<pre>type FxImageStorage struct {
    DiskCache struct {
        Enabled      <a href="/pkg/builtin/#bool">bool</a>
        Compressor   func(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#WriteCloser">WriteCloser</a>) <a href="/pkg/io/">io</a>.<a href="/pkg/io/#WriteCloser">WriteCloser</a>
        Decompressor func(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#ReadCloser">ReadCloser</a>) <a href="/pkg/io/">io</a>.<a href="/pkg/io/#ReadCloser">ReadCloser</a>
    }
    Gpu struct {
        Bgra    <a href="/pkg/builtin/#bool">bool</a>
        UintRev <a href="/pkg/builtin/#bool">bool</a>
    }
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxMaterial">type <a href="/target/fx-material.gt.go?s=103:530#L1">FxMaterial</a></h2>
			<pre>type FxMaterial struct {
    ID <a href="/pkg/builtin/#int">int</a>

    <span class="comment">//	This effect is used by default for all faces that do not</span>
    <span class="comment">//	match any of the selectors in the FaceEffects field.</span>
    DefaultEffectID <a href="/pkg/builtin/#int">int</a>

    <span class="comment">//	Associates certain individual faces or tags of faces</span>
    <span class="comment">//	with specific effect IDs.</span>
    FaceEffects struct {
        <span class="comment">//	Associates face tags with effect IDs.</span>
        ByTag map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#int">int</a>

        <span class="comment">//	Associates specific face IDs with effect IDs.</span>
        ByID map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#int">int</a>
    }
}</pre>
			<p>
A material binds effects (FxEffect in Core.Libs.Effects) to geometry (Model or Node).
</p>


			

			

			

			

			
				
				<h3 id="FxMaterial.HasFaceEffects">func (*FxMaterial) <a href="/target/fx-material.gt.go?s=1208:1251#L38">HasFaceEffects</a></h3>
				<pre>func (me *<a href="#FxMaterial">FxMaterial</a>) HasFaceEffects() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
		
			
			
			<h2 id="FxMaterialLib">type <a href="/target/fx-material.gt.go?s=1424:1455#L45">FxMaterialLib</a></h2>
			<pre>type FxMaterialLib []<a href="#FxMaterial">FxMaterial</a></pre>
			<p>
Only used for Core.Libs.Materials
</p>


			

			

			

			

			
				
				<h3 id="FxMaterialLib.AddNew">func (*FxMaterialLib) <a href="/target/fx-material.gt.go?s=1457:1499#L47">AddNew</a></h3>
				<pre>func (me *<a href="#FxMaterialLib">FxMaterialLib</a>) AddNew() (id <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="FxMaterialLib.Compact">func (*FxMaterialLib) <a href="/target/fx-material.gt.go?s=1832:1866#L69">Compact</a></h3>
				<pre>func (me *<a href="#FxMaterialLib">FxMaterialLib</a>) Compact()</pre>
				
				
				
			
				
				<h3 id="FxMaterialLib.IsOk">func (FxMaterialLib) <a href="/target/fx-material.gt.go?s=2661:2707#L112">IsOk</a></h3>
				<pre>func (me <a href="#FxMaterialLib">FxMaterialLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="FxMaterialLib.Ok">func (FxMaterialLib) <a href="/target/fx-material.gt.go?s=2777:2816#L119">Ok</a></h3>
				<pre>func (me <a href="#FxMaterialLib">FxMaterialLib</a>) Ok(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxMaterialLib.Remove">func (FxMaterialLib) <a href="/target/fx-material.gt.go?s=2846:2893#L123">Remove</a></h3>
				<pre>func (me <a href="#FxMaterialLib">FxMaterialLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="FxMaterialLib.Walk">func (FxMaterialLib) <a href="/target/fx-material.gt.go?s=3183:3237#L137">Walk</a></h3>
				<pre>func (me <a href="#FxMaterialLib">FxMaterialLib</a>) Walk(on func(ref *<a href="#FxMaterial">FxMaterial</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="FxProc">type <a href="/target/fx-procs.gt.go?s=267:534#L3">FxProc</a></h2>
			<pre>type FxProc struct {
    Enabled <a href="/pkg/builtin/#bool">bool</a>

    Color struct {
        Rgb <a href="/pkg/github.com/go3d/go-opengl/util/">ugl</a>.<a href="/pkg/github.com/go3d/go-opengl/util/#GlVec3">GlVec3</a>
    }

    Tex struct {
        ImageID <a href="/pkg/builtin/#int">int</a>

        Sampler <a href="/pkg/github.com/go3d/go-opengl/util/">ugl</a>.<a href="/pkg/github.com/go3d/go-opengl/util/#Sampler">Sampler</a>
        <span class="comment">// contains filtered or unexported fields</span>
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxProc.Color_SetRgb">func (*FxProc) <a href="/target/fx-procs.gt.go?s=2372:2427#L86">Color_SetRgb</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) Color_SetRgb(rgb ...<a href="/pkg/github.com/go3d/go-opengl/core/">gl</a>.<a href="/pkg/github.com/go3d/go-opengl/core/#Float">Float</a>) *<a href="#FxProc">FxProc</a></pre>
				
				
				
			
				
				<h3 id="FxProc.IsColor">func (*FxProc) <a href="/target/fx-procs.gt.go?s=9508:9540#L345">IsColor</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) IsColor() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxProc.IsCoords">func (*FxProc) <a href="/target/fx-procs.gt.go?s=8693:8726#L316">IsCoords</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) IsCoords() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxProc.IsGamma">func (*FxProc) <a href="/target/fx-procs.gt.go?s=10309:10341#L374">IsGamma</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) IsGamma() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxProc.IsGrayscale">func (*FxProc) <a href="/target/fx-procs.gt.go?s=7836:7872#L287">IsGrayscale</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) IsGrayscale() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxProc.IsOrangify">func (*FxProc) <a href="/target/fx-procs.gt.go?s=6993:7028#L258">IsOrangify</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) IsOrangify() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxProc.IsTex">func (*FxProc) <a href="/target/fx-procs.gt.go?s=2566:2596#L96">IsTex</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) IsTex() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxProc.IsTex2D">func (*FxProc) <a href="/target/fx-procs.gt.go?s=5363:5395#L200">IsTex2D</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) IsTex2D() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxProc.IsTexCube">func (*FxProc) <a href="/target/fx-procs.gt.go?s=6164:6198#L229">IsTexCube</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) IsTexCube() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="FxProc.SetMixWeight">func (*FxProc) <a href="/target/fx-procs.gt.go?s=2232:2278#L78">SetMixWeight</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) SetMixWeight(weight <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
			
				
				<h3 id="FxProc.Tex_SetImageID">func (*FxProc) <a href="/target/fx-procs.gt.go?s=2470:2523#L91">Tex_SetImageID</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) Tex_SetImageID(imageID <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				
				
				
			
				
				<h3 id="FxProc.Toggle">func (*FxProc) <a href="/target/fx-procs.gt.go?s=2314:2340#L82">Toggle</a></h3>
				<pre>func (me *<a href="#FxProc">FxProc</a>) Toggle()</pre>
				
				
				
			
		
			
			
			<h2 id="FxProcs">type <a href="/target/fx-procs.gt.go?s=2698:2719#L101">FxProcs</a></h2>
			<pre>type FxProcs []<a href="#FxProc">FxProc</a></pre>
			<p>
Used for FxEffect.Procs and Camera.Rendering.FxProcs.
</p>


			

			

			

			

			
				
				<h3 id="FxProcs.Disable">func (FxProcs) <a href="/target/fx-procs.gt.go?s=2979:3026#L107">Disable</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) Disable(procID <a href="/pkg/builtin/#string">string</a>, n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Disables the nth (0-based) FxProc with the specified procID,
or all FxProcs with the specified procID if n &lt; 0.
The procID must be one of the Core.Render.Fx.KnownProcIDs.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.DisableColor">func (FxProcs) <a href="/target/fx-procs.gt.go?s=9707:9744#L351">DisableColor</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) DisableColor(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Color&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.DisableCoords">func (FxProcs) <a href="/target/fx-procs.gt.go?s=8895:8933#L322">DisableCoords</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) DisableCoords(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Coords&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.DisableGamma">func (FxProcs) <a href="/target/fx-procs.gt.go?s=10508:10545#L380">DisableGamma</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) DisableGamma(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Gamma&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.DisableGrayscale">func (FxProcs) <a href="/target/fx-procs.gt.go?s=8047:8088#L293">DisableGrayscale</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) DisableGrayscale(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Grayscale&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.DisableOrangify">func (FxProcs) <a href="/target/fx-procs.gt.go?s=7201:7241#L264">DisableOrangify</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) DisableOrangify(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Orangify&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.DisableTex2D">func (FxProcs) <a href="/target/fx-procs.gt.go?s=5562:5599#L206">DisableTex2D</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) DisableTex2D(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Tex2D&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.DisableTexCube">func (FxProcs) <a href="/target/fx-procs.gt.go?s=6369:6408#L235">DisableTexCube</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) DisableTexCube(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;TexCube&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.Enable">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=3540:3602#L126">Enable</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) Enable(procID <a href="/pkg/builtin/#string">string</a>, n <a href="/pkg/builtin/#int">int</a>) (proc *<a href="#FxProc">FxProc</a>)</pre>
				<p>
Enables the nth (0-based) FxProc with the specified procID,
or all FxProcs with the specified procID if n &lt; 0.
If me has no FxProc with the specified procID, appends a new one.
The procID must be one of the Core.Render.Fx.KnownProcIDs.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.EnableColor">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=9905:9950#L357">EnableColor</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) EnableColor(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Enable(&#34;Color&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.EnableCoords">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=9096:9142#L328">EnableCoords</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) EnableCoords(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Enable(&#34;Coords&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.EnableGamma">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=10706:10751#L386">EnableGamma</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) EnableGamma(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Enable(&#34;Gamma&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.EnableGrayscale">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=8257:8306#L299">EnableGrayscale</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) EnableGrayscale(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Enable(&#34;Grayscale&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.EnableOrangify">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=7408:7456#L270">EnableOrangify</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) EnableOrangify(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Enable(&#34;Orangify&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.EnableTex2D">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=5760:5805#L212">EnableTex2D</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) EnableTex2D(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Enable(&#34;Tex2D&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.EnableTexCube">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=6573:6620#L241">EnableTexCube</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) EnableTexCube(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Enable(&#34;TexCube&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.EnsureLast">func (FxProcs) <a href="/target/fx-procs.gt.go?s=3903:3954#L144">EnsureLast</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) EnsureLast(lastProcIDs ...<a href="/pkg/builtin/#string">string</a>)</pre>
				
				
				
			
				
				<h3 id="FxProcs.Get">func (FxProcs) <a href="/target/fx-procs.gt.go?s=4282:4340#L160">Get</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) Get(procID <a href="/pkg/builtin/#string">string</a>, n <a href="/pkg/builtin/#int">int</a>) (proc *<a href="#FxProc">FxProc</a>)</pre>
				<p>
Returns the nth (0-based) FxProc with the specified procID.
The procID must be one of the Core.Render.Fx.KnownProcIDs.
</p>

				
				
			
				
				<h3 id="FxProcs.GetColor">func (FxProcs) <a href="/target/fx-procs.gt.go?s=10036:10077#L362">GetColor</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) GetColor(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Get(&#34;Color&#34;, n).
</p>

				
				
			
				
				<h3 id="FxProcs.GetCoords">func (FxProcs) <a href="/target/fx-procs.gt.go?s=9230:9272#L333">GetCoords</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) GetCoords(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Get(&#34;Coords&#34;, n).
</p>

				
				
			
				
				<h3 id="FxProcs.GetGamma">func (FxProcs) <a href="/target/fx-procs.gt.go?s=10837:10878#L391">GetGamma</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) GetGamma(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Get(&#34;Gamma&#34;, n).
</p>

				
				
			
				
				<h3 id="FxProcs.GetGrayscale">func (FxProcs) <a href="/target/fx-procs.gt.go?s=8400:8445#L304">GetGrayscale</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) GetGrayscale(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Get(&#34;Grayscale&#34;, n).
</p>

				
				
			
				
				<h3 id="FxProcs.GetOrangify">func (FxProcs) <a href="/target/fx-procs.gt.go?s=7548:7592#L275">GetOrangify</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) GetOrangify(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Get(&#34;Orangify&#34;, n).
</p>

				
				
			
				
				<h3 id="FxProcs.GetTex2D">func (FxProcs) <a href="/target/fx-procs.gt.go?s=5891:5932#L217">GetTex2D</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) GetTex2D(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Get(&#34;Tex2D&#34;, n).
</p>

				
				
			
				
				<h3 id="FxProcs.GetTexCube">func (FxProcs) <a href="/target/fx-procs.gt.go?s=6710:6753#L246">GetTexCube</a></h3>
				<pre>func (me <a href="#FxProcs">FxProcs</a>) GetTexCube(n <a href="/pkg/builtin/#int">int</a>) *<a href="#FxProc">FxProc</a></pre>
				<p>
Convenience short-hand for me.Get(&#34;TexCube&#34;, n).
</p>

				
				
			
				
				<h3 id="FxProcs.Toggle">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=4818:4865#L178">Toggle</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) Toggle(procID <a href="/pkg/builtin/#string">string</a>, n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Toggles the nth (0-based) FxProc with the specified procID,
or all FxProcs with the specified procID if n &lt; 0.
If me has no FxProc with the specified procID, appends a new one.
The procID must be one of the Core.Render.Fx.KnownProcIDs.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.ToggleColor">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=10241:10278#L368">ToggleColor</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) ToggleColor(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Color&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.ToggleCoords">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=9438:9476#L339">ToggleCoords</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) ToggleCoords(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Coords&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.ToggleGamma">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=11042:11079#L397">ToggleGamma</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) ToggleGamma(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Gamma&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.ToggleGrayscale">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=8617:8658#L310">ToggleGrayscale</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) ToggleGrayscale(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Grayscale&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.ToggleOrangify">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=7762:7802#L281">ToggleOrangify</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) ToggleOrangify(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Orangify&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.ToggleTex2D">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=6096:6133#L223">ToggleTex2D</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) ToggleTex2D(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Tex2D&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxProcs.ToggleTexCube">func (*FxProcs) <a href="/target/fx-procs.gt.go?s=6921:6960#L252">ToggleTexCube</a></h3>
				<pre>func (me *<a href="#FxProcs">FxProcs</a>) ToggleTexCube(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;TexCube&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
		
			
			
			<h2 id="LibElemIDChangedHandler">type <a href="/target/ng-libs.go?s=14:70#L1">LibElemIDChangedHandler</a></h2>
			<pre>type LibElemIDChangedHandler func(oldNewIDs map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>)</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="LibElemIDChangedHandlers">type <a href="/target/ng-libs.go?s=72:127#L1">LibElemIDChangedHandlers</a></h2>
			<pre>type LibElemIDChangedHandlers []<a href="#LibElemIDChangedHandler">LibElemIDChangedHandler</a></pre>
			

			

			

			

			

			
				
				<h3 id="LibElemIDChangedHandlers.Add">func (*LibElemIDChangedHandlers) <a href="/target/ng-libs.go?s=129:196#L1">Add</a></h3>
				<pre>func (me *<a href="#LibElemIDChangedHandlers">LibElemIDChangedHandlers</a>) Add(fn <a href="#LibElemIDChangedHandler">LibElemIDChangedHandler</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="Mesh">type <a href="/target/mesh.gt.go?s=590:969#L24">Mesh</a></h2>
			<pre>type Mesh struct {
    ID             <a href="/pkg/builtin/#int">int</a>
    DefaultModelID <a href="/pkg/builtin/#int">int</a>
    Name           <a href="/pkg/builtin/#string">string</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="Mesh.GpuDelete">func (*Mesh) <a href="/target/mesh.gt.go?s=1070:1097#L43">GpuDelete</a></h3>
				<pre>func (me *<a href="#Mesh">Mesh</a>) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUpload">func (*Mesh) <a href="/target/mesh.gt.go?s=1148:1187#L49">GpuUpload</a></h3>
				<pre>func (me *<a href="#Mesh">Mesh</a>) GpuUpload() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUploaded">func (*Mesh) <a href="/target/mesh.gt.go?s=2698:2732#L77">GpuUploaded</a></h3>
				<pre>func (me *<a href="#Mesh">Mesh</a>) GpuUploaded() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="Mesh.Load">func (*Mesh) <a href="/target/mesh.gt.go?s=2759:2818#L81">Load</a></h3>
				<pre>func (me *<a href="#Mesh">Mesh</a>) Load(provider <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#MeshProvider">MeshProvider</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="Mesh.Loaded">func (*Mesh) <a href="/target/mesh.gt.go?s=5494:5523#L145">Loaded</a></h3>
				<pre>func (me *<a href="#Mesh">Mesh</a>) Loaded() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="Mesh.Unload">func (*Mesh) <a href="/target/mesh.gt.go?s=5559:5583#L149">Unload</a></h3>
				<pre>func (me *<a href="#Mesh">Mesh</a>) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffer">type <a href="/target/mesh-buffer.gt.go?s=143:363#L1">MeshBuffer</a></h2>
			<pre>type MeshBuffer struct {
    Name <a href="/pkg/builtin/#string">string</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffer.Add">func (*MeshBuffer) <a href="/target/mesh-buffer.gt.go?s=1555:1604#L54">Add</a></h3>
				<pre>func (me *<a href="#MeshBuffer">MeshBuffer</a>) Add(meshID <a href="/pkg/builtin/#int">int</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="MeshBuffer.Remove">func (*MeshBuffer) <a href="/target/mesh-buffer.gt.go?s=2186:2226#L73">Remove</a></h3>
				<pre>func (me *<a href="#MeshBuffer">MeshBuffer</a>) Remove(meshID <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBufferLib">type <a href="/target/mesh-buffer.gt.go?s=3766:3798#L130">MeshBufferLib</a></h2>
			<pre>type MeshBufferLib []*<a href="#MeshBuffer">MeshBuffer</a></pre>
			<p>
Only used for Core.Mesh.Buffers
</p>


			

			

			

			

			
				
				<h3 id="MeshBufferLib.AddNew">func (*MeshBufferLib) <a href="/target/mesh-buffer.gt.go?s=3028:3117#L103">AddNew</a></h3>
				<pre>func (me *<a href="#MeshBufferLib">MeshBufferLib</a>) AddNew(name <a href="/pkg/builtin/#string">string</a>, capacity <a href="/pkg/builtin/#int32">int32</a>) (buf *<a href="#MeshBuffer">MeshBuffer</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="MeshBufferLib.FloatsPerVertex">func (MeshBufferLib) <a href="/target/mesh-buffer.gt.go?s=3259:3305#L113">FloatsPerVertex</a></h3>
				<pre>func (_ <a href="#MeshBufferLib">MeshBufferLib</a>) FloatsPerVertex() <a href="/pkg/builtin/#int32">int32</a></pre>
				
				
				
			
				
				<h3 id="MeshBufferLib.IsOk">func (MeshBufferLib) <a href="/target/mesh-buffer.gt.go?s=4022:4063#L146">IsOk</a></h3>
				<pre>func (me <a href="#MeshBufferLib">MeshBufferLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="MeshBufferLib.MemSizePerIndex">func (MeshBufferLib) <a href="/target/mesh-buffer.gt.go?s=3466:3512#L118">MemSizePerIndex</a></h3>
				<pre>func (_ <a href="#MeshBufferLib">MeshBufferLib</a>) MemSizePerIndex() <a href="/pkg/builtin/#int32">int32</a></pre>
				
				
				
			
				
				<h3 id="MeshBufferLib.MemSizePerVertex">func (MeshBufferLib) <a href="/target/mesh-buffer.gt.go?s=3528:3575#L122">MemSizePerVertex</a></h3>
				<pre>func (_ <a href="#MeshBufferLib">MeshBufferLib</a>) MemSizePerVertex() <a href="/pkg/builtin/#int32">int32</a></pre>
				
				
				
			
				
				<h3 id="MeshBufferLib.Remove">func (*MeshBufferLib) <a href="/target/mesh-buffer.gt.go?s=4101:4149#L150">Remove</a></h3>
				<pre>func (me *<a href="#MeshBufferLib">MeshBufferLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="MeshBufferLib.Walk">func (MeshBufferLib) <a href="/target/mesh-buffer.gt.go?s=4423:4477#L163">Walk</a></h3>
				<pre>func (me <a href="#MeshBufferLib">MeshBufferLib</a>) Walk(on func(ref *<a href="#MeshBuffer">MeshBuffer</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="MeshLib">type <a href="/target/mesh.gt.go?s=6641:6660#L198">MeshLib</a></h2>
			<pre>type MeshLib []<a href="#Mesh">Mesh</a></pre>
			<p>
Only used for Core.Libs.Meshes
</p>


			

			

			

			

			
				
				<h3 id="MeshLib.AddNew">func (*MeshLib) <a href="/target/mesh.gt.go?s=6662:6698#L200">AddNew</a></h3>
				<pre>func (me *<a href="#MeshLib">MeshLib</a>) AddNew() (id <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="MeshLib.AddNewAndLoad">func (*MeshLib) <a href="/target/mesh.gt.go?s=5879:5979#L164">AddNewAndLoad</a></h3>
				<pre>func (me *<a href="#MeshLib">MeshLib</a>) AddNewAndLoad(name <a href="/pkg/builtin/#string">string</a>, meshProvider <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#MeshProvider">MeshProvider</a>) (meshID <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="MeshLib.Compact">func (*MeshLib) <a href="/target/mesh.gt.go?s=7019:7047#L222">Compact</a></h3>
				<pre>func (me *<a href="#MeshLib">MeshLib</a>) Compact()</pre>
				
				
				
			
				
				<h3 id="MeshLib.GpuSync">func (MeshLib) <a href="/target/mesh.gt.go?s=5630:5668#L153">GpuSync</a></h3>
				<pre>func (_ <a href="#MeshLib">MeshLib</a>) GpuSync() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="MeshLib.IsOk">func (MeshLib) <a href="/target/mesh.gt.go?s=7794:7834#L265">IsOk</a></h3>
				<pre>func (me <a href="#MeshLib">MeshLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="MeshLib.MeshCube">func (MeshLib) <a href="/target/mesh.gt.go?s=6145:6189#L175">MeshCube</a></h3>
				<pre>func (_ <a href="#MeshLib">MeshLib</a>) MeshCube() <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#MeshProvider">MeshProvider</a></pre>
				
				
				
			
				
				<h3 id="MeshLib.MeshPlane">func (MeshLib) <a href="/target/mesh.gt.go?s=6226:6271#L179">MeshPlane</a></h3>
				<pre>func (_ <a href="#MeshLib">MeshLib</a>) MeshPlane() <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#MeshProvider">MeshProvider</a></pre>
				
				
				
			
				
				<h3 id="MeshLib.MeshPyramid">func (MeshLib) <a href="/target/mesh.gt.go?s=6309:6356#L183">MeshPyramid</a></h3>
				<pre>func (_ <a href="#MeshLib">MeshLib</a>) MeshPyramid() <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#MeshProvider">MeshProvider</a></pre>
				
				
				
			
				
				<h3 id="MeshLib.MeshQuad">func (MeshLib) <a href="/target/mesh.gt.go?s=6396:6440#L187">MeshQuad</a></h3>
				<pre>func (_ <a href="#MeshLib">MeshLib</a>) MeshQuad() <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#MeshProvider">MeshProvider</a></pre>
				
				
				
			
				
				<h3 id="MeshLib.MeshTri">func (MeshLib) <a href="/target/mesh.gt.go?s=6477:6520#L191">MeshTri</a></h3>
				<pre>func (_ <a href="#MeshLib">MeshLib</a>) MeshTri() <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#MeshProvider">MeshProvider</a></pre>
				
				
				
			
				
				<h3 id="MeshLib.Ok">func (MeshLib) <a href="/target/mesh.gt.go?s=7904:7937#L272">Ok</a></h3>
				<pre>func (me <a href="#MeshLib">MeshLib</a>) Ok(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="MeshLib.Remove">func (MeshLib) <a href="/target/mesh.gt.go?s=7967:8008#L276">Remove</a></h3>
				<pre>func (me <a href="#MeshLib">MeshLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="MeshLib.Walk">func (MeshLib) <a href="/target/mesh.gt.go?s=8292:8334#L290">Walk</a></h3>
				<pre>func (me <a href="#MeshLib">MeshLib</a>) Walk(on func(ref *<a href="#Mesh">Mesh</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="Model">type <a href="/target/model.gt.go?s=143:200#L1">Model</a></h2>
			<pre>type Model struct {
    ID    <a href="/pkg/builtin/#int">int</a>
    MatID <a href="/pkg/builtin/#int">int</a>
    Name  <a href="/pkg/builtin/#string">string</a>
}</pre>
			<p>
A Model is a parameterized instantiation of its parent Mesh geometry
with unique appearance, material or other properties.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ModelLib">type <a href="/target/model.gt.go?s=372:393#L12">ModelLib</a></h2>
			<pre>type ModelLib []<a href="#Model">Model</a></pre>
			<p>
Only used for Core.Libs.Models
</p>


			

			

			

			

			
				
				<h3 id="ModelLib.AddNew">func (*ModelLib) <a href="/target/model.gt.go?s=395:432#L14">AddNew</a></h3>
				<pre>func (me *<a href="#ModelLib">ModelLib</a>) AddNew() (id <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="ModelLib.Compact">func (*ModelLib) <a href="/target/model.gt.go?s=755:784#L36">Compact</a></h3>
				<pre>func (me *<a href="#ModelLib">ModelLib</a>) Compact()</pre>
				
				
				
			
				
				<h3 id="ModelLib.IsOk">func (ModelLib) <a href="/target/model.gt.go?s=1539:1580#L79">IsOk</a></h3>
				<pre>func (me <a href="#ModelLib">ModelLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="ModelLib.Ok">func (ModelLib) <a href="/target/model.gt.go?s=1650:1684#L86">Ok</a></h3>
				<pre>func (me <a href="#ModelLib">ModelLib</a>) Ok(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="ModelLib.Remove">func (ModelLib) <a href="/target/model.gt.go?s=1714:1756#L90">Remove</a></h3>
				<pre>func (me <a href="#ModelLib">ModelLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="ModelLib.Walk">func (ModelLib) <a href="/target/model.gt.go?s=2041:2085#L104">Walk</a></h3>
				<pre>func (me <a href="#ModelLib">ModelLib</a>) Walk(on func(ref *<a href="#Model">Model</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="NgCore">type <a href="/target/ng-core.go?s=474:1001#L7">NgCore</a></h2>
			<pre>type NgCore struct {
    Libs <a href="#NgLibs">NgLibs</a>
    Mesh struct {
        Buffers <a href="#MeshBufferLib">MeshBufferLib</a>
        Desc    struct {
            Cube, Plane, Pyramid, Quad, Tri <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#MeshProvider">MeshProvider</a>
        }
    }
    Render struct {
        Canvases <a href="#RenderCanvasLib">RenderCanvasLib</a>
        Fx       struct {
            KnownProcIDs []<a href="/pkg/builtin/#string">string</a>
            Samplers     struct {
                NoFilteringClamp    <a href="/pkg/github.com/go3d/go-opengl/util/">ugl</a>.<a href="/pkg/github.com/go3d/go-opengl/util/#Sampler">Sampler</a>
                FullFilteringRepeat <a href="/pkg/github.com/go3d/go-opengl/util/">ugl</a>.<a href="/pkg/github.com/go3d/go-opengl/util/#Sampler">Sampler</a>
                FullFilteringClamp  <a href="/pkg/github.com/go3d/go-opengl/util/">ugl</a>.<a href="/pkg/github.com/go3d/go-opengl/util/#Sampler">Sampler</a>
            }
            <span class="comment">// contains filtered or unexported fields</span>
        }
        KnownTechniques map[<a href="/pkg/builtin/#string">string</a>]<a href="#renderTechniqueProvider">renderTechniqueProvider</a>
        <span class="comment">// contains filtered or unexported fields</span>
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
NgCore is a singleton type, only used for the core.Core package-global exported variable.
It is only aware of that instance and does not support any other NgCore instances.
</p>


			

			
				<pre>var (
    <span class="comment">//	The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.</span>
    <span id="Core">Core</span> <a href="#NgCore">NgCore</a>
)</pre>
				
			

			

			

			
				
				<h3 id="NgCore.GpuSyncImageLibs">func (*NgCore) <a href="/target/ng-core.go?s=2899:2946#L85">GpuSyncImageLibs</a></h3>
				<pre>func (_ *<a href="#NgCore">NgCore</a>) GpuSyncImageLibs() (err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="NgDiag">type <a href="/target/ng-diag.go?s=578:724#L15">NgDiag</a></h2>
			<pre>type NgDiag struct {
    LogCategories          <a href="#NgDiagLogCategory">NgDiagLogCategory</a>
    LogCategoryNames       map[<a href="#NgDiagLogCategory">NgDiagLogCategory</a>]<a href="/pkg/builtin/#string">string</a>
    LogGLErrorsInLoopOnSec <a href="/pkg/builtin/#bool">bool</a>
}</pre>
			<p>
NgDiag is a singleton type, only used for the core.Diag package-global exported variable.
It is only aware of that instance and does not support any other NgDiag instances.
</p>


			

			

			

			

			
				
				<h3 id="NgDiag.Log">func (*NgDiag) <a href="/target/ng-diag.go?s=726:805#L21">Log</a></h3>
				<pre>func (_ *<a href="#NgDiag">NgDiag</a>) Log(cat <a href="#NgDiagLogCategory">NgDiagLogCategory</a>, fmt <a href="/pkg/builtin/#string">string</a>, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="NgDiag.LogErr">func (*NgDiag) <a href="/target/ng-diag.go?s=911:945#L27">LogErr</a></h3>
				<pre>func (_ *<a href="#NgDiag">NgDiag</a>) LogErr(err <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
			
				
				<h3 id="NgDiag.LogIfGlErr">func (*NgDiag) <a href="/target/ng-diag.go?s=970:1033#L31">LogIfGlErr</a></h3>
				<pre>func (_ *<a href="#NgDiag">NgDiag</a>) LogIfGlErr(fmt <a href="/pkg/builtin/#string">string</a>, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="NgDiag.LogImages">func (*NgDiag) <a href="/target/ng-diag.go?s=1074:1136#L35">LogImages</a></h3>
				<pre>func (_ *<a href="#NgDiag">NgDiag</a>) LogImages(fmt <a href="/pkg/builtin/#string">string</a>, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="NgDiag.LogMeshes">func (*NgDiag) <a href="/target/ng-diag.go?s=1187:1249#L39">LogMeshes</a></h3>
				<pre>func (_ *<a href="#NgDiag">NgDiag</a>) LogMeshes(fmt <a href="/pkg/builtin/#string">string</a>, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="NgDiag.LogMisc">func (*NgDiag) <a href="/target/ng-diag.go?s=1300:1360#L43">LogMisc</a></h3>
				<pre>func (_ *<a href="#NgDiag">NgDiag</a>) LogMisc(fmt <a href="/pkg/builtin/#string">string</a>, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="NgDiag.LogShaders">func (*NgDiag) <a href="/target/ng-diag.go?s=1409:1472#L47">LogShaders</a></h3>
				<pre>func (_ *<a href="#NgDiag">NgDiag</a>) LogShaders(fmt <a href="/pkg/builtin/#string">string</a>, fmtArgs ...interface{})</pre>
				
				
				
			
		
			
			
			<h2 id="NgDiagLogCategory">type <a href="/target/ng-diag.go?s=1524:1550#L51">NgDiagLogCategory</a></h2>
			<pre>type NgDiagLogCategory <a href="/pkg/builtin/#int">int</a></pre>
			

			
				<pre>const (
    <span id="DiagLogCatMisc">DiagLogCatMisc</span>    <a href="#NgDiagLogCategory">NgDiagLogCategory</a> = 1
    <span id="DiagLogCatMeshes">DiagLogCatMeshes</span>  <a href="#NgDiagLogCategory">NgDiagLogCategory</a> = 2
    <span id="DiagLogCatShaders">DiagLogCatShaders</span> <a href="#NgDiagLogCategory">NgDiagLogCategory</a> = 4
    <span id="DiagLogCatImages">DiagLogCatImages</span>  <a href="#NgDiagLogCategory">NgDiagLogCategory</a> = 8
    <span id="DiagLogCatAll">DiagLogCatAll</span>     <a href="#NgDiagLogCategory">NgDiagLogCategory</a> = <a href="#DiagLogCatMeshes">DiagLogCatMeshes</a> | <a href="#DiagLogCatMisc">DiagLogCatMisc</a> | <a href="#DiagLogCatShaders">DiagLogCatShaders</a> | <a href="#DiagLogCatImages">DiagLogCatImages</a>
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="NgLibs">type <a href="/target/ng-libs.go?s=388:614#L10">NgLibs</a></h2>
			<pre>type NgLibs struct {
    Effects   <a href="#FxEffectLib">FxEffectLib</a>
    Materials <a href="#FxMaterialLib">FxMaterialLib</a>
    Images    struct {
        SplashScreen <a href="#FxImage2D">FxImage2D</a>
        TexCube      <a href="#FxImageCubeLib">FxImageCubeLib</a>
        Tex2D        <a href="#FxImage2DLib">FxImage2DLib</a>
    }
    Meshes <a href="#MeshLib">MeshLib</a>
    Models <a href="#ModelLib">ModelLib</a>
    Scenes <a href="#SceneLib">SceneLib</a>
}</pre>
			<p>
Only used for Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="NgLibs.UpdateIDRef">func (*NgLibs) <a href="/target/ng-libs.go?s=1127:1188#L49">UpdateIDRef</a></h3>
				<pre>func (_ *<a href="#NgLibs">NgLibs</a>) UpdateIDRef(oldNewIDs map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>, ptr *<a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="NgLibs.UpdateIDRefs">func (*NgLibs) <a href="/target/ng-libs.go?s=1251:1317#L55">UpdateIDRefs</a></h3>
				<pre>func (_ *<a href="#NgLibs">NgLibs</a>) UpdateIDRefs(oldNewIDs map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>, ptrs ...*<a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="NgLibs.UpdateIDRefsIn">func (*NgLibs) <a href="/target/ng-libs.go?s=1441:1508#L65">UpdateIDRefsIn</a></h3>
				<pre>func (_ *<a href="#NgLibs">NgLibs</a>) UpdateIDRefsIn(oldNewIDs map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>, slice []<a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="NgLibs.UpdatedIDRef">func (*NgLibs) <a href="/target/ng-libs.go?s=1636:1706#L75">UpdatedIDRef</a></h3>
				<pre>func (_ *<a href="#NgLibs">NgLibs</a>) UpdatedIDRef(oldNewIDs map[<a href="/pkg/builtin/#int">int</a>]<a href="/pkg/builtin/#int">int</a>, in <a href="/pkg/builtin/#int">int</a>) (out <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="NgLoop">type <a href="/target/ng-loop.go?s=370:1799#L8">NgLoop</a></h2>
			<pre>type NgLoop struct {
    <span class="comment">//	Set to true by Loop.Run(). Set to false to stop looping.</span>
    Running <a href="/pkg/builtin/#bool">bool</a>

    Delay <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>

    MaxIterations <a href="/pkg/builtin/#float64">float64</a>

    On struct {
        <span class="comment">//	While Loop.Run() is running, this callback is invoked (in its own &#34;app thread&#34;)</span>
        <span class="comment">//	every loop iteration (ie. once per frame).</span>
        <span class="comment">//	This callback may run in parallel with On.EverySec(), but never with On.WinThread().</span>
        AppThread func()

        <span class="comment">//	While Loop.Run() is running, this callback is invoked (on the main windowing thread)</span>
        <span class="comment">//	every loop iteration (ie. once per frame).</span>
        <span class="comment">//	This callback is guaranteed to never run in parallel with</span>
        <span class="comment">//	(and always after) the On.AppThread() and On.EverySec() callbacks.</span>
        WinThread func()

        <span class="comment">//	While Loop.Run() is running, this callback is invoked (on the main windowing thread)</span>
        <span class="comment">//	at least and at most once per second, a useful entry point for non-real-time periodically recurring code.</span>
        <span class="comment">//	Caution: unlike On.WinThread(), this callback runs in parallel with your On.AppThread() callback.</span>
        EverySec func()
    }

    Tick struct {
        <span class="comment">//	The tick-time when the Loop.On.EverySec() callback was last invoked.</span>
        PrevSec <a href="/pkg/builtin/#int">int</a>

        <span class="comment">//	While Loop.Run() is running, is set to the current &#34;tick-time&#34;:</span>
        <span class="comment">//	the time in seconds expired ever since Loop.Run() was last called.</span>
        Now <a href="/pkg/builtin/#float64">float64</a>

        <span class="comment">//	While Loop.Run() is running, is set to the previous tick-time.</span>
        Prev <a href="/pkg/builtin/#float64">float64</a>

        <span class="comment">//	The delta between Tick.Prev and Tick.Now.</span>
        Delta <a href="/pkg/builtin/#float64">float64</a>
    }
}</pre>
			<p>
NgLoop is a singleton type, only used for the Loop variable.
It is only aware of that instance and does not support any other NgLoop instances.
</p>


			

			
				<pre>var (
    <span class="comment">//	Manages your main-thread&#39;s render loop.</span>
    <span class="comment">//	Call it&#39;s Run() method once after go:ngine initialization (see examples).</span>
    <span id="Loop">Loop</span> <a href="#NgLoop">NgLoop</a>
)</pre>
				
			

			

			

			
				
				<h3 id="NgLoop.Run">func (*NgLoop) <a href="/target/ng-loop.go?s=2978:3000#L107">Run</a></h3>
				<pre>func (_ *<a href="#NgLoop">NgLoop</a>) Run()</pre>
				<p>
Initiates a rendering loop. This method returns only when the loop is stopped for whatever reason.
</p>
<p>
(Before entering the loop, this method performs a one-off GC invokation.)
</p>

				
				
			
				
				<h3 id="NgLoop.Time">func (*NgLoop) <a href="/target/ng-loop.go?s=6660:6691#L200">Time</a></h3>
				<pre>func (_ *<a href="#NgLoop">NgLoop</a>) Time() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the number of seconds expired ever since Loop.Run() was last called.
</p>

				
				
			
		
			
			
			<h2 id="NgOptions">type <a href="/target/ng-options.go?s=646:3453#L24">NgOptions</a></h2>
			<pre>type NgOptions struct {
    AppDir struct {
        <span class="comment">//	The base directory path for app file paths.</span>
        BasePath <a href="/pkg/builtin/#string">string</a>

        Temp struct {
            BaseName       <a href="/pkg/builtin/#string">string</a>
            ShaderSources  <a href="/pkg/builtin/#string">string</a>
            CachedTextures <a href="/pkg/builtin/#string">string</a>
        }
    }

    Cameras struct {
        DefaultControllerParams <a href="#ControllerParams">ControllerParams</a>
        PerspectiveDefaults     <a href="/pkg/github.com/go3d/go-3dutil/">u3d</a>.<a href="/pkg/github.com/go3d/go-3dutil/#Perspective">Perspective</a>
    }

    Initialization struct {
        GlContext struct {
            CoreProfile struct {
                <span class="comment">//	Required on Mac OS X, not necessary elsewhere.</span>
                <span class="comment">//	While potentially slightly beneficial with recent GL drivers,</span>
                <span class="comment">//	might also fail with a select few rather outdated ones.</span>
                <span class="comment">//	Defaults to true on Mac OS X, to false elsewhere.</span>
                ForceFirst <a href="/pkg/builtin/#bool">bool</a>

                <span class="comment">//	While required on Mac OS X, really not recommended elsewhere</span>
                <span class="comment">//	(at present). Defaults to true on Mac OS X, to false elsewhere.</span>
                <span class="comment">//	Only used if go:ngine requests the creation of a GL core-profile context.</span>
                ForwardCompat <a href="/pkg/builtin/#bool">bool</a>

                <span class="comment">//	Defaults to the newest GL version currently supported by the GL</span>
                <span class="comment">//	binding used by go:ngine. The binding adaptively uses features</span>
                <span class="comment">//	of GL versions newer than 3.3 only if they are available, so this</span>
                <span class="comment">//	is a most strongly recommended default for release apps. But for</span>
                <span class="comment">//	testing, this is useful to test performance in older GL versions.</span>
                <span class="comment">//	Must be one of the values in glutil.KnownVersions.</span>
                VersionHint <a href="/pkg/builtin/#float64">float64</a>
            }

            <span class="comment">//	Defaults to the DefaultBadVersionMessage constant. If using a custom</span>
            <span class="comment">//	string, you can use the same placeholders as that one.</span>
            BadVersionMessage <a href="/pkg/builtin/#string">string</a>
        }
        DefaultCanvas struct {
            GammaViaShader <a href="/pkg/builtin/#bool">bool</a>
            SplashImage    []<a href="/pkg/builtin/#byte">byte</a>
        }
        Window struct {
            <span class="comment">//	Defaults: R=8 G=8 B=8 A=0 D=8 S=0.</span>
            <span class="comment">//	These defaults are reasonable when using a render-to-texture off-screen</span>
            <span class="comment">//	RenderCanvas. Otherwise, may want to bump D to at least 24 or 32.</span>
            <span class="comment">//	D shouldn&#39;t be 0 as this causes some Intel HD drivers to bug out badly.</span>
            Rbits, Gbits, Bbits, Abits, DepthBits, StencilBits <a href="/pkg/builtin/#int">int</a>
        }
    }

    Libs struct {
        InitialCap   <a href="/pkg/builtin/#int">int</a>
        GrowCapBy    <a href="/pkg/builtin/#int">int</a>
        OnIDsChanged struct {
            Effects <a href="#LibElemIDChangedHandlers">LibElemIDChangedHandlers</a>
            Images  struct {
                TexCube <a href="#LibElemIDChangedHandlers">LibElemIDChangedHandlers</a>
                Tex2D   <a href="#LibElemIDChangedHandlers">LibElemIDChangedHandlers</a>
            }
            Materials <a href="#LibElemIDChangedHandlers">LibElemIDChangedHandlers</a>
            Meshes    <a href="#LibElemIDChangedHandlers">LibElemIDChangedHandlers</a>
            Models    <a href="#LibElemIDChangedHandlers">LibElemIDChangedHandlers</a>
            Scenes    <a href="#LibElemIDChangedHandlers">LibElemIDChangedHandlers</a>
        }
    }

    Loop struct {
        <span class="comment">//	Controls whether and how often the Garbage Collector</span>
        <span class="comment">//	is invoked during the Loop.</span>
        GcEvery struct {
            <span class="comment">//	Defaults to false. If true, GC will</span>
            <span class="comment">//	be invoked every frame during the Loop.</span>
            Frame <a href="/pkg/builtin/#bool">bool</a>

            <span class="comment">//	Defaults to true. If true, GC will be invoked at</span>
            <span class="comment">//	least and at most once per second during the Loop.</span>
            Sec <a href="/pkg/builtin/#bool">bool</a>
        }
    }

    Rendering struct {
        DefaultBatcher    <a href="#RenderBatcher">RenderBatcher</a>
        DefaultClearColor <a href="/pkg/github.com/go3d/go-opengl/util/">ugl</a>.<a href="/pkg/github.com/go3d/go-opengl/util/#GlVec4">GlVec4</a>
    }

    Textures struct {
        Storage <a href="#FxImageStorage">FxImageStorage</a>
    }
}</pre>
			<p>
Only used for the Options variable.
</p>


			

			
				<pre>var (
    <span id="Options">Options</span> <a href="#NgOptions">NgOptions</a>
)</pre>
				
			

			

			

			
		
			
			
			<h2 id="NgStats">type <a href="/target/ng-stats.go?s=291:3929#L4">NgStats</a></h2>
			<pre>type NgStats struct {
    <span class="comment">//	Gives the total number of frames rendered during the &#34;previous&#34;</span>
    <span class="comment">//	(not the current) second. Good enough for just a simple-minded FPS indicator.</span>
    FpsLastSec <a href="/pkg/builtin/#int">int</a>

    <span class="comment">//	This TimingStats instance combines all the individual FrameFoo fields</span>
    <span class="comment">//	to track over time (both average and maximum) total cost per frame.</span>
    Frame <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	&#34;Rendering&#34; consists of a CPU-side and a GPU-side cost.</span>
    <span class="comment">//	This TimingStats instance combines both to track over time</span>
    <span class="comment">//	(both average and maximum) total rendering cost per frame.</span>
    FrameRenderBoth <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	The CPU-side cost of rendering comprises sending pre-batched</span>
    <span class="comment">//	rendering commands (prepared by the &#34;prep&#34; stage) to the GPU.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average</span>
    <span class="comment">//	and maximum) CPU-side rendering cost per frame.</span>
    FrameRenderCpu <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	The GPU-side cost of rendering comprises execution of all draw calls</span>
    <span class="comment">//	sent by the CPU-side, plus waiting for V-sync if enabled.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average</span>
    <span class="comment">//	and maximum) GPU-side rendering cost per frame.</span>
    FrameRenderGpu <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	&#34;Prep code&#34; comprises all go:ngine logic executed every frame in parallel to cull</span>
    <span class="comment">//	geometry and prepare a batch of rendering commands for the next (not current) frame.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;prep code&#34; cost per frame.</span>
    FramePrepThread <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	&#34;App code&#34; comprises (mostly user-specific) logic executed every frame in parallel in</span>
    <span class="comment">//	your Loop.OnAppThread() callback. Such code may freely modify dynamic Cameras, Nodes etc.</span>
    <span class="comment">//	Unlike OnWinThread() code, &#34;app code&#34; always runs in its own thread in parallel to the prep and main threads.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;app code&#34; cost per frame.</span>
    FrameAppThread <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	Tracks over the time (both average and maximum) cost for Loop.On.EverySec() and,</span>
    <span class="comment">//	if Diag.LogGLErrorsInLoopOnSec is true, Diag.LogIfGlErr().</span>
    FrameOnSec <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	&#34;Windowing/GPU/IO code&#34; comprises user-specific logic executed every frame via your own</span>
    <span class="comment">//	Loop.OnWinThread() callback. This should be kept to a minimum to fully enjoy</span>
    <span class="comment">//	the benefits of multi-threading. Main use-cases are calls resulting in GPU state</span>
    <span class="comment">//	changes (such as toggling effects in Core.Render.PostFx) and working with UserIO</span>
    <span class="comment">//	to poll for user input -- but do consider executing resulting logic in your OnAppThread().</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;input code&#34; cost per frame.</span>
    FrameWinThread <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	When CPU-side rendering is completed, Loop waits for the app thread and prep thread</span>
    <span class="comment">//	to finish (either before or after GPU-side rendering depending on Loop.SwapLast).</span>
    <span class="comment">//	It then moves &#34;prep results&#34; to the render thread and &#34;app results&#34; to the prep thread.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;thread sync&#34; cost per frame.</span>
    FrameThreadSync <a href="#TimingStats">TimingStats</a>

    <span class="comment">//	During the Loop, the Go Garbge Collector is invoked at least and at most once per second.</span>
    <span class="comment">//</span>
    <span class="comment">//	Forcing GC &#34;that often&#34; practically guarantees it will almost never have so much work to do as to</span>
    <span class="comment">//	noticably block user interaction --- typically well below 10ms, most often around 1ms.</span>
    <span class="comment">//</span>
    <span class="comment">//	This TimingStats instance over time tracks the maximum and average time spent on that</span>
    <span class="comment">//	1x-per-second-during-Loop GC invokation (but does not track any other GC invokations).</span>
    Gc <a href="#TimingStats">TimingStats</a>

    Programs struct {
        NumProgsCompiled <a href="/pkg/builtin/#int">int</a>
        TotalTimeCost    <a href="/pkg/builtin/#int64">int64</a>
        <span class="comment">// contains filtered or unexported fields</span>
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider NgStats a &#34;Singleton&#34; type, only valid use is the core.Stats global variable.
Tracks various go:ngine performance indicators over time.
</p>


			

			
				<pre>var (
    <span class="comment">//	Tracks various go:ngine performance counters over time.</span>
    <span id="Stats">Stats</span> <a href="#NgStats">NgStats</a>
)</pre>
				
			

			

			

			
				
				<h3 id="NgStats.AverageFps">func (*NgStats) <a href="/target/ng-stats.go?s=4172:4210#L86">AverageFps</a></h3>
				<pre>func (_ *<a href="#NgStats">NgStats</a>) AverageFps() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the average number of frames-per-second since Loop.Loop() was last called.
</p>

				
				
			
				
				<h3 id="NgStats.TotalFrames">func (*NgStats) <a href="/target/ng-stats.go?s=4738:4777#L110">TotalFrames</a></h3>
				<pre>func (_ *<a href="#NgStats">NgStats</a>) TotalFrames() <a href="/pkg/builtin/#float64">float64</a></pre>
				
				
				
			
		
			
			
			<h2 id="NgUserIO">type <a href="/target/ng-userio.go?s=480:737#L6">NgUserIO</a></h2>
			<pre>type NgUserIO struct {
    <span class="comment">//	Minimum delay for NgUserIO.KeyToggled() method, in seconds. Defaults to 0.15.</span>
    KeyToggleMinDelay <a href="/pkg/builtin/#float64">float64</a>

    Window <a href="#WindowOptions">WindowOptions</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider NgUserIO a &#34;Singleton&#34; type, only valid use is the core.UserIO global variable.
Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).
</p>


			

			
				<pre>var (
    <span class="comment">//	Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).</span>
    <span id="UserIO">UserIO</span> <a href="#NgUserIO">NgUserIO</a>
)</pre>
				
			

			

			

			
				
				<h3 id="NgUserIO.IifKeyF">func (*NgUserIO) <a href="/target/ng-userio.go?s=2680:2748#L71">IifKeyF</a></h3>
				<pre>func (_ *<a href="#NgUserIO">NgUserIO</a>) IifKeyF(key <a href="/pkg/builtin/#int">int</a>, ifTrue, ifFalse <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns ifTrue if the specified key is pressed, otherwise returns ifFalse.
</p>

				
				
			
				
				<h3 id="NgUserIO.KeyPressed">func (*NgUserIO) <a href="/target/ng-userio.go?s=2867:2910#L79">KeyPressed</a></h3>
				<pre>func (_ *<a href="#NgUserIO">NgUserIO</a>) KeyPressed(key <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if the specified key is pressed.
</p>

				
				
			
				
				<h3 id="NgUserIO.KeyPressedWhich">func (*NgUserIO) <a href="/target/ng-userio.go?s=3001:3052#L84">KeyPressedWhich</a></h3>
				<pre>func (_ *<a href="#NgUserIO">NgUserIO</a>) KeyPressedWhich(keys ...<a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Returns the first in keys that is pressed.
</p>

				
				
			
				
				<h3 id="NgUserIO.KeyToggled">func (*NgUserIO) <a href="/target/ng-userio.go?s=4054:4097#L114">KeyToggled</a></h3>
				<pre>func (_ *<a href="#NgUserIO">NgUserIO</a>) KeyToggled(key <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if the specified key has been &#34;toggled&#34;, ie. its pressed-state changed within the last me.KeyToggleMinDelay seconds.
</p>

				
				
			
				
				<h3 id="NgUserIO.KeysPressedAll2">func (*NgUserIO) <a href="/target/ng-userio.go?s=3234:3285#L94">KeysPressedAll2</a></h3>
				<pre>func (_ *<a href="#NgUserIO">NgUserIO</a>) KeysPressedAll2(k1, k2 <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if both specified keys are pressed.
</p>

				
				
			
				
				<h3 id="NgUserIO.KeysPressedAll3">func (*NgUserIO) <a href="/target/ng-userio.go?s=3403:3458#L99">KeysPressedAll3</a></h3>
				<pre>func (_ *<a href="#NgUserIO">NgUserIO</a>) KeysPressedAll3(k1, k2, k3 <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if all three specified keys are pressed.
</p>

				
				
			
				
				<h3 id="NgUserIO.KeysPressedAny2">func (*NgUserIO) <a href="/target/ng-userio.go?s=3605:3656#L104">KeysPressedAny2</a></h3>
				<pre>func (_ *<a href="#NgUserIO">NgUserIO</a>) KeysPressedAny2(k1, k2 <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if any of the two specified keys is pressed.
</p>

				
				
			
				
				<h3 id="NgUserIO.KeysPressedAny3">func (*NgUserIO) <a href="/target/ng-userio.go?s=3780:3835#L109">KeysPressedAny3</a></h3>
				<pre>func (_ *<a href="#NgUserIO">NgUserIO</a>) KeysPressedAny3(k1, k2, k3 <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>
Returns true if any of the three specified keys is pressed.
</p>

				
				
			
		
			
			
			<h2 id="RenderBatchCriteria">type <a href="/target/render-batcher.go?s=178:206#L3">RenderBatchCriteria</a></h2>
			<pre>type RenderBatchCriteria <a href="/pkg/builtin/#int">int</a></pre>
			

			
				<pre>const (
    <span id="BatchByProgram">BatchByProgram</span> <a href="#RenderBatchCriteria">RenderBatchCriteria</a> = 0
    <span id="BatchByTexture">BatchByTexture</span> <a href="#RenderBatchCriteria">RenderBatchCriteria</a> = 1
    <span id="BatchByBuffer">BatchByBuffer</span>  <a href="#RenderBatchCriteria">RenderBatchCriteria</a> = 2
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="RenderBatcher">type <a href="/target/render-batcher.go?s=3349:3433#L124">RenderBatcher</a></h2>
			<pre>type RenderBatcher struct {
    Enabled  <a href="/pkg/builtin/#bool">bool</a>
    Priority [<a href="#numPrios">numPrios</a>]<a href="#RenderBatchCriteria">RenderBatchCriteria</a>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderCanvas">type <a href="/target/render-canvas.gt.go?s=181:726#L1">RenderCanvas</a></h2>
			<pre>type RenderCanvas struct {
    <span class="comment">//	This should be an non-negative integer, it&#39;s a float64 just to avoid a</span>
    <span class="comment">//	type conversion. How often this RenderCanvas is included in rendering:</span>
    <span class="comment">//	1 = every frame (this is the default value)</span>
    <span class="comment">//	2 = every 2nd frame</span>
    <span class="comment">//	3, 5, 8 etc. = every 3rd, 5th, 8th etc. frame</span>
    <span class="comment">//	0 = this RenderCanvas is disabled for rendering</span>
    EveryNthFrame <a href="/pkg/builtin/#float64">float64</a>

    Views <a href="#RenderViewLib">RenderViewLib</a>

    Srgb <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents a surface (texture framebuffer) that can be rendered to.
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvas.AddNewView">func (*RenderCanvas) <a href="/target/render-canvas.gt.go?s=984:1061#L31">AddNewView</a></h3>
				<pre>func (me *<a href="#RenderCanvas">RenderCanvas</a>) AddNewView(renderTechnique <a href="/pkg/builtin/#string">string</a>) (view *<a href="#RenderView">RenderView</a>)</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.CurrentAbsoluteSize">func (*RenderCanvas) <a href="/target/render-canvas.gt.go?s=844:909#L26">CurrentAbsoluteSize</a></h3>
				<pre>func (me *<a href="#RenderCanvas">RenderCanvas</a>) CurrentAbsoluteSize() (width, height <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.SetSize">func (*RenderCanvas) <a href="/target/render-canvas.gt.go?s=2289:2358#L70">SetSize</a></h3>
				<pre>func (me *<a href="#RenderCanvas">RenderCanvas</a>) SetSize(relative <a href="/pkg/builtin/#bool">bool</a>, width, height <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets the 2 dimensions of this render canvas.
If relative is true, width and height are interpreted relative to the resolution of the OpenGL context&#39;s default framebuffer, with 1 being 100%.
Otherwise, width and height are absolute pixel dimensions.
</p>

				
				
			
		
			
			
			<h2 id="RenderCanvasLib">type <a href="/target/render-canvas.gt.go?s=3255:3291#L98">RenderCanvasLib</a></h2>
			<pre>type RenderCanvasLib []*<a href="#RenderCanvas">RenderCanvas</a></pre>
			<p>
Only used for Core.Render.Canvases
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvasLib.AddNew">func (*RenderCanvasLib) <a href="/target/render-canvas.gt.go?s=2595:2687#L79">AddNew</a></h3>
				<pre>func (me *<a href="#RenderCanvasLib">RenderCanvasLib</a>) AddNew(relative <a href="/pkg/builtin/#bool">bool</a>, width, height <a href="/pkg/builtin/#float64">float64</a>) (canv *<a href="#RenderCanvas">RenderCanvas</a>)</pre>
				
				
				
			
				
				<h3 id="RenderCanvasLib.IsOk">func (RenderCanvasLib) <a href="/target/render-canvas.gt.go?s=3525:3568#L114">IsOk</a></h3>
				<pre>func (me <a href="#RenderCanvasLib">RenderCanvasLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="RenderCanvasLib.Remove">func (*RenderCanvasLib) <a href="/target/render-canvas.gt.go?s=3606:3656#L118">Remove</a></h3>
				<pre>func (me *<a href="#RenderCanvasLib">RenderCanvasLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="RenderCanvasLib.Walk">func (RenderCanvasLib) <a href="/target/render-canvas.gt.go?s=3930:3988#L131">Walk</a></h3>
				<pre>func (me <a href="#RenderCanvasLib">RenderCanvasLib</a>) Walk(on func(ref *<a href="#RenderCanvas">RenderCanvas</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="RenderTechnique">type <a href="/target/render-technique-base.go?s=83:198#L1">RenderTechnique</a></h2>
			<pre>type RenderTechnique interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderTechniqueQuad">type <a href="/target/render-technique-quad.go?s=64:162#L1">RenderTechniqueQuad</a></h2>
			<pre>type RenderTechniqueQuad struct {
    Effect <a href="#FxEffect">FxEffect</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderTechniqueScene">type <a href="/target/render-technique-scene.go?s=110:331#L1">RenderTechniqueScene</a></h2>
			<pre>type RenderTechniqueScene struct {
    Batch  <a href="#RenderBatcher">RenderBatcher</a>
    Camera <a href="#Camera">Camera</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="RenderTechniqueScene.ApplyCameraPerspective">func (*RenderTechniqueScene) <a href="/target/render-technique-scene.go?s=696:752#L27">ApplyCameraPerspective</a></h3>
				<pre>func (me *<a href="#RenderTechniqueScene">RenderTechniqueScene</a>) ApplyCameraPerspective()</pre>
				<p>
Applies changes made to the Enabled, FovY, ZNear and/or ZFar parameters in me.Camera.Perspective.
</p>

				
				
			
				
				<h3 id="RenderTechniqueScene.NumDrawCalls">func (*RenderTechniqueScene) <a href="/target/render-technique-scene.go?s=841:891#L32">NumDrawCalls</a></h3>
				<pre>func (me *<a href="#RenderTechniqueScene">RenderTechniqueScene</a>) NumDrawCalls() <a href="/pkg/builtin/#int">int</a></pre>
				
				
				
			
				
				<h3 id="RenderTechniqueScene.ToggleBatching">func (*RenderTechniqueScene) <a href="/target/render-technique-scene.go?s=921:969#L36">ToggleBatching</a></h3>
				<pre>func (me *<a href="#RenderTechniqueScene">RenderTechniqueScene</a>) ToggleBatching()</pre>
				
				
				
			
		
			
			
			<h2 id="RenderView">type <a href="/target/render-view.gt.go?s=101:305#L1">RenderView</a></h2>
			<pre>type RenderView struct {
    Enabled <a href="/pkg/builtin/#bool">bool</a>

    FxProcs <a href="#FxProcs">FxProcs</a>

    <span class="comment">//	The device-relative or absolute view-port for this view.</span>
    Port <a href="#RenderViewport">RenderViewport</a>

    RenderStates <a href="/pkg/github.com/go3d/go-opengl/util/">ugl</a>.<a href="/pkg/github.com/go3d/go-opengl/util/#RenderStatesBag">RenderStatesBag</a>

    Technique <a href="#RenderTechnique">RenderTechnique</a>
}</pre>
			

			

			

			

			

			
				
				<h3 id="RenderView.Technique_Quad">func (*RenderView) <a href="/target/render-view.gt.go?s=982:1048#L32">Technique_Quad</a></h3>
				<pre>func (me *<a href="#RenderView">RenderView</a>) Technique_Quad() (tech *<a href="#RenderTechniqueQuad">RenderTechniqueQuad</a>)</pre>
				
				
				
			
				
				<h3 id="RenderView.Technique_Scene">func (*RenderView) <a href="/target/render-view.gt.go?s=1109:1177#L37">Technique_Scene</a></h3>
				<pre>func (me *<a href="#RenderView">RenderView</a>) Technique_Scene() (tech *<a href="#RenderTechniqueScene">RenderTechniqueScene</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="RenderViewLib">type <a href="/target/render-view.gt.go?s=2769:2801#L83">RenderViewLib</a></h2>
			<pre>type RenderViewLib []*<a href="#RenderView">RenderView</a></pre>
			<p>
Only used for Core.Render.Canvases[id].Views
</p>


			

			

			

			

			
				
				<h3 id="RenderViewLib.IsOk">func (RenderViewLib) <a href="/target/render-view.gt.go?s=3025:3066#L99">IsOk</a></h3>
				<pre>func (me <a href="#RenderViewLib">RenderViewLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="RenderViewLib.Remove">func (*RenderViewLib) <a href="/target/render-view.gt.go?s=3104:3152#L103">Remove</a></h3>
				<pre>func (me *<a href="#RenderViewLib">RenderViewLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="RenderViewLib.Walk">func (RenderViewLib) <a href="/target/render-view.gt.go?s=3426:3480#L116">Walk</a></h3>
				<pre>func (me <a href="#RenderViewLib">RenderViewLib</a>) Walk(on func(ref *<a href="#RenderView">RenderView</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="RenderViewport">type <a href="/target/render-view.gt.go?s=1272:1526#L43">RenderViewport</a></h2>
			<pre>type RenderViewport struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Only used for RenderView.Port
</p>


			

			

			

			

			
				
				<h3 id="RenderViewport.SetAbsolute">func (*RenderViewport) <a href="/target/render-view.gt.go?s=1657:1719#L58">SetAbsolute</a></h3>
				<pre>func (me *<a href="#RenderViewport">RenderViewport</a>) SetAbsolute(x, y, width, height <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Sets the absolute viewport origin and dimensions in pixels.
</p>

				
				
			
				
				<h3 id="RenderViewport.SetRelative">func (*RenderViewport) <a href="/target/render-view.gt.go?s=1977:2043#L65">SetRelative</a></h3>
				<pre>func (me *<a href="#RenderViewport">RenderViewport</a>) SetRelative(x, y, width, height <a href="/pkg/builtin/#float64">float64</a>)</pre>
				<p>
Sets the RenderCanvas-relative viewport origin and dimensions, with the value 1.0
representing the maximum extent of the viewport on that respective axis.
</p>

				
				
			
		
			
			
			<h2 id="Scene">type <a href="/target/scene.gt.go?s=126:277#L1">Scene</a></h2>
			<pre>type Scene struct {
    ID <a href="/pkg/builtin/#int">int</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents a scene graph.
</p>


			

			

			

			

			
				
				<h3 id="Scene.AddNewChildNode">func (*Scene) <a href="/target/scene.gt.go?s=597:673#L27">AddNewChildNode</a></h3>
				<pre>func (me *<a href="#Scene">Scene</a>) AddNewChildNode(parentNodeID, meshID <a href="/pkg/builtin/#int">int</a>) (childNodeID <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="Scene.ApplyNodeTransforms">func (*Scene) <a href="/target/scene-node-transform.go?s=2018:2066#L65">ApplyNodeTransforms</a></h3>
				<pre>func (me *<a href="#Scene">Scene</a>) ApplyNodeTransforms(nodeID <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>
Updates the internal 4x4 transformation matrix for all transformations of the specified
node and child-nodes. It is only this matrix that is used by the rendering runtime.
</p>

				
				
			
				
				<h3 id="Scene.Node">func (*Scene) <a href="/target/scene.gt.go?s=1740:1780#L57">Node</a></h3>
				<pre>func (me *<a href="#Scene">Scene</a>) Node(id <a href="/pkg/builtin/#int">int</a>) *<a href="#SceneNode">SceneNode</a></pre>
				
				
				
			
				
				<h3 id="Scene.NumNodes">func (*Scene) <a href="/target/scene.gt.go?s=1814:1845#L61">NumNodes</a></h3>
				<pre>func (me *<a href="#Scene">Scene</a>) NumNodes() <a href="/pkg/builtin/#int">int</a></pre>
				
				
				
			
				
				<h3 id="Scene.ParentNodeID">func (*Scene) <a href="/target/scene.gt.go?s=1872:1933#L65">ParentNodeID</a></h3>
				<pre>func (me *<a href="#Scene">Scene</a>) ParentNodeID(childNodeID <a href="/pkg/builtin/#int">int</a>) (parentID <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="Scene.RemoveNode">func (*Scene) <a href="/target/scene.gt.go?s=2033:2072#L72">RemoveNode</a></h3>
				<pre>func (me *<a href="#Scene">Scene</a>) RemoveNode(fromID <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="Scene.Root">func (*Scene) <a href="/target/scene.gt.go?s=2282:2316#L84">Root</a></h3>
				<pre>func (me *<a href="#Scene">Scene</a>) Root() *<a href="#SceneNode">SceneNode</a></pre>
				
				
				
			
				
				<h3 id="Scene.SetNodeMeshID">func (*Scene) <a href="/target/scene.gt.go?s=2346:2396#L88">SetNodeMeshID</a></h3>
				<pre>func (me *<a href="#Scene">Scene</a>) SetNodeMeshID(nodeID, meshID <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
		
			
			
			<h2 id="SceneLib">type <a href="/target/scene.gt.go?s=2600:2621#L98">SceneLib</a></h2>
			<pre>type SceneLib []<a href="#Scene">Scene</a></pre>
			<p>
Only used for Core.Libs.Scenes
</p>


			

			

			

			

			
				
				<h3 id="SceneLib.AddNew">func (*SceneLib) <a href="/target/scene.gt.go?s=2623:2660#L100">AddNew</a></h3>
				<pre>func (me *<a href="#SceneLib">SceneLib</a>) AddNew() (id <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="SceneLib.Compact">func (*SceneLib) <a href="/target/scene.gt.go?s=2983:3012#L122">Compact</a></h3>
				<pre>func (me *<a href="#SceneLib">SceneLib</a>) Compact()</pre>
				
				
				
			
				
				<h3 id="SceneLib.IsOk">func (SceneLib) <a href="/target/scene.gt.go?s=3767:3808#L165">IsOk</a></h3>
				<pre>func (me <a href="#SceneLib">SceneLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="SceneLib.Ok">func (SceneLib) <a href="/target/scene.gt.go?s=3878:3912#L172">Ok</a></h3>
				<pre>func (me <a href="#SceneLib">SceneLib</a>) Ok(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="SceneLib.Remove">func (SceneLib) <a href="/target/scene.gt.go?s=3942:3984#L176">Remove</a></h3>
				<pre>func (me <a href="#SceneLib">SceneLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="SceneLib.Walk">func (SceneLib) <a href="/target/scene.gt.go?s=4269:4313#L190">Walk</a></h3>
				<pre>func (me <a href="#SceneLib">SceneLib</a>) Walk(on func(ref *<a href="#Scene">Scene</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="SceneNode">type <a href="/target/scene-node.go?s=14:339#L1">SceneNode</a></h2>
			<pre>type SceneNode struct {
    ID        <a href="/pkg/builtin/#int">int</a>
    Transform <a href="#SceneNodeTransform">SceneNodeTransform</a>

    Render struct {
        Cull struct {
            Frustum <a href="/pkg/builtin/#bool">bool</a>
        }
        Enabled <a href="/pkg/builtin/#bool">bool</a>
        MatID   <a href="/pkg/builtin/#int">int</a>
        ModelID <a href="/pkg/builtin/#int">int</a>
        <span class="comment">// contains filtered or unexported fields</span>
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="SceneNodeLib">type <a href="/target/scene-nodes.gt.go?s=148:177#L1">SceneNodeLib</a></h2>
			<pre>type SceneNodeLib []<a href="#SceneNode">SceneNode</a></pre>
			<p>
Only used for Core.Scenes[id].allNodes
</p>


			

			

			

			

			
				
				<h3 id="SceneNodeLib.AddNew">func (*SceneNodeLib) <a href="/target/scene-nodes.gt.go?s=179:220#L1">AddNew</a></h3>
				<pre>func (me *<a href="#SceneNodeLib">SceneNodeLib</a>) AddNew() (id <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeLib.Compact">func (*SceneNodeLib) <a href="/target/scene-nodes.gt.go?s=551:584#L22">Compact</a></h3>
				<pre>func (me *<a href="#SceneNodeLib">SceneNodeLib</a>) Compact()</pre>
				
				
				
			
				
				<h3 id="SceneNodeLib.IsOk">func (SceneNodeLib) <a href="/target/scene-nodes.gt.go?s=1371:1416#L65">IsOk</a></h3>
				<pre>func (me <a href="#SceneNodeLib">SceneNodeLib</a>) IsOk(id <a href="/pkg/builtin/#int">int</a>) (ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeLib.Ok">func (SceneNodeLib) <a href="/target/scene-nodes.gt.go?s=1486:1524#L72">Ok</a></h3>
				<pre>func (me <a href="#SceneNodeLib">SceneNodeLib</a>) Ok(id <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="SceneNodeLib.Remove">func (SceneNodeLib) <a href="/target/scene-nodes.gt.go?s=1554:1600#L76">Remove</a></h3>
				<pre>func (me <a href="#SceneNodeLib">SceneNodeLib</a>) Remove(fromID, num <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeLib.Walk">func (SceneNodeLib) <a href="/target/scene-nodes.gt.go?s=1889:1941#L90">Walk</a></h3>
				<pre>func (me <a href="#SceneNodeLib">SceneNodeLib</a>) Walk(on func(ref *<a href="#SceneNode">SceneNode</a>))</pre>
				
				
				
			
		
			
			
			<h2 id="SceneNodeTransform">type <a href="/target/scene-node-transform.go?s=571:914#L9">SceneNodeTransform</a></h2>
			<pre>type SceneNodeTransform struct {
    <span class="comment">//	Translation of the from origin.</span>
    Pos <a href="/pkg/github.com/metaleap/go-util/num/">unum</a>.<a href="/pkg/github.com/metaleap/go-util/num/#Vec3">Vec3</a>

    <span class="comment">//	Rotation for each axis in radians.</span>
    Rot <a href="/pkg/github.com/metaleap/go-util/num/">unum</a>.<a href="/pkg/github.com/metaleap/go-util/num/#Vec3">Vec3</a>

    <span class="comment">//	Scaling of this node, if any. Defaults to (1, 1, 1) for no scaling.</span>
    Scale <a href="/pkg/github.com/metaleap/go-util/num/">unum</a>.<a href="/pkg/github.com/metaleap/go-util/num/#Vec3">Vec3</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents one or more transformations of a Node.
This is only used by Node objects, which initialize their SceneNodeTransform with the
proper defaults and associate themselves with their SceneNodeTransform. (Any other
SceneNodeTransform are invalid.)
</p>
<p>
A single SceneNodeTransform encapsulates an unexported 4x4 matrix that is recalculated
whenever its parent Node.ApplyTransform() method is called.
</p>


			

			

			

			

			
				
				<h3 id="SceneNodeTransform.AddRot">func (*SceneNodeTransform) <a href="/target/scene-node-transform.go?s=1039:1091#L34">AddRot</a></h3>
				<pre>func (me *<a href="#SceneNodeTransform">SceneNodeTransform</a>) AddRot(rot *<a href="/pkg/github.com/metaleap/go-util/num/">unum</a>.<a href="/pkg/github.com/metaleap/go-util/num/#Vec3">Vec3</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeTransform.AddRotXYZ">func (*SceneNodeTransform) <a href="/target/scene-node-transform.go?s=1114:1170#L38">AddRotXYZ</a></h3>
				<pre>func (me *<a href="#SceneNodeTransform">SceneNodeTransform</a>) AddRotXYZ(x, y, z <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeTransform.SetPos">func (*SceneNodeTransform) <a href="/target/scene-node-transform.go?s=1198:1260#L42">SetPos</a></h3>
				<pre>func (me *<a href="#SceneNodeTransform">SceneNodeTransform</a>) SetPos(posX, posY, posZ <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeTransform.SetRot">func (*SceneNodeTransform) <a href="/target/scene-node-transform.go?s=1315:1377#L46">SetRot</a></h3>
				<pre>func (me *<a href="#SceneNodeTransform">SceneNodeTransform</a>) SetRot(radX, radY, radZ <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeTransform.SetScale">func (*SceneNodeTransform) <a href="/target/scene-node-transform.go?s=1432:1481#L50">SetScale</a></h3>
				<pre>func (me *<a href="#SceneNodeTransform">SceneNodeTransform</a>) SetScale(s <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeTransform.SetScaleXyz">func (*SceneNodeTransform) <a href="/target/scene-node-transform.go?s=1533:1591#L54">SetScaleXyz</a></h3>
				<pre>func (me *<a href="#SceneNodeTransform">SceneNodeTransform</a>) SetScaleXyz(x, y, z <a href="/pkg/builtin/#float64">float64</a>)</pre>
				
				
				
			
				
				<h3 id="SceneNodeTransform.StepDelta">func (*SceneNodeTransform) <a href="/target/scene-node-transform.go?s=1722:1793#L59">StepDelta</a></h3>
				<pre>func (me *<a href="#SceneNodeTransform">SceneNodeTransform</a>) StepDelta(deltaPerSecond <a href="/pkg/builtin/#float64">float64</a>) <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the result of multiplying deltaPerSecond with EngineLoop.TickDelta.
</p>

				
				
			
		
			
			
			<h2 id="TimingStats">type <a href="/target/ng-stats.go?s=4885:4982#L115">TimingStats</a></h2>
			<pre>type TimingStats struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Helps track average and maximum cost for a variety of performance indicators.
</p>


			

			

			

			

			
				
				<h3 id="TimingStats.Average">func (*TimingStats) <a href="/target/ng-stats.go?s=5051:5091#L120">Average</a></h3>
				<pre>func (me *<a href="#TimingStats">TimingStats</a>) Average() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the average cost tracked by this performance indicator.
</p>

				
				
			
				
				<h3 id="TimingStats.Max">func (*TimingStats) <a href="/target/ng-stats.go?s=5744:5780#L149">Max</a></h3>
				<pre>func (me *<a href="#TimingStats">TimingStats</a>) Max() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>
Returns the maximum cost tracked by this performance indicator.
</p>

				
				
			
		
			
			
			<h2 id="WindowOptions">type <a href="/target/ng-window.go?s=56:521#L1">WindowOptions</a></h2>
			<pre>type WindowOptions struct {
    <span class="comment">//	Defaults to a function that returns true to allow closing the window.</span>
    OnCloseRequested func() <a href="/pkg/builtin/#bool">bool</a>

    <span class="comment">//	Minimum delay, in seconds, to wait after the last window-resize event received from</span>
    <span class="comment">//	the OS before notifying the rendering runtime of the new window dimensions.</span>
    <span class="comment">//	Defaults to 0.15.</span>
    ResizeMinDelay <a href="/pkg/builtin/#float64">float64</a>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="WindowOptions.Created">func (*WindowOptions) <a href="/target/ng-window.go?s=523:562#L12">Created</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) Created() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="WindowOptions.Fullscreen">func (*WindowOptions) <a href="/target/ng-window.go?s=610:652#L16">Fullscreen</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) Fullscreen() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
			
				
				<h3 id="WindowOptions.Height">func (*WindowOptions) <a href="/target/ng-window.go?s=727:764#L21">Height</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) Height() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Returns the height of the window in pixels.
</p>

				
				
			
				
				<h3 id="WindowOptions.SetSize">func (*WindowOptions) <a href="/target/ng-window.go?s=788:839#L25">SetSize</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) SetSize(width, height <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="WindowOptions.SetSwapInterval">func (*WindowOptions) <a href="/target/ng-window.go?s=940:993#L31">SetSwapInterval</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) SetSwapInterval(newSwap <a href="/pkg/builtin/#int">int</a>)</pre>
				
				
				
			
				
				<h3 id="WindowOptions.SetTitle">func (*WindowOptions) <a href="/target/ng-window.go?s=1110:1160#L39">SetTitle</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) SetTitle(newTitle <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>
Sets the window title to newTitle.
</p>

				
				
			
				
				<h3 id="WindowOptions.SwapInterval">func (*WindowOptions) <a href="/target/ng-window.go?s=1241:1284#L46">SwapInterval</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) SwapInterval() <a href="/pkg/builtin/#int">int</a></pre>
				
				
				
			
				
				<h3 id="WindowOptions.Title">func (*WindowOptions) <a href="/target/ng-window.go?s=1306:1345#L50">Title</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) Title() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
			
				
				<h3 id="WindowOptions.Width">func (*WindowOptions) <a href="/target/ng-window.go?s=1414:1450#L55">Width</a></h3>
				<pre>func (me *<a href="#WindowOptions">WindowOptions</a>) Width() <a href="/pkg/builtin/#int">int</a></pre>
				<p>
Returns the width of the window in pixels.
</p>

				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="-old-and-misc/">-old-and-misc</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>
	




		</div></div>
	</body>
</html>