<html>
	<head>
		<title>Package github.com/go3d/go-ngine/core</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/core</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/core"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *core* package provides go:ngine client-side core functionality such as rendering and user I/O.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Dispose">func Dispose()</a></dd>
			
				
				<dd><a href="#Init">func Init(options *EngineOptions, initialWinTitle string) (err error)</a></dd>
			
			
				
				<dd><a href="#Camera">type Camera</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.ApplyMatrices">func (me *Camera) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.Scene">func (me *Camera) Scene() *Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.SetScene">func (me *Camera) SetScene(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.SetTechnique">func (me *Camera) SetTechnique(name string)</a></dd>
				
			
				
				<dd><a href="#CameraViewport">type CameraViewport</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewport.SetAbs">func (me *CameraViewport) SetAbs(x, y, width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewport.SetRel">func (me *CameraViewport) SetRel(x, y, width, height float64)</a></dd>
				
			
				
				<dd><a href="#Cameras">type Cameras</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Cameras.Remove">func (me *Cameras) Remove(camera *Camera)</a></dd>
				
			
				
				<dd><a href="#Controller">type Controller</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.BeginUpdate">func (me *Controller) BeginUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.CopyFrom">func (me *Controller) CopyFrom(ctl *Controller)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.Dir">func (me *Controller) Dir() *unum.Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.EndUpdate">func (me *Controller) EndUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveBackward">func (me *Controller) MoveBackward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveDown">func (me *Controller) MoveDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveForward">func (me *Controller) MoveForward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveLeft">func (me *Controller) MoveLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveRight">func (me *Controller) MoveRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveUp">func (me *Controller) MoveUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeMove">func (me *Controller) StepSizeMove() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeTurn">func (me *Controller) StepSizeTurn() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDown">func (me *Controller) TurnDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDownBy">func (me *Controller) TurnDownBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeft">func (me *Controller) TurnLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeftBy">func (me *Controller) TurnLeftBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRight">func (me *Controller) TurnRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRightBy">func (me *Controller) TurnRightBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUp">func (me *Controller) TurnUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUpBy">func (me *Controller) TurnUpBy(deg float64)</a></dd>
				
			
				
				<dd><a href="#ControllerParams">type ControllerParams</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerParams">func NewControllerParams() (me *ControllerParams)</a></dd>
				
				
			
				
				<dd><a href="#EngineCore">type EngineCore</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineCore.SyncUpdates">func (me *EngineCore) SyncUpdates()</a></dd>
				
			
				
				<dd><a href="#EngineDiag">type EngineDiag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.Log">func (me *EngineDiag) Log(cat EngineDiagLogCategory, fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogErr">func (me *EngineDiag) LogErr(err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogIfGlErr">func (me *EngineDiag) LogIfGlErr(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogMeshes">func (me *EngineDiag) LogMeshes(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogMisc">func (me *EngineDiag) LogMisc(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogShaders">func (me *EngineDiag) LogShaders(fmt string, fmtArgs ...interface{})</a></dd>
				
			
				
				<dd><a href="#EngineDiagLogCategory">type EngineDiagLogCategory</a></dd>
				
				
			
				
				<dd><a href="#EngineLoop">type EngineLoop</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Loop">func (me *EngineLoop) Loop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Stop">func (me *EngineLoop) Stop()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Time">func (_ *EngineLoop) Time() float64</a></dd>
				
			
				
				<dd><a href="#EngineOptions">type EngineOptions</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEngineOptions">func NewEngineOptions(assetRootDirPath string, winWidth, winHeight, winSwapInterval int, winFullScreen bool) (me *EngineOptions)</a></dd>
				
				
			
				
				<dd><a href="#EngineStats">type EngineStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.AverageFps">func (me *EngineStats) AverageFps() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.TotalFrames">func (me *EngineStats) TotalFrames() float64</a></dd>
				
			
				
				<dd><a href="#EngineUserIO">type EngineUserIO</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.IifKeyF">func (me *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressed">func (me *EngineUserIO) KeyPressed(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressedWhich">func (me *EngineUserIO) KeyPressedWhich(keys ...int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyToggled">func (me *EngineUserIO) KeyToggled(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll2">func (me *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll3">func (me *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny2">func (me *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny3">func (me *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.SetWinTitle">func (me *EngineUserIO) SetWinTitle(newTitle string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.WinHeight">func (me *EngineUserIO) WinHeight() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.WinWidth">func (me *EngineUserIO) WinWidth() int</a></dd>
				
			
				
				<dd><a href="#FxColorOrTexture">type FxColorOrTexture</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxColor">func NewFxColor(rgba ...float64) (me *FxColorOrTexture)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxTexture">func NewFxTexture(image2ID string, sampler *ugl.Sampler) (me *FxColorOrTexture)</a></dd>
				
				
			
				
				<dd><a href="#FxEffect">type FxEffect</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxEffect">func NewFxEffect() (me *FxEffect)</a></dd>
				
				
			
				
				<dd><a href="#FxImage2D">type FxImage2D</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxImage2D">func NewFxImage2D() (me *FxImage2D)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.GpuSync">func (me *FxImage2D) GpuSync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.IsRemote">func (me *FxImage2D) IsRemote() (remote bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Load">func (me *FxImage2D) Load()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Loaded">func (me *FxImage2D) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Unload">func (me *FxImage2D) Unload()</a></dd>
				
			
				
				<dd><a href="#FxImageBase">type FxImageBase</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.GpuDelete">func (me *FxImageBase) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.GpuSynced">func (me *FxImageBase) GpuSynced() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.NoAutoMips">func (me *FxImageBase) NoAutoMips()</a></dd>
				
			
				
				<dd><a href="#FxImageOnLoad">type FxImageOnLoad</a></dd>
				
				
			
				
				<dd><a href="#FxMaterial">type FxMaterial</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxMaterial">func NewFxMaterial() (me *FxMaterial)</a></dd>
				
				
			
				
				<dd><a href="#LibFxEffects">type LibFxEffects</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffects.AddNew">func (me LibFxEffects) AddNew(id string) (obj *FxEffect)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffects.Remove">func (me LibFxEffects) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibFxImage2Ds">type LibFxImage2Ds</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImage2Ds.AddNew">func (me LibFxImage2Ds) AddNew(id string) (obj *FxImage2D)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImage2Ds.Remove">func (me LibFxImage2Ds) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibFxMaterials">type LibFxMaterials</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterials.AddNew">func (me LibFxMaterials) AddNew(id string) (obj *FxMaterial)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterials.Remove">func (me LibFxMaterials) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibMeshes">type LibMeshes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMeshes.AddLoad">func (me LibMeshes) AddLoad(id string, meshProvider MeshProvider, args ...interface{}) (mesh *Mesh, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMeshes.AddNew">func (me LibMeshes) AddNew(id string) (obj *Mesh)</a></dd>
				
			
				
				<dd><a href="#LibScenes">type LibScenes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibScenes.AddNew">func (me LibScenes) AddNew(id string) (obj *Scene)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibScenes.Remove">func (me LibScenes) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibScenes.Walk">func (me LibScenes) Walk(onNode func(*Node))</a></dd>
				
			
				
				<dd><a href="#Mesh">type Mesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMesh">func NewMesh(id string) (me *Mesh)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuDelete">func (me *Mesh) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUpload">func (me *Mesh) GpuUpload() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUploaded">func (me *Mesh) GpuUploaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Load">func (me *Mesh) Load(provider MeshProvider, args ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Loaded">func (me *Mesh) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Unload">func (me *Mesh) Unload()</a></dd>
				
			
				
				<dd><a href="#MeshBuffer">type MeshBuffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Add">func (me *MeshBuffer) Add(mesh *Mesh) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Remove">func (me *MeshBuffer) Remove(mesh *Mesh)</a></dd>
				
			
				
				<dd><a href="#MeshBuffers">type MeshBuffers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.Add">func (me *MeshBuffers) Add(id string, params *meshBufferParams) (buf *MeshBuffer, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.FloatsPerVertex">func (me *MeshBuffers) FloatsPerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.MemSizePerIndex">func (me *MeshBuffers) MemSizePerIndex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.MemSizePerVertex">func (me *MeshBuffers) MemSizePerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.NewParams">func (me *MeshBuffers) NewParams(numVerts, numIndices int32) (params *meshBufferParams)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.Remove">func (me *MeshBuffers) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabCube">func MeshProviderPrefabCube(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabPlane">func MeshProviderPrefabPlane(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabPyramid">func MeshProviderPrefabPyramid(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabQuad">func MeshProviderPrefabQuad(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabTri">func MeshProviderPrefabTri(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddFaces">func (me *MeshData) AddFaces(faces ...*MeshFace3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddNormals">func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddPositions">func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddTexCoords">func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</a></dd>
				
			
				
				<dd><a href="#MeshFace3">type MeshFace3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshFace3">func NewMeshFace3(tags, id string, verts ...MeshVert) (me *MeshFace3)</a></dd>
				
				
			
				
				<dd><a href="#MeshFaceBase">type MeshFaceBase</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#MeshVert">type MeshVert</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt2">type MeshVertAtt2</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt3">type MeshVertAtt3</a></dd>
				
				
			
				
				<dd><a href="#Model">type Model</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.Clone">func (me *Model) Clone(newModelID string) (clonedModel *Model)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.MatID">func (me *Model) MatID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.SetMatID">func (me *Model) SetMatID(newMatID string)</a></dd>
				
			
				
				<dd><a href="#Models">type Models</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Models.Default">func (me Models) Default() *Model</a></dd>
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.EffectiveMaterial">func (me *Node) EffectiveMaterial() *FxMaterial</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MatID">func (me *Node) MatID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MeshID">func (me *Node) MeshID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.ModelID">func (me *Node) ModelID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.Root">func (me *Node) Root() (root *Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMatID">func (me *Node) SetMatID(newMatID string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMeshModelID">func (me *Node) SetMeshModelID(meshID, modelID string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.Walk">func (me *Node) Walk(onNode func(*Node))</a></dd>
				
			
				
				<dd><a href="#NodeTransform">type NodeTransform</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.AddRot">func (me *NodeTransform) AddRot(rot *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.AddRotXYZ">func (me *NodeTransform) AddRotXYZ(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.ApplyMatrices">func (me *NodeTransform) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPos">func (me *NodeTransform) SetPos(pos *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPosX">func (me *NodeTransform) SetPosX(posX float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPosXYZ">func (me *NodeTransform) SetPosXYZ(posX, posY, posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPosY">func (me *NodeTransform) SetPosY(posY float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPosZ">func (me *NodeTransform) SetPosZ(posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRot">func (me *NodeTransform) SetRot(rot *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRotX">func (me *NodeTransform) SetRotX(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRotXYZ">func (me *NodeTransform) SetRotXYZ(radX, radY, radZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRotY">func (me *NodeTransform) SetRotY(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRotZ">func (me *NodeTransform) SetRotZ(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetScale">func (me *NodeTransform) SetScale(scale *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetScaleN">func (me *NodeTransform) SetScaleN(scale float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetScaleXYZ">func (me *NodeTransform) SetScaleXYZ(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.StepDelta">func (me *NodeTransform) StepDelta(deltaPerSecond float64) float64</a></dd>
				
			
				
				<dd><a href="#Nodes">type Nodes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.Add">func (me *Nodes) Add(node *Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.AddNew">func (me *Nodes) AddNew(id, meshID, modelID string) (node *Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.Remove">func (me *Nodes) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#PostFx">type PostFx</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PostFx.ApplyEffects">func (me *PostFx) ApplyEffects() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PostFx.DisableEffect">func (me *PostFx) DisableEffect(name string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PostFx.EnableEffect">func (me *PostFx) EnableEffect(name string) (effect *PostFxEffect)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PostFx.ToggleEffect">func (me *PostFx) ToggleEffect(name string) (enabled bool)</a></dd>
				
			
				
				<dd><a href="#PostFxEffect">type PostFxEffect</a></dd>
				
				
			
				
				<dd><a href="#RenderCanvas">type RenderCanvas</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.AddNewCamera2D">func (me *RenderCanvas) AddNewCamera2D(allowOverlaps bool) (cam *Camera)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.AddNewCamera3D">func (me *RenderCanvas) AddNewCamera3D() (cam *Camera)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.Main">func (me *RenderCanvas) Main() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.Remove">func (me *RenderCanvas) Remove()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.SetMain">func (me *RenderCanvas) SetMain()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.SetSize">func (me *RenderCanvas) SetSize(relative bool, width, height float64)</a></dd>
				
			
				
				<dd><a href="#RenderCanvases">type RenderCanvases</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.AddNew">func (me *RenderCanvases) AddNew(isMain bool, relative bool, width, height float64) (rc *RenderCanvas)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.Main">func (me RenderCanvases) Main() (main *RenderCanvas)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.Walk">func (me RenderCanvases) Walk(onCam func(*Camera))</a></dd>
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewScene">func NewScene() (me *Scene)</a></dd>
				
				
			
				
				<dd><a href="#TimingStats">type TimingStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Average">func (me *TimingStats) Average() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Max">func (me *TimingStats) Max() float64</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-gen-glsl-src.go">-gen-glsl-src.go</a>
			
				<a href="/target/camera.go">camera.go</a>
			
				<a href="/target/controller.go">controller.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/fileio.go">fileio.go</a>
			
				<a href="/target/fx-effect.gt.go">fx-effect.gt.go</a>
			
				<a href="/target/fx-image-2d.gt.go">fx-image-2d.gt.go</a>
			
				<a href="/target/fx-image.go">fx-image.go</a>
			
				<a href="/target/fx-material.gt.go">fx-material.gt.go</a>
			
				<a href="/target/gl-core.go">gl-core.go</a>
			
				<a href="/target/mesh-buffer.go">mesh-buffer.go</a>
			
				<a href="/target/mesh-data.go">mesh-data.go</a>
			
				<a href="/target/mesh-provider.go">mesh-provider.go</a>
			
				<a href="/target/mesh.go">mesh.go</a>
			
				<a href="/target/model.go">model.go</a>
			
				<a href="/target/ng-core.go">ng-core.go</a>
			
				<a href="/target/ng-diag.go">ng-diag.go</a>
			
				<a href="/target/ng-loop.go">ng-loop.go</a>
			
				<a href="/target/ng-options.go">ng-options.go</a>
			
				<a href="/target/ng-stats.go">ng-stats.go</a>
			
				<a href="/target/ng-userio.go">ng-userio.go</a>
			
				<a href="/target/ng.go">ng.go</a>
			
				<a href="/target/node-transform.go">node-transform.go</a>
			
				<a href="/target/node.go">node.go</a>
			
				<a href="/target/nodes.go">nodes.go</a>
			
				<a href="/target/postfx.go">postfx.go</a>
			
				<a href="/target/render-batch.go">render-batch.go</a>
			
				<a href="/target/render-canvas.go">render-canvas.go</a>
			
				<a href="/target/render-prep.go">render-prep.go</a>
			
				<a href="/target/render-technique.go">render-technique.go</a>
			
				<a href="/target/render.go">render.go</a>
			
				<a href="/target/scene.gt.go">scene.gt.go</a>
			
				<a href="/target/threading.go">threading.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    Diag = EngineDiag{
        LogCategories:       DiagLogCatAll,
        LogErrorsDuringLoop: true,
    }
)</pre>
				
			
		
		
			
			
			<h2 id="Dispose">func <a href="/target/ng.go?s=172:186#L1">Dispose</a></h2>
			<pre>func Dispose()</pre>
			<p>
Call this to &#34;un-init&#34; go:ngine and to release any and all GPU or RAM resources still allocated.
</p>

			
		
			
			
			<h2 id="Init">func <a href="/target/ng.go?s=393:462#L7">Init</a></h2>
			<pre>func Init(options *EngineOptions, initialWinTitle string) (err error)</pre>
			<p>
Initializes go:ngine; this first attempts to initialize OpenGL and then open a window to your supplied specifications with a GL 3.3-or-higher profile.
</p>

			
		
		
			
			
			<h2 id="Camera">type <a href="/target/camera.go?s=219:1343#L1">Camera</a></h2>
			<pre>type Camera struct {
    <span class="comment">//	Optical and imager properties for this camera.</span>
    Perspective struct {
        <span class="comment">//	Whether this is a perspective-projection camera. Defaults to true.</span>
        <span class="comment">//	If false, no projection transformation is applied.</span>
        Use bool

        <span class="comment">//	Vertical field-of-view. Defaults to 37.8493.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        FovY float64

        <span class="comment">//	Distance of the far-plane from the camera. Defaults to 30000.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        ZFar float64

        <span class="comment">//	Distance of the near-plane from the camera. Defaults to 0.3.</span>
        <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
        ZNear float64
    }

    <span class="comment">//	Encapsulates the position and direction of this camera.</span>
    Controller Controller

    Enabled bool

    Rendering struct {
        <span class="comment">//	The device-relative or absolute view-port for this Camera.</span>
        Viewport CameraViewport

        States ugl.RenderStatesBag
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A camera embodies the eye point of the viewer looking at the visual scene.
</p>


			

			

			

			

			
				
				<h3 id="Camera.ApplyMatrices">func (*Camera) <a href="/target/camera.go?s=2406:2439#L83">ApplyMatrices</a></h3>
				<pre>func (me *Camera) ApplyMatrices()</pre>
				<p>
Applies changes made to the FovY, ZNear and/or ZFar parameters in me.Perspective.
</p>

				
				
			
				
				<h3 id="Camera.Scene">func (*Camera) <a href="/target/camera.go?s=2826:2858#L100">Scene</a></h3>
				<pre>func (me *Camera) Scene() *Scene</pre>
				
				
				
			
				
				<h3 id="Camera.SetScene">func (*Camera) <a href="/target/camera.go?s=3096:3133#L115">SetScene</a></h3>
				<pre>func (me *Camera) SetScene(id string)</pre>
				
				
				
			
				
				<h3 id="Camera.SetTechnique">func (*Camera) <a href="/target/camera.go?s=3174:3217#L119">SetTechnique</a></h3>
				<pre>func (me *Camera) SetTechnique(name string)</pre>
				
				
				
			
		
			
			
			<h2 id="CameraViewport">type <a href="/target/camera.go?s=3599:3852#L137">CameraViewport</a></h2>
			<pre>type CameraViewport struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a device-relative or absolute camera view-port.
</p>


			

			

			

			

			
				
				<h3 id="CameraViewport.SetAbs">func (*CameraViewport) <a href="/target/camera.go?s=3978:4035#L152">SetAbs</a></h3>
				<pre>func (me *CameraViewport) SetAbs(x, y, width, height int)</pre>
				<p>
Sets the absolute viewport origin and dimensions in pixels.
</p>

				
				
			
				
				<h3 id="CameraViewport.SetRel">func (*CameraViewport) <a href="/target/camera.go?s=4286:4347#L159">SetRel</a></h3>
				<pre>func (me *CameraViewport) SetRel(x, y, width, height float64)</pre>
				<p>
Sets the device-relative viewport origin and dimensions, with the value 1.0
representing the maximum extent of the viewport on that respective axis.
</p>

				
				
			
		
			
			
			<h2 id="Cameras">type <a href="/target/camera.go?s=3340:3362#L125">Cameras</a></h2>
			<pre>type Cameras []*Camera</pre>
			

			

			

			

			

			
				
				<h3 id="Cameras.Remove">func (*Cameras) <a href="/target/camera.go?s=3364:3405#L127">Remove</a></h3>
				<pre>func (me *Cameras) Remove(camera *Camera)</pre>
				
				
				
			
		
			
			
			<h2 id="Controller">type <a href="/target/controller.go?s=272:987#L2">Controller</a></h2>
			<pre>type Controller struct {
    <span class="comment">//	The position being manipulated by this Controller.</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    Pos unum.Vec3

    <span class="comment">//	Indicates which axis is consider &#34;upward&#34;. This is typically</span>
    <span class="comment">//	the Y-axis, denoted by the default value (0, 1, 0).</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    UpAxis unum.Vec3

    Params *ControllerParams
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a position-and-direction and provides methods
manipulating these with respect to each other (e.g. &#34;move forward&#34;
some entity that is rotated facing some arbitrary direction).
</p>


			

			

			

			

			
				
				<h3 id="Controller.BeginUpdate">func (*Controller) <a href="/target/controller.go?s=2153:2188#L59">BeginUpdate</a></h3>
				<pre>func (me *Controller) BeginUpdate()</pre>
				<p>
Temporarily suspends all matrix re-calculations typically occuring inside
the MoveXyz() / TurnXyz() methods. Call this prior to multiple subsequent
calls to any combination of those methods, and/or prior to manually modifying
the Pos, Dir or UpAxis fields of me. Immediately afterwards, be sure to call
EndUpdate() to apply all changes in a final matrix re-calculation.
</p>

				
				
			
				
				<h3 id="Controller.CopyFrom">func (*Controller) <a href="/target/controller.go?s=2217:2264#L63">CopyFrom</a></h3>
				<pre>func (me *Controller) CopyFrom(ctl *Controller)</pre>
				
				
				
			
				
				<h3 id="Controller.Dir">func (*Controller) <a href="/target/controller.go?s=2600:2638#L72">Dir</a></h3>
				<pre>func (me *Controller) Dir() *unum.Vec3</pre>
				<p>
The direction being manipulated by this Controller.
CAUTION: this returns a pointer to the direction vector to avoid a copy, but it&#39;s
NOT meant to be modified, as the vector is re-computed by the TurnFoo() methods.
</p>

				
				
			
				
				<h3 id="Controller.EndUpdate">func (*Controller) <a href="/target/controller.go?s=2965:2998#L80">EndUpdate</a></h3>
				<pre>func (me *Controller) EndUpdate()</pre>
				<p>
Applies all changes made to Pos, Dir or UpAxis since BeginUpdate() was last
called, and recalculates this Controller&#39;s final 4x4 transformation matrix.
Also resumes all matrix re-calculations typically occuring inside the
MoveXyz() / TurnXyz() methods that were suspended since BeginUpdate().
</p>

				
				
			
				
				<h3 id="Controller.MoveBackward">func (*Controller) <a href="/target/controller.go?s=3831:3867#L111">MoveBackward</a></h3>
				<pre>func (me *Controller) MoveBackward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move backward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveDown">func (*Controller) <a href="/target/controller.go?s=4027:4059#L117">MoveDown</a></h3>
				<pre>func (me *Controller) MoveDown()</pre>
				<p>
Recomputes Pos with regards to UpAxis to effect a &#34;move downward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveForward">func (*Controller) <a href="/target/controller.go?s=4229:4264#L123">MoveForward</a></h3>
				<pre>func (me *Controller) MoveForward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move forward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveLeft">func (*Controller) <a href="/target/controller.go?s=4433:4465#L129">MoveLeft</a></h3>
				<pre>func (me *Controller) MoveLeft()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move left-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveRight">func (*Controller) <a href="/target/controller.go?s=4662:4695#L135">MoveRight</a></h3>
				<pre>func (me *Controller) MoveRight()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move right-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveUp">func (*Controller) <a href="/target/controller.go?s=4880:4910#L141">MoveUp</a></h3>
				<pre>func (me *Controller) MoveUp()</pre>
				<p>
Recomputes Pos with regards to UpAxis to effect a &#34;move upward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.StepSizeMove">func (*Controller) <a href="/target/controller.go?s=5381:5425#L160">StepSizeMove</a></h3>
				<pre>func (me *Controller) StepSizeMove() float64</pre>
				<p>
Returns the current distance that a single MoveXyz() call (per loop iteration) would move.
(Loop.TickDelta * me.Params.MoveSpeed * me.Params.MoveSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.StepSizeTurn">func (*Controller) <a href="/target/controller.go?s=5671:5715#L166">StepSizeTurn</a></h3>
				<pre>func (me *Controller) StepSizeTurn() float64</pre>
				<p>
Returns the current degrees that a single TurnXyz() call (per loop iteration) would turn.
(Loop.TickDelta * me.Params.TurnSpeed * me.Params.TurnSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.TurnDown">func (*Controller) <a href="/target/controller.go?s=5903:5935#L171">TurnDown</a></h3>
				<pre>func (me *Controller) TurnDown()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnDownBy">func (*Controller) <a href="/target/controller.go?s=6078:6123#L176">TurnDownBy</a></h3>
				<pre>func (me *Controller) TurnDownBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeft">func (*Controller) <a href="/target/controller.go?s=6296:6328#L183">TurnLeft</a></h3>
				<pre>func (me *Controller) TurnLeft()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeftBy">func (*Controller) <a href="/target/controller.go?s=6472:6517#L188">TurnLeftBy</a></h3>
				<pre>func (me *Controller) TurnLeftBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnRight">func (*Controller) <a href="/target/controller.go?s=6646:6679#L193">TurnRight</a></h3>
				<pre>func (me *Controller) TurnRight()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnRightBy">func (*Controller) <a href="/target/controller.go?s=6825:6871#L198">TurnRightBy</a></h3>
				<pre>func (me *Controller) TurnRightBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnUp">func (*Controller) <a href="/target/controller.go?s=6997:7027#L203">TurnUp</a></h3>
				<pre>func (me *Controller) TurnUp()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnUpBy">func (*Controller) <a href="/target/controller.go?s=7166:7209#L208">TurnUpBy</a></h3>
				<pre>func (me *Controller) TurnUpBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34; by the specified degress.
</p>

				
				
			
		
			
			
			<h2 id="ControllerParams">type <a href="/target/controller.go?s=7271:7905#L214">ControllerParams</a></h2>
			<pre>type ControllerParams struct {
    <span class="comment">//	Speed of &#34;moving&#34; in the MoveXyz() methods, in units per second.</span>
    <span class="comment">//	Defaults to 2.</span>
    MoveSpeed float64

    <span class="comment">//	A factor multiplied with MoveSpeed in the MoveXyz() methods. Defaults to 1.</span>
    MoveSpeedupFactor float64

    <span class="comment">//	Speed of &#34;turning&#34; in the TurnXyz() methods, in degrees per second.</span>
    <span class="comment">//	Defaults to 90.</span>
    TurnSpeed float64

    <span class="comment">//	A factor multiplied with TurnSpeed in the TurnXyz() methods. Defaults to 1.</span>
    TurnSpeedupFactor float64

    <span class="comment">//	The maximum degree that TurnUp() allows. Defaults to 90.</span>
    MaxTurnUp float64

    <span class="comment">//	The minimum degree that TurnDown() allows. Defaults to -90.</span>
    MinTurnDown float64
}</pre>
			

			

			

			

			
				
				<h3 id="NewControllerParams">func <a href="/target/controller.go?s=7907:7956#L236">NewControllerParams</a></h3>
				<pre>func NewControllerParams() (me *ControllerParams)</pre>
				
				
			

			
		
			
			
			<h2 id="EngineCore">type <a href="/target/ng-core.go?s=436:892#L5">EngineCore</a></h2>
			<pre>type EngineCore struct {
    MeshBuffers *MeshBuffers
    Options     EngineOptions
    Libs        struct {
        Effects   LibFxEffects
        Materials LibFxMaterials
        Images    struct {
            I2D LibFxImage2Ds
        }
        Meshes LibMeshes
        Scenes LibScenes
    }
    Rendering struct {
        Canvases RenderCanvases
        PostFx   PostFx
        Samplers struct {
            NoFilteringClamp    ugl.Sampler
            FullFilteringRepeat ugl.Sampler
        }
        <span class="comment">// contains filtered or unexported fields</span>
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineCore a &#34;Singleton&#34; type, only valid use is the core.Core global variable.
The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.
</p>


			

			
				<pre>var (
    <span class="comment">//	The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.</span>
    Core EngineCore
)</pre>
				
			

			

			

			
				
				<h3 id="EngineCore.SyncUpdates">func (*EngineCore) <a href="/target/ng-core.go?s=2689:2724#L93">SyncUpdates</a></h3>
				<pre>func (me *EngineCore) SyncUpdates()</pre>
				
				
				
			
		
			
			
			<h2 id="EngineDiag">type <a href="/target/ng-diag.go?s=478:573#L16">EngineDiag</a></h2>
			<pre>type EngineDiag struct {
    LogCategories       EngineDiagLogCategory
    LogErrorsDuringLoop bool
}</pre>
			

			

			

			

			

			
				
				<h3 id="EngineDiag.Log">func (*EngineDiag) <a href="/target/ng-diag.go?s=575:663#L21">Log</a></h3>
				<pre>func (me *EngineDiag) Log(cat EngineDiagLogCategory, fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogErr">func (*EngineDiag) <a href="/target/ng-diag.go?s=740:779#L27">LogErr</a></h3>
				<pre>func (me *EngineDiag) LogErr(err error)</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogIfGlErr">func (*EngineDiag) <a href="/target/ng-diag.go?s=804:872#L31">LogIfGlErr</a></h3>
				<pre>func (me *EngineDiag) LogIfGlErr(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogMeshes">func (*EngineDiag) <a href="/target/ng-diag.go?s=913:980#L35">LogMeshes</a></h3>
				<pre>func (me *EngineDiag) LogMeshes(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogMisc">func (*EngineDiag) <a href="/target/ng-diag.go?s=1026:1091#L39">LogMisc</a></h3>
				<pre>func (me *EngineDiag) LogMisc(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogShaders">func (*EngineDiag) <a href="/target/ng-diag.go?s=1138:1206#L43">LogShaders</a></h3>
				<pre>func (me *EngineDiag) LogShaders(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
		
			
			
			<h2 id="EngineDiagLogCategory">type <a href="/target/ng-diag.go?s=107:137#L1">EngineDiagLogCategory</a></h2>
			<pre>type EngineDiagLogCategory int</pre>
			

			
				<pre>const (
    DiagLogCatMisc    EngineDiagLogCategory = 1
    DiagLogMeshes     EngineDiagLogCategory = 2
    DiagLogCatShaders EngineDiagLogCategory = 4
    DiagLogCatAll     EngineDiagLogCategory = DiagLogMeshes | DiagLogCatMisc | DiagLogCatShaders
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="EngineLoop">type <a href="/target/ng-loop.go?s=408:2082#L8">EngineLoop</a></h2>
			<pre>type EngineLoop struct {
    <span class="comment">//	Set to true by Loop.Loop(). Set to false to stop looping.</span>
    IsLooping bool

    <span class="comment">//	The tick-time when the Loop.OnSec() callback was last invoked.</span>
    SecTickLast float64

    <span class="comment">//	While Loop.Loop() is running, is set to the current &#34;tick-time&#34;:</span>
    <span class="comment">//	the time in seconds expired ever since Loop.Loop() was last called.</span>
    TickNow float64

    <span class="comment">//	While Loop.Loop() is running, is set to the previous tick-time.</span>
    TickLast float64

    <span class="comment">//	The delta between TickLast and TickNow.</span>
    TickDelta float64

    <span class="comment">//	While Loop.Loop() is running, this callback is invoked (in its own &#34;app thread&#34;)</span>
    <span class="comment">//	every loop iteration (ie. once per frame).</span>
    <span class="comment">//	This callback may run in parallel with OnSec(), but never with OnWinThread().</span>
    OnAppThread func()

    <span class="comment">//	While Loop.Loop() is running, this callback is invoked (on the main windowing thread)</span>
    <span class="comment">//	every loop iteration (ie. once per frame).</span>
    <span class="comment">//	This callback is guaranteed to never run in parallel with</span>
    <span class="comment">//	(and always after) the OnAppThread() and OnSec() callbacks.</span>
    OnWinThread func()

    <span class="comment">//	While Loop.Loop() is running, this callback is invoked (on the main windowing thread)</span>
    <span class="comment">//	at least and at most once per second.</span>
    <span class="comment">//	Caution: unlike OnWinThread(), this callback most likely runs in parallel with your OnAppThread() callback.</span>
    OnSec func()

    <span class="comment">//	If true, Loop() waits for the app and prep threads to finish before swapping buffers.</span>
    <span class="comment">//	If false, Loop() allows the app and prep threads to continue running while swapping buffers.</span>
    <span class="comment">//	Defaults to false. Setting this to true may prove beneficial if your OnAppThread() callback</span>
    <span class="comment">//	isn&#39;t doing any computationally intensive work.</span>
    SwapLast bool
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineLoop a &#34;Singleton&#34; type, only valid use is the core.Loop global variable.
Manages your main-thread&#39;s &#34;game loop&#34;.
</p>


			

			
				<pre>var (
    <span class="comment">//	Manages your main-thread&#39;s &#34;game loop&#34;. You&#39;ll need to call it&#39;s Loop() method once after go:ngine initialization (see samples).</span>
    Loop EngineLoop
)</pre>
				
			

			

			

			
				
				<h3 id="EngineLoop.Loop">func (*EngineLoop) <a href="/target/ng-loop.go?s=2377:2405#L59">Loop</a></h3>
				<pre>func (me *EngineLoop) Loop()</pre>
				<p>
Initiates a rendering loop. This method returns only when the loop is stopped for whatever reason.
</p>
<p>
(Before entering the loop, this method performs a one-off GC invokation.)
</p>

				
				
			
				
				<h3 id="EngineLoop.Stop">func (*EngineLoop) <a href="/target/ng-loop.go?s=5781:5809#L171">Stop</a></h3>
				<pre>func (me *EngineLoop) Stop()</pre>
				<p>
Stops the currently running Loop.Loop().
</p>

				
				
			
				
				<h3 id="EngineLoop.Time">func (*EngineLoop) <a href="/target/ng-loop.go?s=5918:5953#L176">Time</a></h3>
				<pre>func (_ *EngineLoop) Time() float64</pre>
				<p>
Returns the number of seconds expired ever since Loop.Loop() was last called.
</p>

				
				
			
		
			
			
			<h2 id="EngineOptions">type <a href="/target/ng-options.go?s=247:1037#L1">EngineOptions</a></h2>
			<pre>type EngineOptions struct {
    <span class="comment">//	The base directory path for asset file paths.</span>
    AssetRootDirPath string

    Initialization struct {
        GlCoreContext bool
        Window        struct {
            Rbits, Gbits, Bbits, Abits, DepthBits, StencilBits int
        }
    }

    Misc struct {
        DefaultControllerParams *ControllerParams
    }

    Rendering struct {
        DefaultClearColor ugl.GlVec4

        <span class="comment">//	Name for the default render technique of a Camera2D,</span>
        <span class="comment">//	defaults to the currently only implementation &#34;rt_unlit3&#34;.</span>
        DefaultTechnique2D string

        <span class="comment">//	Name for the default render technique of a Camera3D,</span>
        <span class="comment">//	defaults to the currently only implementation &#34;rt_unlit3&#34;.</span>
        DefaultTechnique3D string

        PostFx struct {
            TextureRect bool
        }
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineOptions a &#34;Singleton&#34; type, only valid use is the one instance you created for core.Init().
Various &#34;global&#34; (rather than use-case-specific) options.
</p>


			

			

			

			
				
				<h3 id="NewEngineOptions">func <a href="/target/ng-options.go?s=1112:1240#L37">NewEngineOptions</a></h3>
				<pre>func NewEngineOptions(assetRootDirPath string, winWidth, winHeight, winSwapInterval int, winFullScreen bool) (me *EngineOptions)</pre>
				<p>
Allocates, initializes and returns a new core.EngineOptions instance.
</p>

				
			

			
		
			
			
			<h2 id="EngineStats">type <a href="/target/ng-stats.go?s=299:3681#L4">EngineStats</a></h2>
			<pre>type EngineStats struct {
    <span class="comment">//	Gives the total number of frames rendered during the &#34;previous&#34;</span>
    <span class="comment">//	(not the current) second. Good enough for just a simple-minded FPS indicator.</span>
    FpsLastSec int

    <span class="comment">//	This TimingStats instance combines all the individual FrameFoo fields</span>
    <span class="comment">//	to track over time (both average and maximum) total cost per frame.</span>
    Frame TimingStats

    <span class="comment">//	&#34;Rendering&#34; consists of a CPU-side and a GPU-side cost.</span>
    <span class="comment">//	This TimingStats instance combines both to track over time</span>
    <span class="comment">//	(both average and maximum) total rendering cost per frame.</span>
    FrameRenderBoth TimingStats

    <span class="comment">//	The CPU-side cost of rendering comprises sending pre-batched</span>
    <span class="comment">//	rendering commands (prepared by the &#34;prep&#34; stage) to the GPU.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average</span>
    <span class="comment">//	and maximum) CPU-side rendering cost per frame.</span>
    FrameRenderCpu TimingStats

    <span class="comment">//	The GPU-side cost of rendering comprises execution of all draw calls</span>
    <span class="comment">//	sent by the CPU-side, plus waiting for V-sync if enabled.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average</span>
    <span class="comment">//	and maximum) GPU-side rendering cost per frame.</span>
    FrameRenderGpu TimingStats

    <span class="comment">//	&#34;Prep code&#34; comprises all go:ngine logic executed every frame in parallel to cull</span>
    <span class="comment">//	geometry and prepare a batch of rendering commands for the next (not current) frame.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;prep code&#34; cost per frame.</span>
    FramePrepThread TimingStats

    <span class="comment">//	&#34;App code&#34; comprises (mostly user-specific) logic executed every frame in parallel in</span>
    <span class="comment">//	your Loop.OnAppThread() callback. Such code may freely modify dynamic Cameras, Nodes etc.</span>
    <span class="comment">//	Unlike OnWinThread() code, &#34;app code&#34; always runs in its own thread in parallel to the prep and main threads.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;app code&#34; cost per frame.</span>
    FrameAppThread TimingStats

    <span class="comment">//	&#34;Windowing/GPU/IO code&#34; comprises user-specific logic executed every frame via your own</span>
    <span class="comment">//	Loop.OnWinThread() callback. This should be kept to a minimum to fully enjoy</span>
    <span class="comment">//	the benefits of multi-threading. Main use-cases are calls resulting in GPU state</span>
    <span class="comment">//	changes (such as toggling effects in Core.Rendering.PostFx) and working with UserIO</span>
    <span class="comment">//	to poll for user input -- but do consider executing resulting logic in your OnAppThread().</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;input code&#34; cost per frame.</span>
    FrameWinThread TimingStats

    <span class="comment">//	When CPU-side rendering is completed, Loop waits for the app thread and prep thread</span>
    <span class="comment">//	to finish (either before or after GPU-side rendering depending on Loop.SwapLast).</span>
    <span class="comment">//	It then moves &#34;prep results&#34; to the render thread and &#34;app results&#34; to the prep thread.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;thread sync&#34; cost per frame.</span>
    FrameThreadSync TimingStats

    <span class="comment">//	During the Loop, the Go Garbge Collector is invoked at least and at most once per second.</span>
    <span class="comment">//	</span>
    <span class="comment">//	Forcing GC &#34;that often&#34; practically guarantees it will almost never have so much work to do as to</span>
    <span class="comment">//	noticably block user interaction --- typically well below 10ms, most often around 1ms.</span>
    <span class="comment">//	</span>
    <span class="comment">//	This TimingStats instance over time tracks the maximum and average time spent on that</span>
    <span class="comment">//	1x-per-second-during-Loop GC invokation (but does not track any other GC invokations).</span>
    Gc TimingStats
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineStats a &#34;Singleton&#34; type, only valid use is the core.Stats global variable.
Tracks various go:ngine performance indicators over time.
</p>


			

			
				<pre>var (
    <span class="comment">//	Tracks various go:ngine performance counters over time.</span>
    Stats EngineStats
)</pre>
				
			

			

			

			
				
				<h3 id="EngineStats.AverageFps">func (*EngineStats) <a href="/target/ng-stats.go?s=3769:3812#L70">AverageFps</a></h3>
				<pre>func (me *EngineStats) AverageFps() float64</pre>
				<p>
Returns the average number of frames-per-second since Loop.Loop() was last called.
</p>

				
				
			
				
				<h3 id="EngineStats.TotalFrames">func (*EngineStats) <a href="/target/ng-stats.go?s=3937:3981#L78">TotalFrames</a></h3>
				<pre>func (me *EngineStats) TotalFrames() float64</pre>
				
				
				
			
		
			
			
			<h2 id="EngineUserIO">type <a href="/target/ng-userio.go?s=500:1049#L8">EngineUserIO</a></h2>
			<pre>type EngineUserIO struct {
    <span class="comment">//	Minimum delay for EngineUserIO.KeyToggled() method, in seconds. Defaults to 0.25.</span>
    KeyToggleMinDelay float64

    <span class="comment">//	Minimum delay, in seconds, to wait after the last window-resize event received from</span>
    <span class="comment">//	the OS before notifying the rendering runtime of the new window dimensions.</span>
    <span class="comment">//	Defaults to 0.25.</span>
    WinResizeMinDelay float64
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineUserIO a &#34;Singleton&#34; type, only valid use is the core.UserIO global variable.
Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).
</p>


			

			
				<pre>var (
    <span class="comment">//	Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).</span>
    UserIO EngineUserIO
)</pre>
				
			

			

			

			
				
				<h3 id="EngineUserIO.IifKeyF">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3025:3098#L82">IifKeyF</a></h3>
				<pre>func (me *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</pre>
				<p>
Returns ifTrue if the specified key is pressed, otherwise returns ifFalse.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressed">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3213:3261#L90">KeyPressed</a></h3>
				<pre>func (me *EngineUserIO) KeyPressed(key int) bool</pre>
				<p>
Returns true if the specified key is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressedWhich">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3352:3408#L95">KeyPressedWhich</a></h3>
				<pre>func (me *EngineUserIO) KeyPressedWhich(keys ...int) int</pre>
				<p>
Returns the first in keys that is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyToggled">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4374:4422#L125">KeyToggled</a></h3>
				<pre>func (me *EngineUserIO) KeyToggled(key int) bool</pre>
				<p>
Returns true if the specified key has been &#34;toggled&#34;, ie. its pressed-state changed within the last me.KeyToggleMinDelay seconds.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3574:3630#L105">KeysPressedAll2</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</pre>
				<p>
Returns true if both specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3740:3800#L110">KeysPressedAll3</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if all three specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3935:3991#L115">KeysPressedAny2</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</pre>
				<p>
Returns true if any of the two specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4107:4167#L120">KeysPressedAny3</a></h3>
				<pre>func (me *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if any of the three specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.SetWinTitle">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4657:4709#L134">SetWinTitle</a></h3>
				<pre>func (me *EngineUserIO) SetWinTitle(newTitle string)</pre>
				<p>
Sets the window title to newTitle.
</p>

				
				
			
				
				<h3 id="EngineUserIO.WinHeight">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4793:4832#L139">WinHeight</a></h3>
				<pre>func (me *EngineUserIO) WinHeight() int</pre>
				<p>
Returns the height of the window in pixels.
</p>

				
				
			
				
				<h3 id="EngineUserIO.WinWidth">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4915:4953#L144">WinWidth</a></h3>
				<pre>func (me *EngineUserIO) WinWidth() int</pre>
				<p>
Returns the width of the window in pixels.
</p>

				
				
			
		
			
			
			<h2 id="FxColorOrTexture">type <a href="/target/fx-effect.gt.go?s=206:625#L1">FxColorOrTexture</a></h2>
			<pre>type FxColorOrTexture struct {
    <span class="comment">//	If set, the color is sourced from this value.</span>
    Color *ugfx.Rgba64

    <span class="comment">//	If Color is nil, the color is sourced from a 2D texture image.</span>
    Texture struct {
        <span class="comment">//	The ID of the FxImage2D in Core.Libs.Images.I2D</span>
        Image2ID string

        <span class="comment">//	Describes filtering and wrapping when sampling the texture image.</span>
        <span class="comment">//	Defaults to Core.Rendering.Samplers.FullFilteringRepeat.</span>
        Sampler *ugl.Sampler
    }
}</pre>
			<p>
Declares a source of color information:
either pointing to an FxImage2D or a 64-bit RGBA color.
</p>


			

			

			

			
				
				<h3 id="NewFxColor">func <a href="/target/fx-effect.gt.go?s=709:764#L16">NewFxColor</a></h3>
				<pre>func NewFxColor(rgba ...float64) (me *FxColorOrTexture)</pre>
				<p>
Creates and returns a new FxColorOrTexture that points to the specified color.
</p>

				
			
				
				<h3 id="NewFxTexture">func <a href="/target/fx-effect.gt.go?s=1022:1101#L23">NewFxTexture</a></h3>
				<pre>func NewFxTexture(image2ID string, sampler *ugl.Sampler) (me *FxColorOrTexture)</pre>
				<p>
Creates and returns a new FxColorOrTexture that points to the specified texture image.
If sampler is nil, Core.Rendering.Samplers.FullFilteringRepeat is used for me.Texture.Sampler.
</p>

				
			

			
		
			
			
			<h2 id="FxEffect">type <a href="/target/fx-effect.gt.go?s=1283:1390#L32">FxEffect</a></h2>
			<pre>type FxEffect struct {
    <span class="comment">//	The source for diffuse color information. Required.</span>
    Diffuse *FxColorOrTexture
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxEffect">func <a href="/target/fx-effect.gt.go?s=1562:1595#L46">NewFxEffect</a></h3>
				<pre>func NewFxEffect() (me *FxEffect)</pre>
				<p>
Initializes and returns a new FxEffect with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="FxImage2D">type <a href="/target/fx-image-2d.gt.go?s=131:210#L4">FxImage2D</a></h2>
			<pre>type FxImage2D struct {
    FxImageBase
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxImage2D">func <a href="/target/fx-image-2d.gt.go?s=3244:3279#L140">NewFxImage2D</a></h3>
				<pre>func NewFxImage2D() (me *FxImage2D)</pre>
				<p>
Initializes and returns a new FxImage2D with default parameters.
</p>

				
			

			
				
				<h3 id="FxImage2D.GpuSync">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=381:423#L21">GpuSync</a></h3>
				<pre>func (me *FxImage2D) GpuSync() (err error)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.IsRemote">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=2165:2210#L94">IsRemote</a></h3>
				<pre>func (me *FxImage2D) IsRemote() (remote bool)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Load">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=524:551#L28">Load</a></h3>
				<pre>func (me *FxImage2D) Load()</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Loaded">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=1636:1670#L77">Loaded</a></h3>
				<pre>func (me *FxImage2D) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Unload">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=2254:2283#L99">Unload</a></h3>
				<pre>func (me *FxImage2D) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageBase">type <a href="/target/fx-image.go?s=64:277#L1">FxImageBase</a></h2>
			<pre>type FxImageBase struct {
    OnAsyncDone      func()
    OnLoad           FxImageOnLoad
    AsyncNumAttempts int
    InitFrom         struct {
        RawData []byte
        RefUrl  string
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxImageBase.GpuDelete">func (*FxImageBase) <a href="/target/fx-image.go?s=544:578#L25">GpuDelete</a></h3>
				<pre>func (me *FxImageBase) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="FxImageBase.GpuSynced">func (*FxImageBase) <a href="/target/fx-image.go?s=625:664#L30">GpuSynced</a></h3>
				<pre>func (me *FxImageBase) GpuSynced() bool</pre>
				
				
				
			
				
				<h3 id="FxImageBase.NoAutoMips">func (*FxImageBase) <a href="/target/fx-image.go?s=690:725#L34">NoAutoMips</a></h3>
				<pre>func (me *FxImageBase) NoAutoMips()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageOnLoad">type <a href="/target/fx-image.go?s=856:919#L44">FxImageOnLoad</a></h2>
			<pre>type FxImageOnLoad func(img interface{}, err error, async bool)</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxMaterial">type <a href="/target/fx-material.gt.go?s=103:538#L1">FxMaterial</a></h2>
			<pre>type FxMaterial struct {
    <span class="comment">//	This effect is used by default for all faces that do not fall</span>
    <span class="comment">//	under any of the associations in the FaceEffects field.</span>
    DefaultEffectID string

    <span class="comment">//	Associates certain individual faces or tags of faces</span>
    <span class="comment">//	with specific effect IDs.</span>
    FaceEffects struct {
        <span class="comment">//	Associates face tags with effect IDs.</span>
        ByTag map[string]string

        <span class="comment">//	Associates specific face IDs with effect IDs.</span>
        ByID map[string]string
    }
}</pre>
			<p>
A material binds effects (FxEffect in Core.Libs.Effects) to geometry (Model or Node).
</p>


			

			

			

			
				
				<h3 id="NewFxMaterial">func <a href="/target/fx-material.gt.go?s=805:842#L21">NewFxMaterial</a></h3>
				<pre>func NewFxMaterial() (me *FxMaterial)</pre>
				<p>
Initializes and returns a new FxMaterial with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="LibFxEffects">type <a href="/target/fx-effect.gt.go?s=1713:1751#L53">LibFxEffects</a></h2>
			<pre>type LibFxEffects map[string]*FxEffect</pre>
			<p>
A hash-table of FxEffects associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxEffects.AddNew">func (LibFxEffects) <a href="/target/fx-effect.gt.go?s=1877:1933#L57">AddNew</a></h3>
				<pre>func (me LibFxEffects) AddNew(id string) (obj *FxEffect)</pre>
				<p>
Creates and initializes a new FxEffect with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxEffects.Remove">func (LibFxEffects) <a href="/target/fx-effect.gt.go?s=2132:2172#L74">Remove</a></h3>
				<pre>func (me LibFxEffects) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibFxImage2Ds">type <a href="/target/fx-image-2d.gt.go?s=3399:3439#L147">LibFxImage2Ds</a></h2>
			<pre>type LibFxImage2Ds map[string]*FxImage2D</pre>
			<p>
A hash-table of FxImage2Ds associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxImage2Ds.AddNew">func (LibFxImage2Ds) <a href="/target/fx-image-2d.gt.go?s=3566:3624#L151">AddNew</a></h3>
				<pre>func (me LibFxImage2Ds) AddNew(id string) (obj *FxImage2D)</pre>
				<p>
Creates and initializes a new FxImage2D with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxImage2Ds.Remove">func (LibFxImage2Ds) <a href="/target/fx-image-2d.gt.go?s=3827:3868#L168">Remove</a></h3>
				<pre>func (me LibFxImage2Ds) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibFxMaterials">type <a href="/target/fx-material.gt.go?s=964:1006#L28">LibFxMaterials</a></h2>
			<pre>type LibFxMaterials map[string]*FxMaterial</pre>
			<p>
A hash-table of FxMaterials associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxMaterials.AddNew">func (LibFxMaterials) <a href="/target/fx-material.gt.go?s=1134:1194#L32">AddNew</a></h3>
				<pre>func (me LibFxMaterials) AddNew(id string) (obj *FxMaterial)</pre>
				<p>
Creates and initializes a new FxMaterial with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxMaterials.Remove">func (LibFxMaterials) <a href="/target/fx-material.gt.go?s=1401:1443#L49">Remove</a></h3>
				<pre>func (me LibFxMaterials) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibMeshes">type <a href="/target/mesh.go?s=4639:4670#L121">LibMeshes</a></h2>
			<pre>type LibMeshes map[string]*Mesh</pre>
			<p>
A hash-table of Meshs associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibMeshes.AddLoad">func (LibMeshes) <a href="/target/mesh.go?s=4888:4998#L131">AddLoad</a></h3>
				<pre>func (me LibMeshes) AddLoad(id string, meshProvider MeshProvider, args ...interface{}) (mesh *Mesh, err error)</pre>
				
				
				
			
				
				<h3 id="LibMeshes.AddNew">func (LibMeshes) <a href="/target/mesh.go?s=4792:4841#L125">AddNew</a></h3>
				<pre>func (me LibMeshes) AddNew(id string) (obj *Mesh)</pre>
				<p>
Creates and initializes a new Mesh with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
		
			
			
			<h2 id="LibScenes">type <a href="/target/scene.gt.go?s=676:708#L27">LibScenes</a></h2>
			<pre>type LibScenes map[string]*Scene</pre>
			<p>
A hash-table of Scenes associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibScenes.AddNew">func (LibScenes) <a href="/target/scene.gt.go?s=831:881#L31">AddNew</a></h3>
				<pre>func (me LibScenes) AddNew(id string) (obj *Scene)</pre>
				<p>
Creates and initializes a new Scene with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibScenes.Remove">func (LibScenes) <a href="/target/scene.gt.go?s=1068:1105#L48">Remove</a></h3>
				<pre>func (me LibScenes) Remove(id string)</pre>
				
				
				
			
				
				<h3 id="LibScenes.Walk">func (LibScenes) <a href="/target/scene.gt.go?s=329:373#L11">Walk</a></h3>
				<pre>func (me LibScenes) Walk(onNode func(*Node))</pre>
				
				
				
			
		
			
			
			<h2 id="Mesh">type <a href="/target/mesh.go?s=63:468#L1">Mesh</a></h2>
			<pre>type Mesh struct {
    Models Models
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewMesh">func <a href="/target/mesh.go?s=4489:4523#L114">NewMesh</a></h3>
				<pre>func NewMesh(id string) (me *Mesh)</pre>
				<p>
Initializes and returns a new Mesh with default parameters.
</p>

				
			

			
				
				<h3 id="Mesh.GpuDelete">func (*Mesh) <a href="/target/mesh.go?s=600:627#L16">GpuDelete</a></h3>
				<pre>func (me *Mesh) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUpload">func (*Mesh) <a href="/target/mesh.go?s=678:717#L22">GpuUpload</a></h3>
				<pre>func (me *Mesh) GpuUpload() (err error)</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUploaded">func (*Mesh) <a href="/target/mesh.go?s=2235:2269#L51">GpuUploaded</a></h3>
				<pre>func (me *Mesh) GpuUploaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Load">func (*Mesh) <a href="/target/mesh.go?s=2296:2372#L55">Load</a></h3>
				<pre>func (me *Mesh) Load(provider MeshProvider, args ...interface{}) (err error)</pre>
				
				
				
			
				
				<h3 id="Mesh.Loaded">func (*Mesh) <a href="/target/mesh.go?s=4325:4354#L105">Loaded</a></h3>
				<pre>func (me *Mesh) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Unload">func (*Mesh) <a href="/target/mesh.go?s=4382:4406#L109">Unload</a></h3>
				<pre>func (me *Mesh) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffer">type <a href="/target/mesh-buffer.go?s=1726:2135#L61">MeshBuffer</a></h2>
			<pre>type MeshBuffer struct {
    MemSizeIndices, MemSizeVertices int32
    Params                          *meshBufferParams
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffer.Add">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=3393:3442#L107">Add</a></h3>
				<pre>func (me *MeshBuffer) Add(mesh *Mesh) (err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffer.Remove">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=4190:4230#L137">Remove</a></h3>
				<pre>func (me *MeshBuffer) Remove(mesh *Mesh)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffers">type <a href="/target/mesh-buffer.go?s=363:419#L4">MeshBuffers</a></h2>
			<pre>type MeshBuffers struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffers.Add">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=531:623#L14">Add</a></h3>
				<pre>func (me *MeshBuffers) Add(id string, params *meshBufferParams) (buf *MeshBuffer, err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.FloatsPerVertex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1013:1059#L35">FloatsPerVertex</a></h3>
				<pre>func (me *MeshBuffers) FloatsPerVertex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.MemSizePerIndex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1220:1266#L40">MemSizePerIndex</a></h3>
				<pre>func (me *MeshBuffers) MemSizePerIndex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.MemSizePerVertex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1282:1329#L44">MemSizePerVertex</a></h3>
				<pre>func (me *MeshBuffers) MemSizePerVertex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.NewParams">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1409:1496#L49">NewParams</a></h3>
				<pre>func (me *MeshBuffers) NewParams(numVerts, numIndices int32) (params *meshBufferParams)</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.Remove">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1602:1642#L54">Remove</a></h3>
				<pre>func (me *MeshBuffers) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshData">type <a href="/target/mesh-data.go?s=2089:2315#L78">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">//	Vertex positions</span>
    Positions []MeshVertAtt3

    <span class="comment">//	Vertex texture coordinates</span>
    TexCoords []MeshVertAtt2

    <span class="comment">//	Vertex normals</span>
    Normals []MeshVertAtt3

    <span class="comment">//	Indexed triangle definitions</span>
    Faces []MeshFace3
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="MeshProviderPrefabCube">func <a href="/target/mesh-provider.go?s=306:386#L1">MeshProviderPrefabCube</a></h3>
				<pre>func MeshProviderPrefabCube(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a cube with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 12 triangle faces with IDs &#34;t0&#34; through &#34;t11&#34;.
These faces are classified in 6 distinct tags: &#34;front&#34;,&#34;back&#34;,&#34;top&#34;,&#34;bottom&#34;,&#34;right&#34;,&#34;left&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabPlane">func <a href="/target/mesh-provider.go?s=2237:2318#L19">MeshProviderPrefabPlane</a></h3>
				<pre>func MeshProviderPrefabPlane(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a flat ground plane with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 2 triangle faces with IDs &#34;t0&#34; through &#34;t1&#34;.
These faces are all classified with tag: &#34;plane&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabPyramid">func <a href="/target/mesh-provider.go?s=3080:3163#L34">MeshProviderPrefabPyramid</a></h3>
				<pre>func MeshProviderPrefabPyramid(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a pyramid with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 4 triangle faces with IDs &#34;t0&#34; through &#34;t3&#34;.
These faces are all classified with tag: &#34;pyr&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabQuad">func <a href="/target/mesh-provider.go?s=4177:4257#L51">MeshProviderPrefabQuad</a></h3>
				<pre>func MeshProviderPrefabQuad(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a quad with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 2 triangle faces with IDs &#34;t0&#34; through &#34;t1&#34;.
These faces are all classified with tag: &#34;quad&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabTri">func <a href="/target/mesh-provider.go?s=4954:5033#L65">MeshProviderPrefabTri</a></h3>
				<pre>func MeshProviderPrefabTri(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a triangle with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 1 triangle face with ID &#34;t0&#34; and tag &#34;tri&#34;.
</p>

				
			
				
				<h3 id="NewMeshData">func <a href="/target/mesh-data.go?s=2371:2404#L93">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
				
				<h3 id="MeshData.AddFaces">func (*MeshData) <a href="/target/mesh-data.go?s=2482:2531#L99">AddFaces</a></h3>
				<pre>func (me *MeshData) AddFaces(faces ...*MeshFace3)</pre>
				<p>
Adds all specified Faces to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddNormals">func (*MeshData) <a href="/target/mesh-data.go?s=2819:2874#L111">AddNormals</a></h3>
				<pre>func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</pre>
				<p>
Adds all the specified Normals to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddPositions">func (*MeshData) <a href="/target/mesh-data.go?s=2651:2710#L106">AddPositions</a></h3>
				<pre>func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</pre>
				<p>
Adds all specified Positions to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddTexCoords">func (*MeshData) <a href="/target/mesh-data.go?s=2979:3038#L116">AddTexCoords</a></h3>
				<pre>func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</pre>
				<p>
Adds all the specified TexCoords to this MeshData.
</p>

				
				
			
		
			
			
			<h2 id="MeshFace3">type <a href="/target/mesh-data.go?s=435:553#L11">MeshFace3</a></h2>
			<pre>type MeshFace3 struct {
    <span class="comment">//	The indexed vertices making up this triangle.</span>
    V [3]MeshVert

    <span class="comment">//	ID, Tags</span>
    MeshFaceBase
}</pre>
			<p>
Represents an indexed triangle.
</p>


			

			

			

			
				
				<h3 id="NewMeshFace3">func <a href="/target/mesh-data.go?s=768:837#L22">NewMeshFace3</a></h3>
				<pre>func NewMeshFace3(tags, id string, verts ...MeshVert) (me *MeshFace3)</pre>
				<p>
Creates and initializes a new MeshVert with the specified tags,
ID and verts, and returns it. tags may be empty or contain multiple
classification tags separated by spaces, which will be split into Tags.
</p>

				
			

			
		
			
			
			<h2 id="MeshFaceBase">type <a href="/target/mesh-data.go?s=252:398#L2">MeshFaceBase</a></h2>
			<pre>type MeshFaceBase struct {
    <span class="comment">//	Mesh-unique identifier for this face.</span>
    ID string

    <span class="comment">//	Arbitrary classification tags for this face.</span>
    Tags []string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/mesh-data.go?s=188:250#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Provides MeshData for constructing a Mesh. An implementation
might load a certain file format or procedurally generate
the returned MeshData.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVert">type <a href="/target/mesh-data.go?s=1588:1775#L58">MeshVert</a></h2>
			<pre>type MeshVert struct {
    <span class="comment">//	Index of the vertex position</span>
    PosIndex uint32

    <span class="comment">//	Index of the texture-coordinate.</span>
    TexCoordIndex uint32

    <span class="comment">//	Index of the vertex normal.</span>
    NormalIndex uint32
}</pre>
			<p>
Represents an indexed vertex in a MeshFace3.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt2">type <a href="/target/mesh-data.go?s=1882:1910#L71">MeshVertAtt2</a></h2>
			<pre>type MeshVertAtt2 [2]float32</pre>
			<p>
Represents a 2-component vertex attribute in a MeshData.
(such as for example texture-coordinates)
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt3">type <a href="/target/mesh-data.go?s=2011:2039#L75">MeshVertAtt3</a></h2>
			<pre>type MeshVertAtt3 [3]float32</pre>
			<p>
Represents a 3-component vertex attribute in a MeshData
(such as for example vertex-normals)
</p>


			

			

			

			

			
		
			
			
			<h2 id="Model">type <a href="/target/model.go?s=593:674#L8">Model</a></h2>
			<pre>type Model struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Model is a parameterized instantiation of its parent Mesh geometry
with unique appearance, material or other properties.
</p>
<p>
Each Mesh provides at least one Model, the &#34;default model&#34; (with ID &#34;&#34;),
accessible via someMesh.Models.Default(). To create new models for a Mesh,
call someMesh.Models[&#34;sourceModelID&#34;].Clone(&#34;newModelID&#34;).
</p>


			

			

			

			

			
				
				<h3 id="Model.Clone">func (*Model) <a href="/target/model.go?s=881:943#L22">Clone</a></h3>
				<pre>func (me *Model) Clone(newModelID string) (clonedModel *Model)</pre>
				<p>
Creates a copy of me and adds it to the parent Mesh&#39;s Models
hash-table under the specified newModelID.
</p>

				
				
			
				
				<h3 id="Model.MatID">func (*Model) <a href="/target/model.go?s=1116:1147#L30">MatID</a></h3>
				<pre>func (me *Model) MatID() string</pre>
				
				
				
			
				
				<h3 id="Model.SetMatID">func (*Model) <a href="/target/model.go?s=1170:1212#L34">SetMatID</a></h3>
				<pre>func (me *Model) SetMatID(newMatID string)</pre>
				
				
				
			
		
			
			
			<h2 id="Models">type <a href="/target/model.go?s=96:125#L1">Models</a></h2>
			<pre>type Models map[string]*Model</pre>
			<p>
A hash-table of Models associated with their ID.
Used only for Mesh.Models.
</p>


			

			

			

			

			
				
				<h3 id="Models.Default">func (Models) <a href="/target/model.go?s=190:223#L1">Default</a></h3>
				<pre>func (me Models) Default() *Model</pre>
				<p>
Returns the default Model (with ID &#34;&#34;) for the parent Mesh.
</p>

				
				
			
		
			
			
			<h2 id="Node">type <a href="/target/node.go?s=241:1114#L3">Node</a></h2>
			<pre>type Node struct {
    <span class="comment">//	Defaults to true. If false, this Node is ignored by the rendering runtime.</span>
    Enabled bool

    <span class="comment">//	Allows the Node to recursively define hierarchy.</span>
    ChildNodes Nodes

    <span class="comment">//	Encapsulates all parent-relative transformations for this Node.</span>
    Transform NodeTransform
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Declares a point of interest in a Scene.
</p>


			

			

			

			

			
				
				<h3 id="Node.EffectiveMaterial">func (*Node) <a href="/target/node.go?s=1384:1431#L48">EffectiveMaterial</a></h3>
				<pre>func (me *Node) EffectiveMaterial() *FxMaterial</pre>
				
				
				
			
				
				<h3 id="Node.MatID">func (*Node) <a href="/target/node.go?s=1871:1901#L68">MatID</a></h3>
				<pre>func (me *Node) MatID() string</pre>
				
				
				
			
				
				<h3 id="Node.MeshID">func (*Node) <a href="/target/node.go?s=1924:1955#L72">MeshID</a></h3>
				<pre>func (me *Node) MeshID() string</pre>
				
				
				
			
				
				<h3 id="Node.ModelID">func (*Node) <a href="/target/node.go?s=1979:2011#L76">ModelID</a></h3>
				<pre>func (me *Node) ModelID() string</pre>
				
				
				
			
				
				<h3 id="Node.Root">func (*Node) <a href="/target/node.go?s=2036:2071#L80">Root</a></h3>
				<pre>func (me *Node) Root() (root *Node)</pre>
				
				
				
			
				
				<h3 id="Node.SetMatID">func (*Node) <a href="/target/node.go?s=2167:2208#L89">SetMatID</a></h3>
				<pre>func (me *Node) SetMatID(newMatID string)</pre>
				
				
				
			
				
				<h3 id="Node.SetMeshModelID">func (*Node) <a href="/target/node.go?s=2305:2359#L95">SetMeshModelID</a></h3>
				<pre>func (me *Node) SetMeshModelID(meshID, modelID string)</pre>
				
				
				
			
				
				<h3 id="Node.Walk">func (*Node) <a href="/target/node.go?s=2663:2703#L109">Walk</a></h3>
				<pre>func (me *Node) Walk(onNode func(*Node))</pre>
				
				
				
			
		
			
			
			<h2 id="NodeTransform">type <a href="/target/node-transform.go?s=487:837#L4">NodeTransform</a></h2>
			<pre>type NodeTransform struct {
    <span class="comment">//	Translation of the from origin.</span>
    Pos unum.Vec3

    <span class="comment">//	Rotation for each axis in radians.</span>
    Rot unum.Vec3

    <span class="comment">//	Scaling of this node, if any. Defaults to (1, 1, 1) for no scaling.</span>
    Scale unum.Vec3

    <span class="comment">//	An arbitrary additional transformation to apply, if any.</span>
    Other *unum.Mat4
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents one or more transformations of a Node.
This is only used by Node objects, which initialize their NodeTransform with the
proper defaults and associate themselves with their NodeTransform. (Any other
NodeTransform are invalid.)
</p>
<p>
A single NodeTransform encapsulates an unexported 4x4 matrix that is recalculated
from its exported fields via the AddFoo(), SetFoo() or ApplyMatrices() methods.
</p>


			

			

			

			

			
				
				<h3 id="NodeTransform.AddRot">func (*NodeTransform) <a href="/target/node-transform.go?s=1065:1112#L29">AddRot</a></h3>
				<pre>func (me *NodeTransform) AddRot(rot *unum.Vec3)</pre>
				<p>
Adds the specified vector to me.Rot and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.AddRotXYZ">func (*NodeTransform) <a href="/target/node-transform.go?s=1221:1272#L35">AddRotXYZ</a></h3>
				<pre>func (me *NodeTransform) AddRotXYZ(x, y, z float64)</pre>
				<p>
Adds the specified values to me.Rot and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.ApplyMatrices">func (*NodeTransform) <a href="/target/node-transform.go?s=1466:1506#L42">ApplyMatrices</a></h3>
				<pre>func (me *NodeTransform) ApplyMatrices()</pre>
				<p>
Updates the internal 4x4 transformation matrix for all transformations
in me. It is only this matrix that is used by the rendering runtime.
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPos">func (*NodeTransform) <a href="/target/node-transform.go?s=2336:2383#L60">SetPos</a></h3>
				<pre>func (me *NodeTransform) SetPos(pos *unum.Vec3)</pre>
				<p>
Sets me.Pos and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPosX">func (*NodeTransform) <a href="/target/node-transform.go?s=2468:2514#L66">SetPosX</a></h3>
				<pre>func (me *NodeTransform) SetPosX(posX float64)</pre>
				<p>
Sets me.Pos.X and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPosXYZ">func (*NodeTransform) <a href="/target/node-transform.go?s=2599:2659#L72">SetPosXYZ</a></h3>
				<pre>func (me *NodeTransform) SetPosXYZ(posX, posY, posZ float64)</pre>
				<p>
Sets me.Pos and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPosY">func (*NodeTransform) <a href="/target/node-transform.go?s=2778:2824#L78">SetPosY</a></h3>
				<pre>func (me *NodeTransform) SetPosY(posY float64)</pre>
				<p>
Sets me.Pos.Y and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPosZ">func (*NodeTransform) <a href="/target/node-transform.go?s=2911:2957#L84">SetPosZ</a></h3>
				<pre>func (me *NodeTransform) SetPosZ(posZ float64)</pre>
				<p>
Sets me.Pos.Z and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRot">func (*NodeTransform) <a href="/target/node-transform.go?s=3042:3089#L90">SetRot</a></h3>
				<pre>func (me *NodeTransform) SetRot(rot *unum.Vec3)</pre>
				<p>
Sets me.Rot and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRotX">func (*NodeTransform) <a href="/target/node-transform.go?s=3174:3219#L96">SetRotX</a></h3>
				<pre>func (me *NodeTransform) SetRotX(rad float64)</pre>
				<p>
Sets me.Rot.X and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRotXYZ">func (*NodeTransform) <a href="/target/node-transform.go?s=3303:3363#L102">SetRotXYZ</a></h3>
				<pre>func (me *NodeTransform) SetRotXYZ(radX, radY, radZ float64)</pre>
				<p>
Sets me.Rot and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRotY">func (*NodeTransform) <a href="/target/node-transform.go?s=3482:3527#L108">SetRotY</a></h3>
				<pre>func (me *NodeTransform) SetRotY(rad float64)</pre>
				<p>
Sets me.Rot.Y and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRotZ">func (*NodeTransform) <a href="/target/node-transform.go?s=3613:3658#L114">SetRotZ</a></h3>
				<pre>func (me *NodeTransform) SetRotZ(rad float64)</pre>
				<p>
Sets me.Rot.Z and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetScale">func (*NodeTransform) <a href="/target/node-transform.go?s=3744:3795#L120">SetScale</a></h3>
				<pre>func (me *NodeTransform) SetScale(scale *unum.Vec3)</pre>
				<p>
Sets me.Scale and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetScaleN">func (*NodeTransform) <a href="/target/node-transform.go?s=3884:3933#L126">SetScaleN</a></h3>
				<pre>func (me *NodeTransform) SetScaleN(scale float64)</pre>
				<p>
Sets me.Scale and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetScaleXYZ">func (*NodeTransform) <a href="/target/node-transform.go?s=4020:4073#L131">SetScaleXYZ</a></h3>
				<pre>func (me *NodeTransform) SetScaleXYZ(x, y, z float64)</pre>
				<p>
Sets me.Scale and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.StepDelta">func (*NodeTransform) <a href="/target/node-transform.go?s=4224:4290#L137">StepDelta</a></h3>
				<pre>func (me *NodeTransform) StepDelta(deltaPerSecond float64) float64</pre>
				<p>
Returns the result of multiplying deltaPerSecond with EngineLoop.TickDelta.
</p>

				
				
			
		
			
			
			<h2 id="Nodes">type <a href="/target/nodes.go?s=77:277#L1">Nodes</a></h2>
			<pre>type Nodes struct {
    <span class="comment">//	The underlying hash-table. NOT to be modified directly.</span>
    <span class="comment">//	ONLY use the methods defined on the Nodes type to add,</span>
    <span class="comment">//	remove or move nodes.</span>
    M map[string]*Node
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A hash-table of child nodes. Only used for Node.ChildNodes.
</p>


			

			

			

			

			
				
				<h3 id="Nodes.Add">func (*Nodes) <a href="/target/nodes.go?s=456:488#L10">Add</a></h3>
				<pre>func (me *Nodes) Add(node *Node)</pre>
				<p>
Removes node from its previous parent Node (if any)
and adds it to me.M under its ID.
</p>

				
				
			
				
				<h3 id="Nodes.AddNew">func (*Nodes) <a href="/target/nodes.go?s=743:807#L20">AddNew</a></h3>
				<pre>func (me *Nodes) AddNew(id, meshID, modelID string) (node *Node)</pre>
				<p>
Creates a new Node with the specified ID, binds it to the
specified Mesh and Model, adds it to me.M and returns it.
</p>

				
				
			
				
				<h3 id="Nodes.Remove">func (*Nodes) <a href="/target/nodes.go?s=955:989#L27">Remove</a></h3>
				<pre>func (me *Nodes) Remove(id string)</pre>
				<p>
Removes the Node with the specified ID from me.M.
</p>

				
				
			
		
			
			
			<h2 id="PostFx">type <a href="/target/postfx.go?s=548:709#L11">PostFx</a></h2>
			<pre>type PostFx struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ONLY used for Core.Rendering.PostFx.
Represents the final shading stage in a rendered frame and is always used, but initially all effects are disabled.
Always takes the image produced by the Core.Rendering.Canvases.Main render canvas and blits it to the screen,
applying the currently enabled effects, if any.
</p>


			

			

			

			

			
				
				<h3 id="PostFx.ApplyEffects">func (*PostFx) <a href="/target/postfx.go?s=1058:1102#L25">ApplyEffects</a></h3>
				<pre>func (me *PostFx) ApplyEffects() (err error)</pre>
				<p>
Switches me to a postfx shader program that has all effects enabled as specified
by all previous DisableEffect() / EnableEffect() / ToggleEffect() calls since the last ApplyEffects() call.
If that shader program does not yet exist, builds it. If that fails, a non-nil err is returned.
</p>

				
				
			
				
				<h3 id="PostFx.DisableEffect">func (*PostFx) <a href="/target/postfx.go?s=1850:1894#L52">DisableEffect</a></h3>
				<pre>func (me *PostFx) DisableEffect(name string)</pre>
				<p>
Deactivates the specified post-processing full-screen effect.
After all necessary calls to DisableEffect() / EnableEffect() / ToggleEffect(), be sure to call ApplyEffects() once.
</p>

				
				
			
				
				<h3 id="PostFx.EnableEffect">func (*PostFx) <a href="/target/postfx.go?s=2109:2175#L58">EnableEffect</a></h3>
				<pre>func (me *PostFx) EnableEffect(name string) (effect *PostFxEffect)</pre>
				<p>
Activates the specified post-processing full-screen effect.
After all necessary calls to DisableEffect() / EnableEffect() / ToggleEffect(), be sure to call ApplyEffects() once.
</p>

				
				
			
				
				<h3 id="PostFx.ToggleEffect">func (*PostFx) <a href="/target/postfx.go?s=2838:2896#L80">ToggleEffect</a></h3>
				<pre>func (me *PostFx) ToggleEffect(name string) (enabled bool)</pre>
				<p>
Activates or deactivates the specified post-processing full-screen effect.
After all necessary calls to DisableEffect() / EnableEffect() / ToggleEffect(), be sure to call ApplyEffects() once.
Returns whether this call has activated (true) or deactivated (false) the specified effect.
</p>

				
				
			
		
			
			
			<h2 id="PostFxEffect">type <a href="/target/postfx.go?s=154:224#L3">PostFxEffect</a></h2>
			<pre>type PostFxEffect struct {
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderCanvas">type <a href="/target/render-canvas.go?s=216:741#L5">RenderCanvas</a></h2>
			<pre>type RenderCanvas struct {
    <span class="comment">//	This should be an non-negative integer, it&#39;s a float64 just to avoid a</span>
    <span class="comment">//	type conversion. How often this RenderCanvas is included in rendering:</span>
    <span class="comment">//	1 = every frame (this is the default value)</span>
    <span class="comment">//	2 = every 2nd frame</span>
    <span class="comment">//	3, 5, 8 etc. = every 3rd, 5th, 8th etc. frame</span>
    <span class="comment">//	0 = this RenderCanvas is disabled for rendering</span>
    EveryNthFrame float64

    Cameras Cameras
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents a surface (texture framebuffer) that can be rendered to.
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvas.AddNewCamera2D">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1299:1371#L34">AddNewCamera2D</a></h3>
				<pre>func (me *RenderCanvas) AddNewCamera2D(allowOverlaps bool) (cam *Camera)</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.AddNewCamera3D">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1461:1515#L40">AddNewCamera3D</a></h3>
				<pre>func (me *RenderCanvas) AddNewCamera3D() (cam *Camera)</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.Main">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1873:1908#L52">Main</a></h3>
				<pre>func (me *RenderCanvas) Main() bool</pre>
				<p>
Returns whether me is the primary / &#34;main&#34; render canvas (if multiple render canvases are present).
The &#34;main&#34; render canvas is the one whose output image is blitted to the screen / window by Core.Rendering.PostFx.
</p>

				
				
			
				
				<h3 id="RenderCanvas.Remove">func (*RenderCanvas) <a href="/target/render-canvas.go?s=2432:2464#L69">Remove</a></h3>
				<pre>func (me *RenderCanvas) Remove()</pre>
				<p>
Removes me from Core.Rendering.Canvases and deletes its associated GPU resources.
This renders me invalid for further use.
</p>

				
				
			
				
				<h3 id="RenderCanvas.SetMain">func (*RenderCanvas) <a href="/target/render-canvas.go?s=3037:3070#L86">SetMain</a></h3>
				<pre>func (me *RenderCanvas) SetMain()</pre>
				<p>
Declares me the primary / &#34;main&#34; render canvas (if multiple render canvases are present).
The &#34;main&#34; render canvas is the one whose output image is blitted to the screen / window by Core.Rendering.PostFx.
</p>

				
				
			
				
				<h3 id="RenderCanvas.SetSize">func (*RenderCanvas) <a href="/target/render-canvas.go?s=3457:3526#L97">SetSize</a></h3>
				<pre>func (me *RenderCanvas) SetSize(relative bool, width, height float64)</pre>
				<p>
Sets the 2 dimensions of this render canvas.
If relative is true, width and height are interpreted relative to the resolution of the OpenGL context&#39;s default framebuffer, with 1 being 100%.
Otherwise, width and height are absolute pixel dimensions.
</p>

				
				
			
		
			
			
			<h2 id="RenderCanvases">type <a href="/target/render-canvas.go?s=3759:3794#L106">RenderCanvases</a></h2>
			<pre>type RenderCanvases []*RenderCanvas</pre>
			<p>
Only used for Core.Rendering.Canvases.
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvases.AddNew">func (*RenderCanvases) <a href="/target/render-canvas.go?s=4022:4124#L117">AddNew</a></h3>
				<pre>func (me *RenderCanvases) AddNew(isMain bool, relative bool, width, height float64) (rc *RenderCanvas)</pre>
				<p>
Adds a new RenderCanvas and returns it.
The relative, width and height values are passed to a call to SetSize().
</p>

				
				
			
				
				<h3 id="RenderCanvases.Main">func (RenderCanvases) <a href="/target/render-canvas.go?s=4574:4626#L131">Main</a></h3>
				<pre>func (me RenderCanvases) Main() (main *RenderCanvas)</pre>
				<p>
Returns whatever RenderCanvas in me is currently declared the primary / &#34;main&#34; render canvas (if multiple render canvases are present).
The &#34;main&#34; render canvas is the one whose output image is blitted to the screen / window by Core.Rendering.PostFx.
</p>

				
				
			
				
				<h3 id="RenderCanvases.Walk">func (RenderCanvases) <a href="/target/render-canvas.go?s=4721:4771#L141">Walk</a></h3>
				<pre>func (me RenderCanvases) Walk(onCam func(*Camera))</pre>
				
				
				
			
		
			
			
			<h2 id="Scene">type <a href="/target/scene.gt.go?s=43:119#L1">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	The root Node for this scene graph.</span>
    RootNode Node
}</pre>
			<p>
Represents a scene graph.
</p>


			

			

			

			
				
				<h3 id="NewScene">func <a href="/target/scene.gt.go?s=537:564#L20">NewScene</a></h3>
				<pre>func NewScene() (me *Scene)</pre>
				<p>
Initializes and returns a new Scene with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="TimingStats">type <a href="/target/ng-stats.go?s=4086:4258#L83">TimingStats</a></h2>
			<pre>type TimingStats struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Helps track average and maximum cost for a variety of performance indicators.
</p>


			

			

			

			

			
				
				<h3 id="TimingStats.Average">func (*TimingStats) <a href="/target/ng-stats.go?s=4327:4367#L89">Average</a></h3>
				<pre>func (me *TimingStats) Average() float64</pre>
				<p>
Returns the average cost tracked by this performance indicator.
</p>

				
				
			
				
				<h3 id="TimingStats.Max">func (*TimingStats) <a href="/target/ng-stats.go?s=5011:5047#L116">Max</a></h3>
				<pre>func (me *TimingStats) Max() float64</pre>
				<p>
Returns the maximum cost tracked by this performance indicator.
</p>

				
				
			
		
		</div>
	

	








		</div></div>
	</body>
</html>