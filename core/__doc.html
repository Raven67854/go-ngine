<html>
	<head>
		<title>Package github.com/go3d/go-ngine/core</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/core</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/core"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *core* package provides go:ngine client-side core functionality such as rendering and user I/O.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Dispose">func Dispose()</a></dd>
			
				
				<dd><a href="#Init">func Init(fullscreen bool) (err error)</a></dd>
			
			
				
				<dd><a href="#Camera">type Camera</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.ApplyMatrices">func (me *Camera) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.RenderTechniqueQuad">func (me *Camera) RenderTechniqueQuad() (tech *RenderTechniqueQuad)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.RenderTechniqueScene">func (me *Camera) RenderTechniqueScene() (tech *RenderTechniqueScene)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.Scene">func (me *Camera) Scene() *Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Camera.SetScene">func (me *Camera) SetScene(id string)</a></dd>
				
			
				
				<dd><a href="#CameraPerspective">type CameraPerspective</a></dd>
				
				
			
				
				<dd><a href="#CameraViewport">type CameraViewport</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewport.SetAbs">func (me *CameraViewport) SetAbs(x, y, width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraViewport.SetRel">func (me *CameraViewport) SetRel(x, y, width, height float64)</a></dd>
				
			
				
				<dd><a href="#Cameras">type Cameras</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Cameras.Remove">func (me *Cameras) Remove(camera *Camera)</a></dd>
				
			
				
				<dd><a href="#Controller">type Controller</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.BeginUpdate">func (me *Controller) BeginUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.CopyFrom">func (me *Controller) CopyFrom(ctl *Controller)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.Dir">func (me *Controller) Dir() *unum.Vec3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.EndUpdate">func (me *Controller) EndUpdate()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveBackward">func (me *Controller) MoveBackward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveDown">func (me *Controller) MoveDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveForward">func (me *Controller) MoveForward()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveLeft">func (me *Controller) MoveLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveRight">func (me *Controller) MoveRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.MoveUp">func (me *Controller) MoveUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeMove">func (me *Controller) StepSizeMove() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.StepSizeTurn">func (me *Controller) StepSizeTurn() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDown">func (me *Controller) TurnDown()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnDownBy">func (me *Controller) TurnDownBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeft">func (me *Controller) TurnLeft()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnLeftBy">func (me *Controller) TurnLeftBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRight">func (me *Controller) TurnRight()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnRightBy">func (me *Controller) TurnRightBy(deg float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUp">func (me *Controller) TurnUp()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Controller.TurnUpBy">func (me *Controller) TurnUpBy(deg float64)</a></dd>
				
			
				
				<dd><a href="#ControllerParams">type ControllerParams</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerParams">func NewControllerParams() (me *ControllerParams)</a></dd>
				
				
			
				
				<dd><a href="#EngineCore">type EngineCore</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineCore.GpuSyncImageLibs">func (_ *EngineCore) GpuSyncImageLibs() (err error)</a></dd>
				
			
				
				<dd><a href="#EngineDiag">type EngineDiag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.Log">func (_ *EngineDiag) Log(cat EngineDiagLogCategory, fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogErr">func (_ *EngineDiag) LogErr(err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogIfGlErr">func (_ *EngineDiag) LogIfGlErr(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogImages">func (_ *EngineDiag) LogImages(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogMeshes">func (_ *EngineDiag) LogMeshes(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogMisc">func (_ *EngineDiag) LogMisc(fmt string, fmtArgs ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineDiag.LogShaders">func (_ *EngineDiag) LogShaders(fmt string, fmtArgs ...interface{})</a></dd>
				
			
				
				<dd><a href="#EngineDiagLogCategory">type EngineDiagLogCategory</a></dd>
				
				
			
				
				<dd><a href="#EngineLoop">type EngineLoop</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Run">func (_ *EngineLoop) Run()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineLoop.Time">func (_ *EngineLoop) Time() float64</a></dd>
				
			
				
				<dd><a href="#EngineOptions">type EngineOptions</a></dd>
				
				
			
				
				<dd><a href="#EngineStats">type EngineStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.AverageFps">func (_ *EngineStats) AverageFps() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineStats.TotalFrames">func (_ *EngineStats) TotalFrames() float64</a></dd>
				
			
				
				<dd><a href="#EngineUserIO">type EngineUserIO</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.IifKeyF">func (_ *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressed">func (_ *EngineUserIO) KeyPressed(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyPressedWhich">func (_ *EngineUserIO) KeyPressedWhich(keys ...int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeyToggled">func (_ *EngineUserIO) KeyToggled(key int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll2">func (_ *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAll3">func (_ *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny2">func (_ *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EngineUserIO.KeysPressedAny3">func (_ *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</a></dd>
				
			
				
				<dd><a href="#FxEffect">type FxEffect</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxEffect">func NewFxEffect() (me *FxEffect)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffect.UpdateRoutine">func (me *FxEffect) UpdateRoutine()</a></dd>
				
			
				
				<dd><a href="#FxImage">type FxImage</a></dd>
				
				
			
				
				<dd><a href="#FxImage2D">type FxImage2D</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxImage2D">func NewFxImage2D() (me *FxImage2D)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.GpuSync">func (me *FxImage2D) GpuSync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Load">func (me *FxImage2D) Load() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Loaded">func (me *FxImage2D) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImage2D.Unload">func (me *FxImage2D) Unload()</a></dd>
				
			
				
				<dd><a href="#FxImageBase">type FxImageBase</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.GpuDelete">func (me *FxImageBase) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.GpuSynced">func (me *FxImageBase) GpuSynced() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageBase.NoAutoMips">func (me *FxImageBase) NoAutoMips()</a></dd>
				
			
				
				<dd><a href="#FxImageCube">type FxImageCube</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxImageCube">func NewFxImageCube() (me *FxImageCube)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.GpuSync">func (me *FxImageCube) GpuSync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.Load">func (me *FxImageCube) Load() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.Loaded">func (me *FxImageCube) Loaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageCube.Unload">func (me *FxImageCube) Unload()</a></dd>
				
			
				
				<dd><a href="#FxImageInitFrom">type FxImageInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxImageStorage">type FxImageStorage</a></dd>
				
				
			
				
				<dd><a href="#FxMaterial">type FxMaterial</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxMaterial">func NewFxMaterial() (me *FxMaterial)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterial.HasFaceEffects">func (me *FxMaterial) HasFaceEffects() bool</a></dd>
				
			
				
				<dd><a href="#FxOp">type FxOp</a></dd>
				
				
			
				
				<dd><a href="#FxOpColor">type FxOpColor</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.Disable">func (me *FxOpColor) Disable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.Disabled">func (me *FxOpColor) Disabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.Enable">func (me *FxOpColor) Enable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.Enabled">func (me *FxOpColor) Enabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.ProcID">func (me *FxOpColor) ProcID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.ProcIndex">func (me *FxOpColor) ProcIndex() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.SetMixWeight">func (me *FxOpColor) SetMixWeight(weight float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.SetRgb">func (me *FxOpColor) SetRgb(rgb ...gl.Float) *FxOpColor</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpColor.Toggle">func (me *FxOpColor) Toggle()</a></dd>
				
			
				
				<dd><a href="#FxOpCoords">type FxOpCoords</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpCoords.Disable">func (me *FxOpCoords) Disable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpCoords.Disabled">func (me *FxOpCoords) Disabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpCoords.Enable">func (me *FxOpCoords) Enable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpCoords.Enabled">func (me *FxOpCoords) Enabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpCoords.ProcID">func (me *FxOpCoords) ProcID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpCoords.ProcIndex">func (me *FxOpCoords) ProcIndex() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpCoords.SetMixWeight">func (me *FxOpCoords) SetMixWeight(weight float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpCoords.Toggle">func (me *FxOpCoords) Toggle()</a></dd>
				
			
				
				<dd><a href="#FxOpGamma">type FxOpGamma</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGamma.Disable">func (me *FxOpGamma) Disable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGamma.Disabled">func (me *FxOpGamma) Disabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGamma.Enable">func (me *FxOpGamma) Enable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGamma.Enabled">func (me *FxOpGamma) Enabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGamma.ProcID">func (me *FxOpGamma) ProcID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGamma.ProcIndex">func (me *FxOpGamma) ProcIndex() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGamma.SetMixWeight">func (me *FxOpGamma) SetMixWeight(weight float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGamma.Toggle">func (me *FxOpGamma) Toggle()</a></dd>
				
			
				
				<dd><a href="#FxOpGrayscale">type FxOpGrayscale</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGrayscale.Disable">func (me *FxOpGrayscale) Disable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGrayscale.Disabled">func (me *FxOpGrayscale) Disabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGrayscale.Enable">func (me *FxOpGrayscale) Enable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGrayscale.Enabled">func (me *FxOpGrayscale) Enabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGrayscale.ProcID">func (me *FxOpGrayscale) ProcID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGrayscale.ProcIndex">func (me *FxOpGrayscale) ProcIndex() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGrayscale.SetMixWeight">func (me *FxOpGrayscale) SetMixWeight(weight float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpGrayscale.Toggle">func (me *FxOpGrayscale) Toggle()</a></dd>
				
			
				
				<dd><a href="#FxOpOrangify">type FxOpOrangify</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpOrangify.Disable">func (me *FxOpOrangify) Disable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpOrangify.Disabled">func (me *FxOpOrangify) Disabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpOrangify.Enable">func (me *FxOpOrangify) Enable()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpOrangify.Enabled">func (me *FxOpOrangify) Enabled() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpOrangify.ProcID">func (me *FxOpOrangify) ProcID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpOrangify.ProcIndex">func (me *FxOpOrangify) ProcIndex() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpOrangify.SetMixWeight">func (me *FxOpOrangify) SetMixWeight(weight float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpOrangify.Toggle">func (me *FxOpOrangify) Toggle()</a></dd>
				
			
				
				<dd><a href="#FxOpTex2D">type FxOpTex2D</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpTex2D.SetImageID">func (me *FxOpTex2D) SetImageID(imageID string) *FxOpTex2D</a></dd>
				
			
				
				<dd><a href="#FxOpTexCube">type FxOpTexCube</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOpTexCube.SetImageID">func (me *FxOpTexCube) SetImageID(imageID string)</a></dd>
				
			
				
				<dd><a href="#FxOps">type FxOps</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.Disable">func (me FxOps) Disable(procID string, n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.DisableColor">func (me FxOps) DisableColor(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.DisableCoords">func (me FxOps) DisableCoords(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.DisableGamma">func (me FxOps) DisableGamma(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.DisableGrayscale">func (me FxOps) DisableGrayscale(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.DisableOrangify">func (me FxOps) DisableOrangify(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.DisableTex2D">func (me FxOps) DisableTex2D(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.DisableTexCube">func (me FxOps) DisableTexCube(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.Enable">func (me *FxOps) Enable(procID string, n int) (fxOp FxOp)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.EnableColor">func (me *FxOps) EnableColor(n int) *FxOpColor</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.EnableCoords">func (me *FxOps) EnableCoords(n int) *FxOpCoords</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.EnableGamma">func (me *FxOps) EnableGamma(n int) *FxOpGamma</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.EnableGrayscale">func (me *FxOps) EnableGrayscale(n int) *FxOpGrayscale</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.EnableOrangify">func (me *FxOps) EnableOrangify(n int) *FxOpOrangify</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.EnableTex2D">func (me *FxOps) EnableTex2D(n int) *FxOpTex2D</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.EnableTexCube">func (me *FxOps) EnableTexCube(n int) *FxOpTexCube</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.Get">func (me FxOps) Get(procID string, n int) (op FxOp)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.GetColor">func (me FxOps) GetColor(n int) (op *FxOpColor)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.GetCoords">func (me FxOps) GetCoords(n int) (op *FxOpCoords)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.GetGamma">func (me FxOps) GetGamma(n int) (op *FxOpGamma)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.GetGrayscale">func (me FxOps) GetGrayscale(n int) (op *FxOpGrayscale)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.GetOrangify">func (me FxOps) GetOrangify(n int) (op *FxOpOrangify)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.GetTex2D">func (me FxOps) GetTex2D(n int) (op *FxOpTex2D)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.GetTexCube">func (me FxOps) GetTexCube(n int) (op *FxOpTexCube)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.Toggle">func (me *FxOps) Toggle(procID string, n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.ToggleColor">func (me *FxOps) ToggleColor(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.ToggleCoords">func (me *FxOps) ToggleCoords(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.ToggleGamma">func (me *FxOps) ToggleGamma(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.ToggleGrayscale">func (me *FxOps) ToggleGrayscale(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.ToggleOrangify">func (me *FxOps) ToggleOrangify(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.ToggleTex2D">func (me *FxOps) ToggleTex2D(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxOps.ToggleTexCube">func (me *FxOps) ToggleTexCube(n int)</a></dd>
				
			
				
				<dd><a href="#LibFxEffects">type LibFxEffects</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffects.AddNew">func (me LibFxEffects) AddNew(id string) (obj *FxEffect)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffects.Remove">func (me LibFxEffects) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibFxImage2Ds">type LibFxImage2Ds</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImage2Ds.AddNew">func (me LibFxImage2Ds) AddNew(id string) (obj *FxImage2D)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImage2Ds.Remove">func (me LibFxImage2Ds) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibFxImageCubes">type LibFxImageCubes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageCubes.AddNew">func (me LibFxImageCubes) AddNew(id string) (obj *FxImageCube)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageCubes.Remove">func (me LibFxImageCubes) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibFxMaterials">type LibFxMaterials</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterials.AddNew">func (me LibFxMaterials) AddNew(id string) (obj *FxMaterial)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterials.Remove">func (me LibFxMaterials) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#LibMeshes">type LibMeshes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMeshes.AddLoad">func (me LibMeshes) AddLoad(id string, meshProvider MeshProvider, args ...interface{}) (mesh *Mesh, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMeshes.AddNew">func (me LibMeshes) AddNew(id string) (obj *Mesh)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMeshes.GpuSync">func (me LibMeshes) GpuSync() (err error)</a></dd>
				
			
				
				<dd><a href="#LibScenes">type LibScenes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibScenes.AddNew">func (me LibScenes) AddNew(id string) (obj *Scene)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibScenes.Remove">func (me LibScenes) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibScenes.Walk">func (me LibScenes) Walk(onNode NodeVisitor)</a></dd>
				
			
				
				<dd><a href="#Mesh">type Mesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMesh">func NewMesh(id string) (me *Mesh)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuDelete">func (me *Mesh) GpuDelete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUpload">func (me *Mesh) GpuUpload() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.GpuUploaded">func (me *Mesh) GpuUploaded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Load">func (me *Mesh) Load(provider MeshProvider, args ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Mesh.Loaded">func (me *Mesh) Loaded() bool</a></dd>
				
			
				
				<dd><a href="#MeshBuffer">type MeshBuffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Add">func (me *MeshBuffer) Add(mesh *Mesh) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffer.Remove">func (me *MeshBuffer) Remove(mesh *Mesh)</a></dd>
				
			
				
				<dd><a href="#MeshBuffers">type MeshBuffers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.Add">func (me *MeshBuffers) Add(id string, params *meshBufferParams) (buf *MeshBuffer, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.FloatsPerVertex">func (me *MeshBuffers) FloatsPerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.MemSizePerIndex">func (me *MeshBuffers) MemSizePerIndex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.MemSizePerVertex">func (me *MeshBuffers) MemSizePerVertex() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.NewParams">func (me *MeshBuffers) NewParams(numVerts, numIndices int32) (params *meshBufferParams)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshBuffers.Remove">func (me *MeshBuffers) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabCube">func MeshProviderPrefabCube(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabPlane">func MeshProviderPrefabPlane(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabPyramid">func MeshProviderPrefabPyramid(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabQuad">func MeshProviderPrefabQuad(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshProviderPrefabTri">func MeshProviderPrefabTri(args ...interface{}) (meshData *MeshData, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddFaces">func (me *MeshData) AddFaces(faces ...*MeshF3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddNormals">func (me *MeshData) AddNormals(normals ...MeshVA3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddPositions">func (me *MeshData) AddPositions(positions ...MeshVA3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddTexCoords">func (me *MeshData) AddTexCoords(texCoords ...MeshVA2)</a></dd>
				
			
				
				<dd><a href="#MeshF3">type MeshF3</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshF3">func NewMeshF3(tags, id string, verts ...MeshV) (me *MeshF3)</a></dd>
				
				
			
				
				<dd><a href="#MeshFaceBase">type MeshFaceBase</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#MeshV">type MeshV</a></dd>
				
				
			
				
				<dd><a href="#MeshVA2">type MeshVA2</a></dd>
				
				
			
				
				<dd><a href="#MeshVA3">type MeshVA3</a></dd>
				
				
			
				
				<dd><a href="#Model">type Model</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.Clone">func (me *Model) Clone(newModelID string) (clonedModel *Model)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.MatID">func (me *Model) MatID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Model.SetMatID">func (me *Model) SetMatID(newMatID string)</a></dd>
				
			
				
				<dd><a href="#Models">type Models</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Models.Default">func (me Models) Default() *Model</a></dd>
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.EffectiveMaterial">func (me *Node) EffectiveMaterial() *FxMaterial</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MatID">func (me *Node) MatID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.MeshID">func (me *Node) MeshID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.ModelID">func (me *Node) ModelID() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.Root">func (me *Node) Root() (root *Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMatID">func (me *Node) SetMatID(newMatID string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.SetMeshModelID">func (me *Node) SetMeshModelID(meshID, modelID string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Node.Walk">func (me *Node) Walk(onNode NodeVisitor)</a></dd>
				
			
				
				<dd><a href="#NodeTransform">type NodeTransform</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.AddRot">func (me *NodeTransform) AddRot(rot *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.AddRotXYZ">func (me *NodeTransform) AddRotXYZ(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.ApplyMatrices">func (me *NodeTransform) ApplyMatrices()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPos">func (me *NodeTransform) SetPos(pos *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPosX">func (me *NodeTransform) SetPosX(posX float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPosXYZ">func (me *NodeTransform) SetPosXYZ(posX, posY, posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPosY">func (me *NodeTransform) SetPosY(posY float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetPosZ">func (me *NodeTransform) SetPosZ(posZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRot">func (me *NodeTransform) SetRot(rot *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRotX">func (me *NodeTransform) SetRotX(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRotXYZ">func (me *NodeTransform) SetRotXYZ(radX, radY, radZ float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRotY">func (me *NodeTransform) SetRotY(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetRotZ">func (me *NodeTransform) SetRotZ(rad float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetScale">func (me *NodeTransform) SetScale(scale *unum.Vec3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetScaleN">func (me *NodeTransform) SetScaleN(scale float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.SetScaleXYZ">func (me *NodeTransform) SetScaleXYZ(x, y, z float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeTransform.StepDelta">func (me *NodeTransform) StepDelta(deltaPerSecond float64) float64</a></dd>
				
			
				
				<dd><a href="#NodeVisitor">type NodeVisitor</a></dd>
				
				
			
				
				<dd><a href="#Nodes">type Nodes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.Add">func (me *Nodes) Add(node *Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.AddNew">func (me *Nodes) AddNew(id, meshID, modelID string) (node *Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nodes.Remove">func (me *Nodes) Remove(id string)</a></dd>
				
			
				
				<dd><a href="#RenderBatch">type RenderBatch</a></dd>
				
				
			
				
				<dd><a href="#RenderBatchCriteria">type RenderBatchCriteria</a></dd>
				
				
			
				
				<dd><a href="#RenderCanvas">type RenderCanvas</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.AddNewCamera2D">func (me *RenderCanvas) AddNewCamera2D(allowOverlaps bool) (cam *Camera)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.AddNewCamera3D">func (me *RenderCanvas) AddNewCamera3D() (cam *Camera)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.AddNewCameraQuad">func (me *RenderCanvas) AddNewCameraQuad() (cam *Camera)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.CurrentAbsoluteSize">func (me *RenderCanvas) CurrentAbsoluteSize() (width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.Remove">func (me *RenderCanvas) Remove()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvas.SetSize">func (me *RenderCanvas) SetSize(relative bool, width, height float64)</a></dd>
				
			
				
				<dd><a href="#RenderCanvases">type RenderCanvases</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.AddNew">func (_ RenderCanvases) AddNew(relative bool, width, height float64) (rc *RenderCanvas)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.Final">func (_ RenderCanvases) Final() *RenderCanvas</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderCanvases.Walk">func (_ RenderCanvases) Walk(onCanv func(*RenderCanvas), onCam func(*Camera))</a></dd>
				
			
				
				<dd><a href="#RenderTechnique">type RenderTechnique</a></dd>
				
				
			
				
				<dd><a href="#RenderTechniqueProvider">type RenderTechniqueProvider</a></dd>
				
				
			
				
				<dd><a href="#RenderTechniqueQuad">type RenderTechniqueQuad</a></dd>
				
				
			
				
				<dd><a href="#RenderTechniqueScene">type RenderTechniqueScene</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RenderTechniqueScene.ToggleBatching">func (me *RenderTechniqueScene) ToggleBatching()</a></dd>
				
			
				
				<dd><a href="#RenderTechniques">type RenderTechniques</a></dd>
				
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewScene">func NewScene() (me *Scene)</a></dd>
				
				
			
				
				<dd><a href="#TimingStats">type TimingStats</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Average">func (me *TimingStats) Average() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TimingStats.Max">func (me *TimingStats) Max() float64</a></dd>
				
			
				
				<dd><a href="#WindowOptions">type WindowOptions</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Created">func (me *WindowOptions) Created() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Fullscreen">func (me *WindowOptions) Fullscreen() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Height">func (me *WindowOptions) Height() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.SetSize">func (me *WindowOptions) SetSize(width, height int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.SetSwapInterval">func (me *WindowOptions) SetSwapInterval(newSwap int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.SetTitle">func (me *WindowOptions) SetTitle(newTitle string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.SwapInterval">func (me *WindowOptions) SwapInterval() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Title">func (me *WindowOptions) Title() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#WindowOptions.Width">func (me *WindowOptions) Width() int</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-auto-generated.go">-auto-generated.go</a>
			
				<a href="/target/camera.go">camera.go</a>
			
				<a href="/target/controller.go">controller.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/fileio.go">fileio.go</a>
			
				<a href="/target/fx-effect.gt.go">fx-effect.gt.go</a>
			
				<a href="/target/fx-image-2d.gt.go">fx-image-2d.gt.go</a>
			
				<a href="/target/fx-image-cached.go">fx-image-cached.go</a>
			
				<a href="/target/fx-image-cube.gt.go">fx-image-cube.gt.go</a>
			
				<a href="/target/fx-image-loading.go">fx-image-loading.go</a>
			
				<a href="/target/fx-image.go">fx-image.go</a>
			
				<a href="/target/fx-material.gt.go">fx-material.gt.go</a>
			
				<a href="/target/fx-ops.gt.go">fx-ops.gt.go</a>
			
				<a href="/target/gl-core.go">gl-core.go</a>
			
				<a href="/target/glsl-ubershader.go">glsl-ubershader.go</a>
			
				<a href="/target/mesh-buffer.go">mesh-buffer.go</a>
			
				<a href="/target/mesh-data.go">mesh-data.go</a>
			
				<a href="/target/mesh-provider.go">mesh-provider.go</a>
			
				<a href="/target/mesh.go">mesh.go</a>
			
				<a href="/target/model.go">model.go</a>
			
				<a href="/target/ng-core.go">ng-core.go</a>
			
				<a href="/target/ng-diag.go">ng-diag.go</a>
			
				<a href="/target/ng-loop.go">ng-loop.go</a>
			
				<a href="/target/ng-options.go">ng-options.go</a>
			
				<a href="/target/ng-stats.go">ng-stats.go</a>
			
				<a href="/target/ng-userio.go">ng-userio.go</a>
			
				<a href="/target/ng-window.go">ng-window.go</a>
			
				<a href="/target/ng.go">ng.go</a>
			
				<a href="/target/node-transform.go">node-transform.go</a>
			
				<a href="/target/node.go">node.go</a>
			
				<a href="/target/nodes.go">nodes.go</a>
			
				<a href="/target/render-batch.go">render-batch.go</a>
			
				<a href="/target/render-bucket.go">render-bucket.go</a>
			
				<a href="/target/render-canvas.go">render-canvas.go</a>
			
				<a href="/target/render-prep.go">render-prep.go</a>
			
				<a href="/target/render-technique-quad.go">render-technique-quad.go</a>
			
				<a href="/target/render-technique-scene.go">render-technique-scene.go</a>
			
				<a href="/target/render-technique.go">render-technique.go</a>
			
				<a href="/target/render.go">render.go</a>
			
				<a href="/target/scene.gt.go">scene.gt.go</a>
			
				<a href="/target/threading.go">threading.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    BatchByProgram
    BatchByTexture
    BatchByBuffer
)</pre>
				
			
				<pre>const DefaultBadVersionMessage = `
Minimum required OpenGL version is {MINVER}, but your
current {OS} graphics driver only provides
OpenGL version {CURVER}.

Most likely your machine is just
missing some recent system updates.

*HOW TO RESOLVE*:

1. On the web, search for &#34;downloading &amp; installing the
latest {OS} driver for {GPU}&#34;,

2. or simply visit the {VENDOR} website and locate
their &#34;driver downloads&#34; pages to obtain the most
recent driver for {GPU}.
`</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    Diag = EngineDiag{
        LogCategories: DiagLogCatAll,
        LogCategoryNames: map[EngineDiagLogCategory]string{
            DiagLogCatMisc:    &#34;[INFO]\t\t&#34;,
            DiagLogCatShaders: &#34;[SHADER]\t&#34;,
            DiagLogCatImages:  &#34;[IMAGES]\t&#34;,
            DiagLogCatMeshes:  &#34;[MESHES]\t&#34;,
        },
        LogGLErrorsInLoopOnSec: true,
    }
)</pre>
				
			
		
		
			
			
			<h2 id="Dispose">func <a href="/target/ng.go?s=227:241#L2">Dispose</a></h2>
			<pre>func Dispose()</pre>
			<p>
Call this to &#34;un-init&#34; go:ngine and to release any and all GPU or RAM resources still allocated.
</p>

			
		
			
			
			<h2 id="Init">func <a href="/target/ng.go?s=448:486#L9">Init</a></h2>
			<pre>func Init(fullscreen bool) (err error)</pre>
			<p>
Initializes go:ngine; this first attempts to initialize OpenGL and then open a window to your supplied specifications with a GL 3.3-or-higher profile.
</p>

			
		
		
			
			
			<h2 id="Camera">type <a href="/target/camera.go?s=698:1510#L14">Camera</a></h2>
			<pre>type Camera struct {
    <span class="comment">//	Optical and imager properties for this camera.</span>
    Perspective struct {
        <span class="comment">//	FovY, ZFar, ZNear</span>
        CameraPerspective

        <span class="comment">//	Whether this is a perspective-projection camera. Defaults to true.</span>
        <span class="comment">//	If false, no projection transformation is applied.</span>
        Use bool
    }

    <span class="comment">//	Encapsulates the position and direction of this camera.</span>
    Controller Controller

    Enabled bool

    Rendering struct {
        <span class="comment">//	The device-relative or absolute view-port for this Camera.</span>
        Viewport CameraViewport

        States ugl.RenderStatesBag

        Technique RenderTechnique

        FxOps FxOps
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A camera embodies the eye point of the viewer looking at the visual scene.
</p>


			

			

			

			

			
				
				<h3 id="Camera.ApplyMatrices">func (*Camera) <a href="/target/camera.go?s=2879:2912#L95">ApplyMatrices</a></h3>
				<pre>func (me *Camera) ApplyMatrices()</pre>
				<p>
Applies changes made to the FovY, ZNear and/or ZFar parameters in me.Perspective.
</p>

				
				
			
				
				<h3 id="Camera.RenderTechniqueQuad">func (*Camera) <a href="/target/camera.go?s=3755:3822#L134">RenderTechniqueQuad</a></h3>
				<pre>func (me *Camera) RenderTechniqueQuad() (tech *RenderTechniqueQuad)</pre>
				
				
				
			
				
				<h3 id="Camera.RenderTechniqueScene">func (*Camera) <a href="/target/camera.go?s=3893:3962#L139">RenderTechniqueScene</a></h3>
				<pre>func (me *Camera) RenderTechniqueScene() (tech *RenderTechniqueScene)</pre>
				
				
				
			
				
				<h3 id="Camera.Scene">func (*Camera) <a href="/target/camera.go?s=3407:3439#L115">Scene</a></h3>
				<pre>func (me *Camera) Scene() *Scene</pre>
				
				
				
			
				
				<h3 id="Camera.SetScene">func (*Camera) <a href="/target/camera.go?s=3677:3714#L130">SetScene</a></h3>
				<pre>func (me *Camera) SetScene(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="CameraPerspective">type <a href="/target/camera.go?s=141:618#L1">CameraPerspective</a></h2>
			<pre>type CameraPerspective struct {
    <span class="comment">//	Vertical field-of-view. Defaults to 37.8493.</span>
    <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
    FovY float64

    <span class="comment">//	Distance of the far-plane from the camera. Defaults to 30000.</span>
    <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
    ZFar float64

    <span class="comment">//	Distance of the near-plane from the camera. Defaults to 0.3.</span>
    <span class="comment">//	After changing this value, you must call the ApplyMatrices() method.</span>
    ZNear float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="CameraViewport">type <a href="/target/camera.go?s=4384:4644#L163">CameraViewport</a></h2>
			<pre>type CameraViewport struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a device-relative or absolute camera view-port.
</p>


			

			

			

			

			
				
				<h3 id="CameraViewport.SetAbs">func (*CameraViewport) <a href="/target/camera.go?s=4770:4827#L178">SetAbs</a></h3>
				<pre>func (me *CameraViewport) SetAbs(x, y, width, height int)</pre>
				<p>
Sets the absolute viewport origin and dimensions in pixels.
</p>

				
				
			
				
				<h3 id="CameraViewport.SetRel">func (*CameraViewport) <a href="/target/camera.go?s=5079:5140#L185">SetRel</a></h3>
				<pre>func (me *CameraViewport) SetRel(x, y, width, height float64)</pre>
				<p>
Sets the device-relative viewport origin and dimensions, with the value 1.0
representing the maximum extent of the viewport on that respective axis.
</p>

				
				
			
		
			
			
			<h2 id="Cameras">type <a href="/target/camera.go?s=4034:4056#L144">Cameras</a></h2>
			<pre>type Cameras []*Camera</pre>
			

			

			

			

			

			
				
				<h3 id="Cameras.Remove">func (*Cameras) <a href="/target/camera.go?s=4149:4190#L153">Remove</a></h3>
				<pre>func (me *Cameras) Remove(camera *Camera)</pre>
				
				
				
			
		
			
			
			<h2 id="Controller">type <a href="/target/controller.go?s=272:987#L2">Controller</a></h2>
			<pre>type Controller struct {
    <span class="comment">//	The position being manipulated by this Controller.</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    Pos unum.Vec3

    <span class="comment">//	Indicates which axis is consider &#34;upward&#34;. This is typically</span>
    <span class="comment">//	the Y-axis, denoted by the default value (0, 1, 0).</span>
    <span class="comment">//	When manipulating this manually (outside the TurnXyz() / MoveXyz() methods),</span>
    <span class="comment">//	do so in between calling the BeginUpdate() and EndUpdate() methods.</span>
    UpAxis unum.Vec3

    Params *ControllerParams
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Encapsulates a position-and-direction and provides methods
manipulating these with respect to each other (e.g. &#34;move forward&#34;
some entity that is rotated facing some arbitrary direction).
</p>


			

			

			

			

			
				
				<h3 id="Controller.BeginUpdate">func (*Controller) <a href="/target/controller.go?s=2154:2189#L59">BeginUpdate</a></h3>
				<pre>func (me *Controller) BeginUpdate()</pre>
				<p>
Temporarily suspends all matrix re-calculations typically occuring inside
the MoveXyz() / TurnXyz() methods. Call this prior to multiple subsequent
calls to any combination of those methods, and/or prior to manually modifying
the Pos, Dir or UpAxis fields of me. Immediately afterwards, be sure to call
EndUpdate() to apply all changes in a final matrix re-calculation.
</p>

				
				
			
				
				<h3 id="Controller.CopyFrom">func (*Controller) <a href="/target/controller.go?s=2218:2265#L63">CopyFrom</a></h3>
				<pre>func (me *Controller) CopyFrom(ctl *Controller)</pre>
				
				
				
			
				
				<h3 id="Controller.Dir">func (*Controller) <a href="/target/controller.go?s=2601:2639#L72">Dir</a></h3>
				<pre>func (me *Controller) Dir() *unum.Vec3</pre>
				<p>
The direction being manipulated by this Controller.
CAUTION: this returns a pointer to the direction vector to avoid a copy, but it&#39;s
NOT meant to be modified, as the vector is re-computed by the TurnFoo() methods.
</p>

				
				
			
				
				<h3 id="Controller.EndUpdate">func (*Controller) <a href="/target/controller.go?s=2966:2999#L80">EndUpdate</a></h3>
				<pre>func (me *Controller) EndUpdate()</pre>
				<p>
Applies all changes made to Pos, Dir or UpAxis since BeginUpdate() was last
called, and recalculates this Controller&#39;s final 4x4 transformation matrix.
Also resumes all matrix re-calculations typically occuring inside the
MoveXyz() / TurnXyz() methods that were suspended since BeginUpdate().
</p>

				
				
			
				
				<h3 id="Controller.MoveBackward">func (*Controller) <a href="/target/controller.go?s=3839:3875#L111">MoveBackward</a></h3>
				<pre>func (me *Controller) MoveBackward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move backward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveDown">func (*Controller) <a href="/target/controller.go?s=4035:4067#L117">MoveDown</a></h3>
				<pre>func (me *Controller) MoveDown()</pre>
				<p>
Recomputes Pos with regards to UpAxis to effect a &#34;move downward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveForward">func (*Controller) <a href="/target/controller.go?s=4237:4272#L123">MoveForward</a></h3>
				<pre>func (me *Controller) MoveForward()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move forward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveLeft">func (*Controller) <a href="/target/controller.go?s=4441:4473#L129">MoveLeft</a></h3>
				<pre>func (me *Controller) MoveLeft()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move left-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveRight">func (*Controller) <a href="/target/controller.go?s=4670:4703#L135">MoveRight</a></h3>
				<pre>func (me *Controller) MoveRight()</pre>
				<p>
Recomputes Pos with regards to UpAxis and Dir to effect a &#34;move right-ward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.MoveUp">func (*Controller) <a href="/target/controller.go?s=4888:4918#L141">MoveUp</a></h3>
				<pre>func (me *Controller) MoveUp()</pre>
				<p>
Recomputes Pos with regards to UpAxis to effect a &#34;move upward&#34;.
</p>

				
				
			
				
				<h3 id="Controller.StepSizeMove">func (*Controller) <a href="/target/controller.go?s=5389:5433#L160">StepSizeMove</a></h3>
				<pre>func (me *Controller) StepSizeMove() float64</pre>
				<p>
Returns the current distance that a single MoveXyz() call (per loop iteration) would move.
(Loop.TickDelta * me.Params.MoveSpeed * me.Params.MoveSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.StepSizeTurn">func (*Controller) <a href="/target/controller.go?s=5680:5724#L166">StepSizeTurn</a></h3>
				<pre>func (me *Controller) StepSizeTurn() float64</pre>
				<p>
Returns the current degrees that a single TurnXyz() call (per loop iteration) would turn.
(Loop.TickDelta * me.Params.TurnSpeed * me.Params.TurnSpeedupFactor)
</p>

				
				
			
				
				<h3 id="Controller.TurnDown">func (*Controller) <a href="/target/controller.go?s=5913:5945#L171">TurnDown</a></h3>
				<pre>func (me *Controller) TurnDown()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnDownBy">func (*Controller) <a href="/target/controller.go?s=6088:6133#L176">TurnDownBy</a></h3>
				<pre>func (me *Controller) TurnDownBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn downward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeft">func (*Controller) <a href="/target/controller.go?s=6306:6338#L183">TurnLeft</a></h3>
				<pre>func (me *Controller) TurnLeft()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnLeftBy">func (*Controller) <a href="/target/controller.go?s=6482:6527#L188">TurnLeftBy</a></h3>
				<pre>func (me *Controller) TurnLeftBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn left-ward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnRight">func (*Controller) <a href="/target/controller.go?s=6656:6689#L193">TurnRight</a></h3>
				<pre>func (me *Controller) TurnRight()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnRightBy">func (*Controller) <a href="/target/controller.go?s=6835:6881#L198">TurnRightBy</a></h3>
				<pre>func (me *Controller) TurnRightBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn right-ward&#34; by the specified degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnUp">func (*Controller) <a href="/target/controller.go?s=7007:7037#L203">TurnUp</a></h3>
				<pre>func (me *Controller) TurnUp()</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34; by me.StepSizeTurn() degrees.
</p>

				
				
			
				
				<h3 id="Controller.TurnUpBy">func (*Controller) <a href="/target/controller.go?s=7176:7219#L208">TurnUpBy</a></h3>
				<pre>func (me *Controller) TurnUpBy(deg float64)</pre>
				<p>
Recomputes Dir with regards to UpAxis and Pos to effect a &#34;turn upward&#34; by the specified degress.
</p>

				
				
			
		
			
			
			<h2 id="ControllerParams">type <a href="/target/controller.go?s=7281:7915#L214">ControllerParams</a></h2>
			<pre>type ControllerParams struct {
    <span class="comment">//	Speed of &#34;moving&#34; in the MoveXyz() methods, in units per second.</span>
    <span class="comment">//	Defaults to 2.</span>
    MoveSpeed float64

    <span class="comment">//	A factor multiplied with MoveSpeed in the MoveXyz() methods. Defaults to 1.</span>
    MoveSpeedupFactor float64

    <span class="comment">//	Speed of &#34;turning&#34; in the TurnXyz() methods, in degrees per second.</span>
    <span class="comment">//	Defaults to 90.</span>
    TurnSpeed float64

    <span class="comment">//	A factor multiplied with TurnSpeed in the TurnXyz() methods. Defaults to 1.</span>
    TurnSpeedupFactor float64

    <span class="comment">//	The maximum degree that TurnUp() allows. Defaults to 90.</span>
    MaxTurnUp float64

    <span class="comment">//	The minimum degree that TurnDown() allows. Defaults to -90.</span>
    MinTurnDown float64
}</pre>
			

			

			

			

			
				
				<h3 id="NewControllerParams">func <a href="/target/controller.go?s=7917:7966#L236">NewControllerParams</a></h3>
				<pre>func NewControllerParams() (me *ControllerParams)</pre>
				
				
			

			
		
			
			
			<h2 id="EngineCore">type <a href="/target/ng-core.go?s=453:1107#L6">EngineCore</a></h2>
			<pre>type EngineCore struct {
    MeshBuffers *MeshBuffers
    Libs        struct {
        Effects   LibFxEffects
        Materials LibFxMaterials
        Images    struct {
            SplashScreen FxImage2D
            TexCubes     LibFxImageCubes
            Tex2D        LibFxImage2Ds
        }
        Meshes LibMeshes
        Scenes LibScenes
    }
    Rendering struct {
        Canvases RenderCanvases
        Fx       struct {
            KnownProcIDs []string
            Samplers     struct {
                NoFilteringClamp    ugl.Sampler
                FullFilteringRepeat ugl.Sampler
                FullFilteringClamp  ugl.Sampler
            }
            <span class="comment">// contains filtered or unexported fields</span>
        }
        KnownTechniques map[string]RenderTechniqueProvider
        <span class="comment">// contains filtered or unexported fields</span>
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
EngineCore is a singleton type, only used for the core.Core package-global exported variable.
It is only aware of that instance and does not support any other EngineCore instances.
</p>


			

			
				<pre>var (
    <span class="comment">//	The heart and brain of go:ngine --- a container for all runtime resources and responsible for rendering.</span>
    Core EngineCore
)</pre>
				
			

			

			

			
				
				<h3 id="EngineCore.GpuSyncImageLibs">func (*EngineCore) <a href="/target/ng-core.go?s=3796:3847#L121">GpuSyncImageLibs</a></h3>
				<pre>func (_ *EngineCore) GpuSyncImageLibs() (err error)</pre>
				
				
				
			
		
			
			
			<h2 id="EngineDiag">type <a href="/target/ng-diag.go?s=986:1144#L29">EngineDiag</a></h2>
			<pre>type EngineDiag struct {
    LogCategories          EngineDiagLogCategory
    LogCategoryNames       map[EngineDiagLogCategory]string
    LogGLErrorsInLoopOnSec bool
}</pre>
			<p>
EngineDiag is a singleton type, only used for the core.Diag package-global exported variable.
It is only aware of that instance and does not support any other EngineDiag instances.
</p>


			

			

			

			

			
				
				<h3 id="EngineDiag.Log">func (*EngineDiag) <a href="/target/ng-diag.go?s=1146:1233#L35">Log</a></h3>
				<pre>func (_ *EngineDiag) Log(cat EngineDiagLogCategory, fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogErr">func (*EngineDiag) <a href="/target/ng-diag.go?s=1339:1377#L41">LogErr</a></h3>
				<pre>func (_ *EngineDiag) LogErr(err error)</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogIfGlErr">func (*EngineDiag) <a href="/target/ng-diag.go?s=1402:1469#L45">LogIfGlErr</a></h3>
				<pre>func (_ *EngineDiag) LogIfGlErr(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogImages">func (*EngineDiag) <a href="/target/ng-diag.go?s=1510:1576#L49">LogImages</a></h3>
				<pre>func (_ *EngineDiag) LogImages(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogMeshes">func (*EngineDiag) <a href="/target/ng-diag.go?s=1627:1693#L53">LogMeshes</a></h3>
				<pre>func (_ *EngineDiag) LogMeshes(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogMisc">func (*EngineDiag) <a href="/target/ng-diag.go?s=1744:1808#L57">LogMisc</a></h3>
				<pre>func (_ *EngineDiag) LogMisc(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
				
				<h3 id="EngineDiag.LogShaders">func (*EngineDiag) <a href="/target/ng-diag.go?s=1857:1924#L61">LogShaders</a></h3>
				<pre>func (_ *EngineDiag) LogShaders(fmt string, fmtArgs ...interface{})</pre>
				
				
				
			
		
			
			
			<h2 id="EngineDiagLogCategory">type <a href="/target/ng-diag.go?s=107:137#L1">EngineDiagLogCategory</a></h2>
			<pre>type EngineDiagLogCategory int</pre>
			

			
				<pre>const (
    DiagLogCatMisc    EngineDiagLogCategory = 1
    DiagLogCatMeshes  EngineDiagLogCategory = 2
    DiagLogCatShaders EngineDiagLogCategory = 4
    DiagLogCatImages  EngineDiagLogCategory = 8
    DiagLogCatAll     EngineDiagLogCategory = DiagLogCatMeshes | DiagLogCatMisc | DiagLogCatShaders | DiagLogCatImages
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="EngineLoop">type <a href="/target/ng-loop.go?s=411:2170#L8">EngineLoop</a></h2>
			<pre>type EngineLoop struct {
    <span class="comment">//	Set to true by Loop.Run(). Set to false to stop looping.</span>
    Running bool

    On struct {
        <span class="comment">//	While Loop.Run() is running, this callback is invoked (in its own &#34;app thread&#34;)</span>
        <span class="comment">//	every loop iteration (ie. once per frame).</span>
        <span class="comment">//	This callback may run in parallel with On.EverySec(), but never with On.WinThread().</span>
        AppThread func()

        <span class="comment">//	While Loop.Run() is running, this callback is invoked (on the main windowing thread)</span>
        <span class="comment">//	every loop iteration (ie. once per frame).</span>
        <span class="comment">//	This callback is guaranteed to never run in parallel with</span>
        <span class="comment">//	(and always after) the On.AppThread() and On.EverySec() callbacks.</span>
        WinThread func()

        <span class="comment">//	While Loop.Run() is running, this callback is invoked (on the main windowing thread)</span>
        <span class="comment">//	at least and at most once per second, a useful entry point for non-real-time periodically recurring code.</span>
        <span class="comment">//	Caution: unlike On.WinThread(), this callback runs in parallel with your On.AppThread() callback.</span>
        EverySec func()
    }

    Tick struct {
        <span class="comment">//	The tick-time when the Loop.On.EverySec() callback was last invoked.</span>
        PrevSec int

        <span class="comment">//	While Loop.Run() is running, is set to the current &#34;tick-time&#34;:</span>
        <span class="comment">//	the time in seconds expired ever since Loop.Run() was last called.</span>
        Now float64

        <span class="comment">//	While Loop.Run() is running, is set to the previous tick-time.</span>
        Prev float64

        <span class="comment">//	The delta between Tick.Prev and Tick.Now.</span>
        Delta float64
    }
}</pre>
			<p>
EngineLoop is a singleton type, only used for the Loop variable.
It is only aware of that instance and does not support any other EngineLoop instances.
</p>


			

			
				<pre>var (
    <span class="comment">//	Manages your main-thread&#39;s render loop.</span>
    <span class="comment">//	Call it&#39;s Run() method once after go:ngine initialization (see examples).</span>
    Loop EngineLoop
)</pre>
				
			

			

			

			
				
				<h3 id="EngineLoop.Run">func (*EngineLoop) <a href="/target/ng-loop.go?s=3506:3532#L115">Run</a></h3>
				<pre>func (_ *EngineLoop) Run()</pre>
				<p>
Initiates a rendering loop. This method returns only when the loop is stopped for whatever reason.
</p>
<p>
(Before entering the loop, this method performs a one-off GC invokation.)
</p>

				
				
			
				
				<h3 id="EngineLoop.Time">func (*EngineLoop) <a href="/target/ng-loop.go?s=6812:6847#L202">Time</a></h3>
				<pre>func (_ *EngineLoop) Time() float64</pre>
				<p>
Returns the number of seconds expired ever since Loop.Run() was last called.
</p>

				
				
			
		
			
			
			<h2 id="EngineOptions">type <a href="/target/ng-options.go?s=617:3805#L23">EngineOptions</a></h2>
			<pre>type EngineOptions struct {
    AppDir struct {
        <span class="comment">//	The base directory path for app file paths.</span>
        BasePath string

        Temp struct {
            BaseName       string
            ShaderSources  string
            CachedTextures string
        }
    }

    Cameras struct {
        DefaultControllerParams *ControllerParams
        PerspectiveDefaults     CameraPerspective
    }

    Initialization struct {
        GlContext struct {
            CoreProfile struct {
                <span class="comment">//	Required on Mac OS X, not necessary elsewhere.</span>
                <span class="comment">//	While potentially slightly beneficial with recent GL drivers,</span>
                <span class="comment">//	might also fail with a select few rather outdated ones.</span>
                <span class="comment">//	Defaults to true on Mac OS X, to false elsewhere.</span>
                ForceFirst bool

                <span class="comment">//	While required on Mac OS X, really not recommended elsewhere</span>
                <span class="comment">//	(at present). Defaults to true on Mac OS X, to false elsewhere.</span>
                ForwardCompat bool

                <span class="comment">//	Defaults to the newest GL version currently supported by the GL</span>
                <span class="comment">//	binding used by go:ngine. The binding adaptively uses features</span>
                <span class="comment">//	of GL versions newer than 3.3 only if they are available, so this</span>
                <span class="comment">//	is a most strongly recommended default for release apps. But for</span>
                <span class="comment">//	testing, this is useful to test performance in older GL versions.</span>
                <span class="comment">//	Must be one of the values in glutil.KnownVersions.</span>
                VersionHint float64
            }

            <span class="comment">//	Defaults to the DefaultBadVersionMessage constant. If using a custom</span>
            <span class="comment">//	string, you can use the same placeholders as that one.</span>
            BadVersionMessage string
        }
        DefaultCanvas struct {
            GammaViaShader bool
            SplashImage    []byte
        }
        Window struct {
            <span class="comment">//	Defaults: R=8 G=8 B=8 A=0 D=8 S=0.</span>
            <span class="comment">//	These defaults are reasonable when using a render-to-texture off-screen</span>
            <span class="comment">//	RenderCanvas. Otherwise, may want to bump D to at least 24 or 32.</span>
            <span class="comment">//	D shouldn&#39;t be 0 as this causes some Intel HD drivers to bug out badly.</span>
            Rbits, Gbits, Bbits, Abits, DepthBits, StencilBits int
        }
    }

    Loop struct {
        <span class="comment">//	By default, the app and prep &#34;threads&#34; being invoked every frame</span>
        <span class="comment">//	during Loop() are just normal go-routines that may or may not</span>
        <span class="comment">//	correspond to real separate OS thread contexts.</span>
        ForceThreads struct {
            <span class="comment">//	If true, each On.AppThread() go-routine invokation locks its own exclusive thread context.</span>
            App bool

            <span class="comment">//	If true, each prep-stage go-routine invokation locks its own exclusive thread context.</span>
            Prep bool
        }

        <span class="comment">//	Controls whether and how often the Garbage Collector</span>
        <span class="comment">//	is invoked during the Loop.</span>
        GcEvery struct {
            <span class="comment">//	Defaults to false. If true, GC will</span>
            <span class="comment">//	be invoked every frame during the Loop.</span>
            Frame bool

            <span class="comment">//	Defaults to true. If true, GC will be invoked at</span>
            <span class="comment">//	least and at most once per second during the Loop.</span>
            Sec bool
        }
    }

    Rendering struct {
        DefaultClearColor ugl.GlVec4

        <span class="comment">//	Default render technique for a Camera created via RenderCanvas.AddNewCamera2D().</span>
        <span class="comment">//	Defaults to &#34;Scene&#34;.</span>
        DefaultTechnique2D string

        <span class="comment">//	Default render technique for a Camera created via RenderCanvas.AddNewCamera3D().</span>
        <span class="comment">//	Defaults to &#34;Scene&#34;.</span>
        DefaultTechnique3D string

        <span class="comment">//	Default render technique for a Camera created via RenderCanvas.AddNewCameraQuad().</span>
        <span class="comment">//	Defaults to &#34;Quad&#34;.</span>
        DefaultTechniqueQuad string
    }

    Textures struct {
        Storage FxImageStorage
    }
}</pre>
			<p>
Only used for the Options variable.
</p>


			

			
				<pre>var (
    Options EngineOptions
)</pre>
				
			

			

			

			
		
			
			
			<h2 id="EngineStats">type <a href="/target/ng-stats.go?s=299:3752#L4">EngineStats</a></h2>
			<pre>type EngineStats struct {
    <span class="comment">//	Gives the total number of frames rendered during the &#34;previous&#34;</span>
    <span class="comment">//	(not the current) second. Good enough for just a simple-minded FPS indicator.</span>
    FpsLastSec int

    <span class="comment">//	This TimingStats instance combines all the individual FrameFoo fields</span>
    <span class="comment">//	to track over time (both average and maximum) total cost per frame.</span>
    Frame TimingStats

    <span class="comment">//	&#34;Rendering&#34; consists of a CPU-side and a GPU-side cost.</span>
    <span class="comment">//	This TimingStats instance combines both to track over time</span>
    <span class="comment">//	(both average and maximum) total rendering cost per frame.</span>
    FrameRenderBoth TimingStats

    <span class="comment">//	The CPU-side cost of rendering comprises sending pre-batched</span>
    <span class="comment">//	rendering commands (prepared by the &#34;prep&#34; stage) to the GPU.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average</span>
    <span class="comment">//	and maximum) CPU-side rendering cost per frame.</span>
    FrameRenderCpu TimingStats

    <span class="comment">//	The GPU-side cost of rendering comprises execution of all draw calls</span>
    <span class="comment">//	sent by the CPU-side, plus waiting for V-sync if enabled.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average</span>
    <span class="comment">//	and maximum) GPU-side rendering cost per frame.</span>
    FrameRenderGpu TimingStats

    <span class="comment">//	&#34;Prep code&#34; comprises all go:ngine logic executed every frame in parallel to cull</span>
    <span class="comment">//	geometry and prepare a batch of rendering commands for the next (not current) frame.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;prep code&#34; cost per frame.</span>
    FramePrepThread TimingStats

    <span class="comment">//	&#34;App code&#34; comprises (mostly user-specific) logic executed every frame in parallel in</span>
    <span class="comment">//	your Loop.OnAppThread() callback. Such code may freely modify dynamic Cameras, Nodes etc.</span>
    <span class="comment">//	Unlike OnWinThread() code, &#34;app code&#34; always runs in its own thread in parallel to the prep and main threads.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;app code&#34; cost per frame.</span>
    FrameAppThread TimingStats

    <span class="comment">//	&#34;Windowing/GPU/IO code&#34; comprises user-specific logic executed every frame via your own</span>
    <span class="comment">//	Loop.OnWinThread() callback. This should be kept to a minimum to fully enjoy</span>
    <span class="comment">//	the benefits of multi-threading. Main use-cases are calls resulting in GPU state</span>
    <span class="comment">//	changes (such as toggling effects in Core.Rendering.PostFx) and working with UserIO</span>
    <span class="comment">//	to poll for user input -- but do consider executing resulting logic in your OnAppThread().</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;input code&#34; cost per frame.</span>
    FrameWinThread TimingStats

    <span class="comment">//	When CPU-side rendering is completed, Loop waits for the app thread and prep thread</span>
    <span class="comment">//	to finish (either before or after GPU-side rendering depending on Loop.SwapLast).</span>
    <span class="comment">//	It then moves &#34;prep results&#34; to the render thread and &#34;app results&#34; to the prep thread.</span>
    <span class="comment">//	This TimingStats instance tracks over time (both average and maximum) &#34;thread sync&#34; cost per frame.</span>
    FrameThreadSync TimingStats

    <span class="comment">//	During the Loop, the Go Garbge Collector is invoked at least and at most once per second.</span>
    <span class="comment">//	</span>
    <span class="comment">//	Forcing GC &#34;that often&#34; practically guarantees it will almost never have so much work to do as to</span>
    <span class="comment">//	noticably block user interaction --- typically well below 10ms, most often around 1ms.</span>
    <span class="comment">//	</span>
    <span class="comment">//	This TimingStats instance over time tracks the maximum and average time spent on that</span>
    <span class="comment">//	1x-per-second-during-Loop GC invokation (but does not track any other GC invokations).</span>
    Gc TimingStats

    Programs struct {
        NumProgsCompiled int
        TotalTimeCost    int64
    }
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineStats a &#34;Singleton&#34; type, only valid use is the core.Stats global variable.
Tracks various go:ngine performance indicators over time.
</p>


			

			
				<pre>var (
    <span class="comment">//	Tracks various go:ngine performance counters over time.</span>
    Stats EngineStats
)</pre>
				
			

			

			

			
				
				<h3 id="EngineStats.AverageFps">func (*EngineStats) <a href="/target/ng-stats.go?s=3999:4041#L80">AverageFps</a></h3>
				<pre>func (_ *EngineStats) AverageFps() float64</pre>
				<p>
Returns the average number of frames-per-second since Loop.Loop() was last called.
</p>

				
				
			
				
				<h3 id="EngineStats.TotalFrames">func (*EngineStats) <a href="/target/ng-stats.go?s=4299:4342#L94">TotalFrames</a></h3>
				<pre>func (_ *EngineStats) TotalFrames() float64</pre>
				
				
				
			
		
			
			
			<h2 id="EngineUserIO">type <a href="/target/ng-userio.go?s=500:765#L8">EngineUserIO</a></h2>
			<pre>type EngineUserIO struct {
    <span class="comment">//	Minimum delay for EngineUserIO.KeyToggled() method, in seconds. Defaults to 0.25.</span>
    KeyToggleMinDelay float64

    Window WindowOptions
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Consider EngineUserIO a &#34;Singleton&#34; type, only valid use is the core.UserIO global variable.
Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).
</p>


			

			
				<pre>var (
    <span class="comment">//	Your gateway for end-user input (key, mouse etc.) and &#34;output&#34; (window management, not the graphics themselves).</span>
    UserIO EngineUserIO
)</pre>
				
			

			

			

			
				
				<h3 id="EngineUserIO.IifKeyF">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2677:2749#L73">IifKeyF</a></h3>
				<pre>func (_ *EngineUserIO) IifKeyF(key int, ifTrue, ifFalse float64) float64</pre>
				<p>
Returns ifTrue if the specified key is pressed, otherwise returns ifFalse.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressed">func (*EngineUserIO) <a href="/target/ng-userio.go?s=2868:2915#L81">KeyPressed</a></h3>
				<pre>func (_ *EngineUserIO) KeyPressed(key int) bool</pre>
				<p>
Returns true if the specified key is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyPressedWhich">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3006:3061#L86">KeyPressedWhich</a></h3>
				<pre>func (_ *EngineUserIO) KeyPressedWhich(keys ...int) int</pre>
				<p>
Returns the first in keys that is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeyToggled">func (*EngineUserIO) <a href="/target/ng-userio.go?s=4079:4126#L116">KeyToggled</a></h3>
				<pre>func (_ *EngineUserIO) KeyToggled(key int) bool</pre>
				<p>
Returns true if the specified key has been &#34;toggled&#34;, ie. its pressed-state changed within the last me.KeyToggleMinDelay seconds.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3243:3298#L96">KeysPressedAll2</a></h3>
				<pre>func (_ *EngineUserIO) KeysPressedAll2(k1, k2 int) bool</pre>
				<p>
Returns true if both specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAll3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3416:3475#L101">KeysPressedAll3</a></h3>
				<pre>func (_ *EngineUserIO) KeysPressedAll3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if all three specified keys are pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny2">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3622:3677#L106">KeysPressedAny2</a></h3>
				<pre>func (_ *EngineUserIO) KeysPressedAny2(k1, k2 int) bool</pre>
				<p>
Returns true if any of the two specified keys is pressed.
</p>

				
				
			
				
				<h3 id="EngineUserIO.KeysPressedAny3">func (*EngineUserIO) <a href="/target/ng-userio.go?s=3801:3860#L111">KeysPressedAny3</a></h3>
				<pre>func (_ *EngineUserIO) KeysPressedAny3(k1, k2, k3 int) bool</pre>
				<p>
Returns true if any of the three specified keys is pressed.
</p>

				
				
			
		
			
			
			<h2 id="FxEffect">type <a href="/target/fx-effect.gt.go?s=342:936#L8">FxEffect</a></h2>
			<pre>type FxEffect struct {
    <span class="comment">//	An ordered collection of all FxOps that make up this effect.</span>
    <span class="comment">//	When changing the ordering or disabling, enabling or toggling individual FxOps,</span>
    <span class="comment">//	you need to call the FxEffect.UpdateRoutine() method to reflect such changes.</span>
    <span class="comment">//	Other dynamic, individual FxOp-specific parameter changes (colors, image bindings, weights etc.pp.)</span>
    <span class="comment">//	do not require this.</span>
    Ops FxOps

    OpsX FxOps

    KeepOpsLast []string
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Declares the visual appearance of a surface.
An FxEffect can be reused for multiple surfaces, it is bound to geometry via an FxMaterial.
</p>


			

			

			

			
				
				<h3 id="NewFxEffect">func <a href="/target/fx-effect.gt.go?s=2479:2512#L96">NewFxEffect</a></h3>
				<pre>func NewFxEffect() (me *FxEffect)</pre>
				<p>
Initializes and returns a new FxEffect with default parameters.
</p>

				
			

			
				
				<h3 id="FxEffect.UpdateRoutine">func (*FxEffect) <a href="/target/fx-effect.gt.go?s=1117:1152#L40">UpdateRoutine</a></h3>
				<pre>func (me *FxEffect) UpdateRoutine()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImage">type <a href="/target/fx-image.go?s=71:143#L1">FxImage</a></h2>
			<pre>type FxImage interface {
    Load() error
    Loaded() bool
    GpuSync() error
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxImage2D">type <a href="/target/fx-image-2d.gt.go?s=105:210#L1">FxImage2D</a></h2>
			<pre>type FxImage2D struct {
    FxImageBase
    InitFrom FxImageInitFrom
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxImage2D">func <a href="/target/fx-image-2d.gt.go?s=926:961#L43">NewFxImage2D</a></h3>
				<pre>func NewFxImage2D() (me *FxImage2D)</pre>
				<p>
Initializes and returns a new FxImage2D with default parameters.
</p>

				
			

			
				
				<h3 id="FxImage2D.GpuSync">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=381:423#L19">GpuSync</a></h3>
				<pre>func (me *FxImage2D) GpuSync() (err error)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Load">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=570:609#L26">Load</a></h3>
				<pre>func (me *FxImage2D) Load() (err error)</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Loaded">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=690:724#L32">Loaded</a></h3>
				<pre>func (me *FxImage2D) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="FxImage2D.Unload">func (*FxImage2D) <a href="/target/fx-image-2d.gt.go?s=752:781#L36">Unload</a></h3>
				<pre>func (me *FxImage2D) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageBase">type <a href="/target/fx-image.go?s=371:537#L17">FxImageBase</a></h2>
			<pre>type FxImageBase struct {
    PreProcess struct {
        FlipY    bool
        ToLinear bool
        ToBgra   bool
    }
    Storage FxImageStorage
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxImageBase.GpuDelete">func (*FxImageBase) <a href="/target/fx-image.go?s=944:978#L46">GpuDelete</a></h3>
				<pre>func (me *FxImageBase) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="FxImageBase.GpuSynced">func (*FxImageBase) <a href="/target/fx-image.go?s=1025:1064#L51">GpuSynced</a></h3>
				<pre>func (me *FxImageBase) GpuSynced() bool</pre>
				
				
				
			
				
				<h3 id="FxImageBase.NoAutoMips">func (*FxImageBase) <a href="/target/fx-image.go?s=1215:1250#L59">NoAutoMips</a></h3>
				<pre>func (me *FxImageBase) NoAutoMips()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageCube">type <a href="/target/fx-image-cube.gt.go?s=74:190#L1">FxImageCube</a></h2>
			<pre>type FxImageCube struct {
    FxImageBase
    InitFrom [6]FxImageInitFrom
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxImageCube">func <a href="/target/fx-image-cube.gt.go?s=1129:1168#L52">NewFxImageCube</a></h3>
				<pre>func NewFxImageCube() (me *FxImageCube)</pre>
				<p>
Initializes and returns a new FxImageCube with default parameters.
</p>

				
			

			
				
				<h3 id="FxImageCube.GpuSync">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=407:451#L19">GpuSync</a></h3>
				<pre>func (me *FxImageCube) GpuSync() (err error)</pre>
				
				
				
			
				
				<h3 id="FxImageCube.Load">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=605:646#L26">Load</a></h3>
				<pre>func (me *FxImageCube) Load() (err error)</pre>
				
				
				
			
				
				<h3 id="FxImageCube.Loaded">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=796:832#L36">Loaded</a></h3>
				<pre>func (me *FxImageCube) Loaded() bool</pre>
				
				
				
			
				
				<h3 id="FxImageCube.Unload">func (*FxImageCube) <a href="/target/fx-image-cube.gt.go?s=927:958#L45">Unload</a></h3>
				<pre>func (me *FxImageCube) Unload()</pre>
				
				
				
			
		
			
			
			<h2 id="FxImageInitFrom">type <a href="/target/fx-image-loading.go?s=116:179#L3">FxImageInitFrom</a></h2>
			<pre>type FxImageInitFrom struct {
    RawData []byte
    RefUrl  string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxImageStorage">type <a href="/target/fx-image.go?s=145:369#L5">FxImageStorage</a></h2>
			<pre>type FxImageStorage struct {
    DiskCache struct {
        Enabled      bool
        Compressor   func(w io.WriteCloser) io.WriteCloser
        Decompressor func(r io.ReadCloser) io.ReadCloser
    }
    Gpu struct {
        Bgra    bool
        UintRev bool
    }
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxMaterial">type <a href="/target/fx-material.gt.go?s=103:530#L1">FxMaterial</a></h2>
			<pre>type FxMaterial struct {
    <span class="comment">//	This effect is used by default for all faces that do not</span>
    <span class="comment">//	match any of the selectors in the FaceEffects field.</span>
    DefaultEffectID string

    <span class="comment">//	Associates certain individual faces or tags of faces</span>
    <span class="comment">//	with specific effect IDs.</span>
    FaceEffects struct {
        <span class="comment">//	Associates face tags with effect IDs.</span>
        ByTag map[string]string

        <span class="comment">//	Associates specific face IDs with effect IDs.</span>
        ByID map[string]string
    }
}</pre>
			<p>
A material binds effects (FxEffect in Core.Libs.Effects) to geometry (Model or Node).
</p>


			

			

			

			
				
				<h3 id="NewFxMaterial">func <a href="/target/fx-material.gt.go?s=1351:1388#L41">NewFxMaterial</a></h3>
				<pre>func NewFxMaterial() (me *FxMaterial)</pre>
				<p>
Initializes and returns a new FxMaterial with default parameters.
</p>

				
			

			
				
				<h3 id="FxMaterial.HasFaceEffects">func (*FxMaterial) <a href="/target/fx-material.gt.go?s=1125:1168#L34">HasFaceEffects</a></h3>
				<pre>func (me *FxMaterial) HasFaceEffects() bool</pre>
				
				
				
			
		
			
			
			<h2 id="FxOp">type <a href="/target/fx-ops.gt.go?s=469:1343#L5">FxOp</a></h2>
			<pre>type FxOp interface {

    <span class="comment">//	Disables this FxOp.</span>
    <span class="comment">//	For this change to be applied, call FxEffect.UpdateRoutine() subsequently.</span>
    Disable()

    <span class="comment">//	Returns whether this FxOp is currently disabled.</span>
    Disabled() bool

    <span class="comment">//	Enables this FxOp.</span>
    <span class="comment">//	For this change to be applied, call FxEffect.UpdateRoutine() subsequently.</span>
    Enable()

    <span class="comment">//	Returns whether this FxOp is currently enabled.</span>
    Enabled() bool

    <span class="comment">//	The procID of this FxOp. This is one of the Core.Rendering.Fx.KnownProcIDs.</span>
    <span class="comment">//	For example, &#34;Tex2D&#34; for an FxOpTex2D, &#34;Grayscale&#34; for an FxOpGrayscale etc.</span>
    ProcID() string

    ProcIndex() int

    SetMixWeight(weight float64)

    <span class="comment">//	Toggles this FxOp.</span>
    <span class="comment">//	For this change to be applied, call FxEffect.UpdateRoutine() subsequently.</span>
    Toggle()
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			<p>
Implemented by specialized types such as FxOpTex2D, FxOpGrayscale etc.
Those are created and initializes exclusively through FxOps.Enable(&#34;{procID}&#34;) or the specialized FxOps.EnableFoo() methods.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxOpColor">type <a href="/target/fx-ops.gt.go?s=4019:4070#L172">FxOpColor</a></h2>
			<pre>type FxOpColor struct {
    Rgb ugl.GlVec3
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Colors geometry based on a specified color.
</p>


			

			

			

			

			
				
				<h3 id="FxOpColor.Disable">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=2557:2586#L106">Disable</a></h3>
				<pre>func (me *FxOpColor) Disable()</pre>
				<p>
Disables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpColor.Disabled">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=2664:2699#L111">Disabled</a></h3>
				<pre>func (me *FxOpColor) Disabled() bool</pre>
				<p>
Returns whether this FxOp is currently disabled.
</p>

				
				
			
				
				<h3 id="FxOpColor.Enable">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=2825:2853#L117">Enable</a></h3>
				<pre>func (me *FxOpColor) Enable()</pre>
				<p>
Enables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpColor.Enabled">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=2931:2965#L122">Enabled</a></h3>
				<pre>func (me *FxOpColor) Enabled() bool</pre>
				<p>
Returns whether this FxOp is currently enabled.
</p>

				
				
			
				
				<h3 id="FxOpColor.ProcID">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=3151:3186#L128">ProcID</a></h3>
				<pre>func (me *FxOpColor) ProcID() string</pre>
				<p>
The procID of this FxOp. This is one of the Core.Rendering.Fx.KnownProcIDs.
For example, &#34;Tex2D&#34; for an FxOpTex2D, &#34;Grayscale&#34; for an FxOpGrayscale etc.
</p>

				
				
			
				
				<h3 id="FxOpColor.ProcIndex">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=3210:3245#L132">ProcIndex</a></h3>
				<pre>func (me *FxOpColor) ProcIndex() int</pre>
				
				
				
			
				
				<h3 id="FxOpColor.SetMixWeight">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=3272:3320#L136">SetMixWeight</a></h3>
				<pre>func (me *FxOpColor) SetMixWeight(weight float64)</pre>
				
				
				
			
				
				<h3 id="FxOpColor.SetRgb">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=4072:4127#L177">SetRgb</a></h3>
				<pre>func (me *FxOpColor) SetRgb(rgb ...gl.Float) *FxOpColor</pre>
				
				
				
			
				
				<h3 id="FxOpColor.Toggle">func (*FxOpColor) <a href="/target/fx-ops.gt.go?s=3563:3591#L147">Toggle</a></h3>
				<pre>func (me *FxOpColor) Toggle()</pre>
				<p>
Toggles this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
		
			
			
			<h2 id="FxOpCoords">type <a href="/target/fx-ops.gt.go?s=3934:3970#L167">FxOpCoords</a></h2>
			<pre>type FxOpCoords struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Colors geometry based on texture coordinates.
</p>


			

			

			

			

			
				
				<h3 id="FxOpCoords.Disable">func (*FxOpCoords) <a href="/target/fx-ops.gt.go?s=2557:2586#L106">Disable</a></h3>
				<pre>func (me *FxOpCoords) Disable()</pre>
				<p>
Disables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpCoords.Disabled">func (*FxOpCoords) <a href="/target/fx-ops.gt.go?s=2664:2699#L111">Disabled</a></h3>
				<pre>func (me *FxOpCoords) Disabled() bool</pre>
				<p>
Returns whether this FxOp is currently disabled.
</p>

				
				
			
				
				<h3 id="FxOpCoords.Enable">func (*FxOpCoords) <a href="/target/fx-ops.gt.go?s=2825:2853#L117">Enable</a></h3>
				<pre>func (me *FxOpCoords) Enable()</pre>
				<p>
Enables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpCoords.Enabled">func (*FxOpCoords) <a href="/target/fx-ops.gt.go?s=2931:2965#L122">Enabled</a></h3>
				<pre>func (me *FxOpCoords) Enabled() bool</pre>
				<p>
Returns whether this FxOp is currently enabled.
</p>

				
				
			
				
				<h3 id="FxOpCoords.ProcID">func (*FxOpCoords) <a href="/target/fx-ops.gt.go?s=3151:3186#L128">ProcID</a></h3>
				<pre>func (me *FxOpCoords) ProcID() string</pre>
				<p>
The procID of this FxOp. This is one of the Core.Rendering.Fx.KnownProcIDs.
For example, &#34;Tex2D&#34; for an FxOpTex2D, &#34;Grayscale&#34; for an FxOpGrayscale etc.
</p>

				
				
			
				
				<h3 id="FxOpCoords.ProcIndex">func (*FxOpCoords) <a href="/target/fx-ops.gt.go?s=3210:3245#L132">ProcIndex</a></h3>
				<pre>func (me *FxOpCoords) ProcIndex() int</pre>
				
				
				
			
				
				<h3 id="FxOpCoords.SetMixWeight">func (*FxOpCoords) <a href="/target/fx-ops.gt.go?s=3272:3320#L136">SetMixWeight</a></h3>
				<pre>func (me *FxOpCoords) SetMixWeight(weight float64)</pre>
				
				
				
			
				
				<h3 id="FxOpCoords.Toggle">func (*FxOpCoords) <a href="/target/fx-ops.gt.go?s=3563:3591#L147">Toggle</a></h3>
				<pre>func (me *FxOpCoords) Toggle()</pre>
				<p>
Toggles this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
		
			
			
			<h2 id="FxOpGamma">type <a href="/target/fx-ops.gt.go?s=3739:3774#L157">FxOpGamma</a></h2>
			<pre>type FxOpGamma struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
pow(color, 1/2.2)
</p>


			

			

			

			

			
				
				<h3 id="FxOpGamma.Disable">func (*FxOpGamma) <a href="/target/fx-ops.gt.go?s=2557:2586#L106">Disable</a></h3>
				<pre>func (me *FxOpGamma) Disable()</pre>
				<p>
Disables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpGamma.Disabled">func (*FxOpGamma) <a href="/target/fx-ops.gt.go?s=2664:2699#L111">Disabled</a></h3>
				<pre>func (me *FxOpGamma) Disabled() bool</pre>
				<p>
Returns whether this FxOp is currently disabled.
</p>

				
				
			
				
				<h3 id="FxOpGamma.Enable">func (*FxOpGamma) <a href="/target/fx-ops.gt.go?s=2825:2853#L117">Enable</a></h3>
				<pre>func (me *FxOpGamma) Enable()</pre>
				<p>
Enables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpGamma.Enabled">func (*FxOpGamma) <a href="/target/fx-ops.gt.go?s=2931:2965#L122">Enabled</a></h3>
				<pre>func (me *FxOpGamma) Enabled() bool</pre>
				<p>
Returns whether this FxOp is currently enabled.
</p>

				
				
			
				
				<h3 id="FxOpGamma.ProcID">func (*FxOpGamma) <a href="/target/fx-ops.gt.go?s=3151:3186#L128">ProcID</a></h3>
				<pre>func (me *FxOpGamma) ProcID() string</pre>
				<p>
The procID of this FxOp. This is one of the Core.Rendering.Fx.KnownProcIDs.
For example, &#34;Tex2D&#34; for an FxOpTex2D, &#34;Grayscale&#34; for an FxOpGrayscale etc.
</p>

				
				
			
				
				<h3 id="FxOpGamma.ProcIndex">func (*FxOpGamma) <a href="/target/fx-ops.gt.go?s=3210:3245#L132">ProcIndex</a></h3>
				<pre>func (me *FxOpGamma) ProcIndex() int</pre>
				
				
				
			
				
				<h3 id="FxOpGamma.SetMixWeight">func (*FxOpGamma) <a href="/target/fx-ops.gt.go?s=3272:3320#L136">SetMixWeight</a></h3>
				<pre>func (me *FxOpGamma) SetMixWeight(weight float64)</pre>
				
				
				
			
				
				<h3 id="FxOpGamma.Toggle">func (*FxOpGamma) <a href="/target/fx-ops.gt.go?s=3563:3591#L147">Toggle</a></h3>
				<pre>func (me *FxOpGamma) Toggle()</pre>
				<p>
Toggles this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
		
			
			
			<h2 id="FxOpGrayscale">type <a href="/target/fx-ops.gt.go?s=3677:3716#L152">FxOpGrayscale</a></h2>
			<pre>type FxOpGrayscale struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Yields the grayscale of the current pixel color.
</p>


			

			

			

			

			
				
				<h3 id="FxOpGrayscale.Disable">func (*FxOpGrayscale) <a href="/target/fx-ops.gt.go?s=2557:2586#L106">Disable</a></h3>
				<pre>func (me *FxOpGrayscale) Disable()</pre>
				<p>
Disables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpGrayscale.Disabled">func (*FxOpGrayscale) <a href="/target/fx-ops.gt.go?s=2664:2699#L111">Disabled</a></h3>
				<pre>func (me *FxOpGrayscale) Disabled() bool</pre>
				<p>
Returns whether this FxOp is currently disabled.
</p>

				
				
			
				
				<h3 id="FxOpGrayscale.Enable">func (*FxOpGrayscale) <a href="/target/fx-ops.gt.go?s=2825:2853#L117">Enable</a></h3>
				<pre>func (me *FxOpGrayscale) Enable()</pre>
				<p>
Enables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpGrayscale.Enabled">func (*FxOpGrayscale) <a href="/target/fx-ops.gt.go?s=2931:2965#L122">Enabled</a></h3>
				<pre>func (me *FxOpGrayscale) Enabled() bool</pre>
				<p>
Returns whether this FxOp is currently enabled.
</p>

				
				
			
				
				<h3 id="FxOpGrayscale.ProcID">func (*FxOpGrayscale) <a href="/target/fx-ops.gt.go?s=3151:3186#L128">ProcID</a></h3>
				<pre>func (me *FxOpGrayscale) ProcID() string</pre>
				<p>
The procID of this FxOp. This is one of the Core.Rendering.Fx.KnownProcIDs.
For example, &#34;Tex2D&#34; for an FxOpTex2D, &#34;Grayscale&#34; for an FxOpGrayscale etc.
</p>

				
				
			
				
				<h3 id="FxOpGrayscale.ProcIndex">func (*FxOpGrayscale) <a href="/target/fx-ops.gt.go?s=3210:3245#L132">ProcIndex</a></h3>
				<pre>func (me *FxOpGrayscale) ProcIndex() int</pre>
				
				
				
			
				
				<h3 id="FxOpGrayscale.SetMixWeight">func (*FxOpGrayscale) <a href="/target/fx-ops.gt.go?s=3272:3320#L136">SetMixWeight</a></h3>
				<pre>func (me *FxOpGrayscale) SetMixWeight(weight float64)</pre>
				
				
				
			
				
				<h3 id="FxOpGrayscale.Toggle">func (*FxOpGrayscale) <a href="/target/fx-ops.gt.go?s=3563:3591#L147">Toggle</a></h3>
				<pre>func (me *FxOpGrayscale) Toggle()</pre>
				<p>
Toggles this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
		
			
			
			<h2 id="FxOpOrangify">type <a href="/target/fx-ops.gt.go?s=3845:3883#L162">FxOpOrangify</a></h2>
			<pre>type FxOpOrangify struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A very simple color &#34;effect&#34;. Tints the current color orange-red.
</p>


			

			

			

			

			
				
				<h3 id="FxOpOrangify.Disable">func (*FxOpOrangify) <a href="/target/fx-ops.gt.go?s=2557:2586#L106">Disable</a></h3>
				<pre>func (me *FxOpOrangify) Disable()</pre>
				<p>
Disables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpOrangify.Disabled">func (*FxOpOrangify) <a href="/target/fx-ops.gt.go?s=2664:2699#L111">Disabled</a></h3>
				<pre>func (me *FxOpOrangify) Disabled() bool</pre>
				<p>
Returns whether this FxOp is currently disabled.
</p>

				
				
			
				
				<h3 id="FxOpOrangify.Enable">func (*FxOpOrangify) <a href="/target/fx-ops.gt.go?s=2825:2853#L117">Enable</a></h3>
				<pre>func (me *FxOpOrangify) Enable()</pre>
				<p>
Enables this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOpOrangify.Enabled">func (*FxOpOrangify) <a href="/target/fx-ops.gt.go?s=2931:2965#L122">Enabled</a></h3>
				<pre>func (me *FxOpOrangify) Enabled() bool</pre>
				<p>
Returns whether this FxOp is currently enabled.
</p>

				
				
			
				
				<h3 id="FxOpOrangify.ProcID">func (*FxOpOrangify) <a href="/target/fx-ops.gt.go?s=3151:3186#L128">ProcID</a></h3>
				<pre>func (me *FxOpOrangify) ProcID() string</pre>
				<p>
The procID of this FxOp. This is one of the Core.Rendering.Fx.KnownProcIDs.
For example, &#34;Tex2D&#34; for an FxOpTex2D, &#34;Grayscale&#34; for an FxOpGrayscale etc.
</p>

				
				
			
				
				<h3 id="FxOpOrangify.ProcIndex">func (*FxOpOrangify) <a href="/target/fx-ops.gt.go?s=3210:3245#L132">ProcIndex</a></h3>
				<pre>func (me *FxOpOrangify) ProcIndex() int</pre>
				
				
				
			
				
				<h3 id="FxOpOrangify.SetMixWeight">func (*FxOpOrangify) <a href="/target/fx-ops.gt.go?s=3272:3320#L136">SetMixWeight</a></h3>
				<pre>func (me *FxOpOrangify) SetMixWeight(weight float64)</pre>
				
				
				
			
				
				<h3 id="FxOpOrangify.Toggle">func (*FxOpOrangify) <a href="/target/fx-ops.gt.go?s=3563:3591#L147">Toggle</a></h3>
				<pre>func (me *FxOpOrangify) Toggle()</pre>
				<p>
Toggles this FxOp.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
		
			
			
			<h2 id="FxOpTex2D">type <a href="/target/fx-ops.gt.go?s=4891:4951#L215">FxOpTex2D</a></h2>
			<pre>type FxOpTex2D struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Samples from a 2D texture.
</p>


			

			

			

			

			
				
				<h3 id="FxOpTex2D.SetImageID">func (*FxOpTex2D) <a href="/target/fx-ops.gt.go?s=5028:5086#L224">SetImageID</a></h3>
				<pre>func (me *FxOpTex2D) SetImageID(imageID string) *FxOpTex2D</pre>
				
				
				
			
		
			
			
			<h2 id="FxOpTexCube">type <a href="/target/fx-ops.gt.go?s=5350:5414#L236">FxOpTexCube</a></h2>
			<pre>type FxOpTexCube struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FxOpTexCube.SetImageID">func (*FxOpTexCube) <a href="/target/fx-ops.gt.go?s=5554:5603#L246">SetImageID</a></h3>
				<pre>func (me *FxOpTexCube) SetImageID(imageID string)</pre>
				
				
				
			
		
			
			
			<h2 id="FxOps">type <a href="/target/fx-ops.gt.go?s=5859:5876#L257">FxOps</a></h2>
			<pre>type FxOps []FxOp</pre>
			<p>
Used for FxEffect.Ops/OpsX and Camera.Rendering.FxOps.
</p>


			

			

			

			

			
				
				<h3 id="FxOps.Disable">func (FxOps) <a href="/target/fx-ops.gt.go?s=6135:6180#L263">Disable</a></h3>
				<pre>func (me FxOps) Disable(procID string, n int)</pre>
				<p>
Disables the nth (0-based) FxOp with the specified procID,
or all FxOps with the specified procID if n &lt; 0.
The procID must be one of the Core.Rendering.Fx.KnownProcIDs.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.DisableColor">func (FxOps) <a href="/target/fx-ops.gt.go?s=12319:12354#L476">DisableColor</a></h3>
				<pre>func (me FxOps) DisableColor(n int)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Color&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.DisableCoords">func (FxOps) <a href="/target/fx-ops.gt.go?s=11532:11568#L450">DisableCoords</a></h3>
				<pre>func (me FxOps) DisableCoords(n int)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Coords&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.DisableGamma">func (FxOps) <a href="/target/fx-ops.gt.go?s=13091:13126#L502">DisableGamma</a></h3>
				<pre>func (me FxOps) DisableGamma(n int)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Gamma&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.DisableGrayscale">func (FxOps) <a href="/target/fx-ops.gt.go?s=10699:10738#L424">DisableGrayscale</a></h3>
				<pre>func (me FxOps) DisableGrayscale(n int)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Grayscale&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.DisableOrangify">func (FxOps) <a href="/target/fx-ops.gt.go?s=9878:9916#L398">DisableOrangify</a></h3>
				<pre>func (me FxOps) DisableOrangify(n int)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Orangify&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.DisableTex2D">func (FxOps) <a href="/target/fx-ops.gt.go?s=8299:8334#L346">DisableTex2D</a></h3>
				<pre>func (me FxOps) DisableTex2D(n int)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;Tex2D&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.DisableTexCube">func (FxOps) <a href="/target/fx-ops.gt.go?s=9073:9110#L372">DisableTexCube</a></h3>
				<pre>func (me FxOps) DisableTexCube(n int)</pre>
				<p>
Convenience short-hand for me.Disable(&#34;TexCube&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.Enable">func (*FxOps) <a href="/target/fx-ops.gt.go?s=6674:6731#L282">Enable</a></h3>
				<pre>func (me *FxOps) Enable(procID string, n int) (fxOp FxOp)</pre>
				<p>
Enables the nth (0-based) FxOp with the specified procID,
or all FxOps with the specified procID if n &lt; 0.
If me has no FxOp with the specified procID, appends a new one.
The procID must be one of the Core.Rendering.Fx.KnownProcIDs.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.EnableColor">func (*FxOps) <a href="/target/fx-ops.gt.go?s=12515:12561#L482">EnableColor</a></h3>
				<pre>func (me *FxOps) EnableColor(n int) *FxOpColor</pre>
				<p>
Convenience short-hand for me.Enable(&#34;Color&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.EnableCoords">func (*FxOps) <a href="/target/fx-ops.gt.go?s=11731:11779#L456">EnableCoords</a></h3>
				<pre>func (me *FxOps) EnableCoords(n int) *FxOpCoords</pre>
				<p>
Convenience short-hand for me.Enable(&#34;Coords&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.EnableGamma">func (*FxOps) <a href="/target/fx-ops.gt.go?s=13287:13333#L508">EnableGamma</a></h3>
				<pre>func (me *FxOps) EnableGamma(n int) *FxOpGamma</pre>
				<p>
Convenience short-hand for me.Enable(&#34;Gamma&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.EnableGrayscale">func (*FxOps) <a href="/target/fx-ops.gt.go?s=10907:10961#L430">EnableGrayscale</a></h3>
				<pre>func (me *FxOps) EnableGrayscale(n int) *FxOpGrayscale</pre>
				<p>
Convenience short-hand for me.Enable(&#34;Grayscale&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.EnableOrangify">func (*FxOps) <a href="/target/fx-ops.gt.go?s=10083:10135#L404">EnableOrangify</a></h3>
				<pre>func (me *FxOps) EnableOrangify(n int) *FxOpOrangify</pre>
				<p>
Convenience short-hand for me.Enable(&#34;Orangify&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.EnableTex2D">func (*FxOps) <a href="/target/fx-ops.gt.go?s=8495:8541#L352">EnableTex2D</a></h3>
				<pre>func (me *FxOps) EnableTex2D(n int) *FxOpTex2D</pre>
				<p>
Convenience short-hand for me.Enable(&#34;Tex2D&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.EnableTexCube">func (*FxOps) <a href="/target/fx-ops.gt.go?s=9275:9325#L378">EnableTexCube</a></h3>
				<pre>func (me *FxOps) EnableTexCube(n int) *FxOpTexCube</pre>
				<p>
Convenience short-hand for me.Enable(&#34;TexCube&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.Get">func (FxOps) <a href="/target/fx-ops.gt.go?s=7136:7187#L303">Get</a></h3>
				<pre>func (me FxOps) Get(procID string, n int) (op FxOp)</pre>
				<p>
Returns the nth (0-based) FxOp with the specified procID.
The procID must be one of the Core.Rendering.Fx.KnownProcIDs.
</p>

				
				
			
				
				<h3 id="FxOps.GetColor">func (FxOps) <a href="/target/fx-ops.gt.go?s=12660:12707#L487">GetColor</a></h3>
				<pre>func (me FxOps) GetColor(n int) (op *FxOpColor)</pre>
				<p>
Convenience short-hand for me.Get(&#34;Color&#34;, n).
</p>

				
				
			
				
				<h3 id="FxOps.GetCoords">func (FxOps) <a href="/target/fx-ops.gt.go?s=11881:11930#L461">GetCoords</a></h3>
				<pre>func (me FxOps) GetCoords(n int) (op *FxOpCoords)</pre>
				<p>
Convenience short-hand for me.Get(&#34;Coords&#34;, n).
</p>

				
				
			
				
				<h3 id="FxOps.GetGamma">func (FxOps) <a href="/target/fx-ops.gt.go?s=13432:13479#L513">GetGamma</a></h3>
				<pre>func (me FxOps) GetGamma(n int) (op *FxOpGamma)</pre>
				<p>
Convenience short-hand for me.Get(&#34;Gamma&#34;, n).
</p>

				
				
			
				
				<h3 id="FxOps.GetGrayscale">func (FxOps) <a href="/target/fx-ops.gt.go?s=11072:11127#L435">GetGrayscale</a></h3>
				<pre>func (me FxOps) GetGrayscale(n int) (op *FxOpGrayscale)</pre>
				<p>
Convenience short-hand for me.Get(&#34;Grayscale&#34;, n).
</p>

				
				
			
				
				<h3 id="FxOps.GetOrangify">func (FxOps) <a href="/target/fx-ops.gt.go?s=10243:10296#L409">GetOrangify</a></h3>
				<pre>func (me FxOps) GetOrangify(n int) (op *FxOpOrangify)</pre>
				<p>
Convenience short-hand for me.Get(&#34;Orangify&#34;, n).
</p>

				
				
			
				
				<h3 id="FxOps.GetTex2D">func (FxOps) <a href="/target/fx-ops.gt.go?s=8640:8687#L357">GetTex2D</a></h3>
				<pre>func (me FxOps) GetTex2D(n int) (op *FxOpTex2D)</pre>
				<p>
Convenience short-hand for me.Get(&#34;Tex2D&#34;, n).
</p>

				
				
			
				
				<h3 id="FxOps.GetTexCube">func (FxOps) <a href="/target/fx-ops.gt.go?s=9430:9481#L383">GetTexCube</a></h3>
				<pre>func (me FxOps) GetTexCube(n int) (op *FxOpTexCube)</pre>
				<p>
Convenience short-hand for me.Get(&#34;TexCube&#34;, n).
</p>

				
				
			
				
				<h3 id="FxOps.Toggle">func (*FxOps) <a href="/target/fx-ops.gt.go?s=7645:7690#L321">Toggle</a></h3>
				<pre>func (me *FxOps) Toggle(procID string, n int)</pre>
				<p>
Toggles the nth (0-based) FxOp with the specified procID,
or all FxOps with the specified procID if n &lt; 0.
If me has no FxOp with the specified procID, appends a new one.
The procID must be one of the Core.Rendering.Fx.KnownProcIDs.
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.ToggleColor">func (*FxOps) <a href="/target/fx-ops.gt.go?s=12893:12928#L494">ToggleColor</a></h3>
				<pre>func (me *FxOps) ToggleColor(n int)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Color&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.ToggleCoords">func (*FxOps) <a href="/target/fx-ops.gt.go?s=12119:12155#L468">ToggleCoords</a></h3>
				<pre>func (me *FxOps) ToggleCoords(n int)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Coords&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.ToggleGamma">func (*FxOps) <a href="/target/fx-ops.gt.go?s=13665:13700#L520">ToggleGamma</a></h3>
				<pre>func (me *FxOps) ToggleGamma(n int)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Gamma&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.ToggleGrayscale">func (*FxOps) <a href="/target/fx-ops.gt.go?s=11325:11364#L442">ToggleGrayscale</a></h3>
				<pre>func (me *FxOps) ToggleGrayscale(n int)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Grayscale&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.ToggleOrangify">func (*FxOps) <a href="/target/fx-ops.gt.go?s=10491:10529#L416">ToggleOrangify</a></h3>
				<pre>func (me *FxOps) ToggleOrangify(n int)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Orangify&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.ToggleTex2D">func (*FxOps) <a href="/target/fx-ops.gt.go?s=8873:8908#L364">ToggleTex2D</a></h3>
				<pre>func (me *FxOps) ToggleTex2D(n int)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;Tex2D&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
				
				<h3 id="FxOps.ToggleTexCube">func (*FxOps) <a href="/target/fx-ops.gt.go?s=9673:9710#L390">ToggleTexCube</a></h3>
				<pre>func (me *FxOps) ToggleTexCube(n int)</pre>
				<p>
Convenience short-hand for me.Toggle(&#34;TexCube&#34;, n).
For this change to be applied, call FxEffect.UpdateRoutine() subsequently.
</p>

				
				
			
		
			
			
			<h2 id="LibFxEffects">type <a href="/target/fx-effect.gt.go?s=2630:2668#L103">LibFxEffects</a></h2>
			<pre>type LibFxEffects map[string]*FxEffect</pre>
			<p>
A hash-table of FxEffects associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxEffects.AddNew">func (LibFxEffects) <a href="/target/fx-effect.gt.go?s=2794:2850#L107">AddNew</a></h3>
				<pre>func (me LibFxEffects) AddNew(id string) (obj *FxEffect)</pre>
				<p>
Creates and initializes a new FxEffect with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxEffects.Remove">func (LibFxEffects) <a href="/target/fx-effect.gt.go?s=3049:3089#L124">Remove</a></h3>
				<pre>func (me LibFxEffects) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibFxImage2Ds">type <a href="/target/fx-image-2d.gt.go?s=1081:1121#L50">LibFxImage2Ds</a></h2>
			<pre>type LibFxImage2Ds map[string]*FxImage2D</pre>
			<p>
A hash-table of FxImage2Ds associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxImage2Ds.AddNew">func (LibFxImage2Ds) <a href="/target/fx-image-2d.gt.go?s=1248:1306#L54">AddNew</a></h3>
				<pre>func (me LibFxImage2Ds) AddNew(id string) (obj *FxImage2D)</pre>
				<p>
Creates and initializes a new FxImage2D with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxImage2Ds.Remove">func (LibFxImage2Ds) <a href="/target/fx-image-2d.gt.go?s=1509:1550#L71">Remove</a></h3>
				<pre>func (me LibFxImage2Ds) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibFxImageCubes">type <a href="/target/fx-image-cube.gt.go?s=1292:1336#L59">LibFxImageCubes</a></h2>
			<pre>type LibFxImageCubes map[string]*FxImageCube</pre>
			<p>
A hash-table of FxImageCubes associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxImageCubes.AddNew">func (LibFxImageCubes) <a href="/target/fx-image-cube.gt.go?s=1465:1527#L63">AddNew</a></h3>
				<pre>func (me LibFxImageCubes) AddNew(id string) (obj *FxImageCube)</pre>
				<p>
Creates and initializes a new FxImageCube with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxImageCubes.Remove">func (LibFxImageCubes) <a href="/target/fx-image-cube.gt.go?s=1738:1781#L80">Remove</a></h3>
				<pre>func (me LibFxImageCubes) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibFxMaterials">type <a href="/target/fx-material.gt.go?s=1510:1552#L48">LibFxMaterials</a></h2>
			<pre>type LibFxMaterials map[string]*FxMaterial</pre>
			<p>
A hash-table of FxMaterials associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibFxMaterials.AddNew">func (LibFxMaterials) <a href="/target/fx-material.gt.go?s=1680:1740#L52">AddNew</a></h3>
				<pre>func (me LibFxMaterials) AddNew(id string) (obj *FxMaterial)</pre>
				<p>
Creates and initializes a new FxMaterial with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibFxMaterials.Remove">func (LibFxMaterials) <a href="/target/fx-material.gt.go?s=1947:1989#L69">Remove</a></h3>
				<pre>func (me LibFxMaterials) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="LibMeshes">type <a href="/target/mesh.go?s=4361:4392#L113">LibMeshes</a></h2>
			<pre>type LibMeshes map[string]*Mesh</pre>
			<p>
A hash-table of Meshs associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibMeshes.AddLoad">func (LibMeshes) <a href="/target/mesh.go?s=4781:4891#L134">AddLoad</a></h3>
				<pre>func (me LibMeshes) AddLoad(id string, meshProvider MeshProvider, args ...interface{}) (mesh *Mesh, err error)</pre>
				
				
				
			
				
				<h3 id="LibMeshes.AddNew">func (LibMeshes) <a href="/target/mesh.go?s=4685:4734#L128">AddNew</a></h3>
				<pre>func (me LibMeshes) AddNew(id string) (obj *Mesh)</pre>
				<p>
Creates and initializes a new Mesh with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibMeshes.GpuSync">func (LibMeshes) <a href="/target/mesh.go?s=4394:4435#L115">GpuSync</a></h3>
				<pre>func (me LibMeshes) GpuSync() (err error)</pre>
				
				
				
			
		
			
			
			<h2 id="LibScenes">type <a href="/target/scene.gt.go?s=681:713#L27">LibScenes</a></h2>
			<pre>type LibScenes map[string]*Scene</pre>
			<p>
A hash-table of Scenes associated by IDs. Only for use in Core.Libs.
</p>


			

			

			

			

			
				
				<h3 id="LibScenes.AddNew">func (LibScenes) <a href="/target/scene.gt.go?s=836:886#L31">AddNew</a></h3>
				<pre>func (me LibScenes) AddNew(id string) (obj *Scene)</pre>
				<p>
Creates and initializes a new Scene with default parameters,
adds it to me under the specified ID, and returns it.
</p>

				
				
			
				
				<h3 id="LibScenes.Remove">func (LibScenes) <a href="/target/scene.gt.go?s=1073:1110#L48">Remove</a></h3>
				<pre>func (me LibScenes) Remove(id string)</pre>
				
				
				
			
				
				<h3 id="LibScenes.Walk">func (LibScenes) <a href="/target/scene.gt.go?s=334:378#L11">Walk</a></h3>
				<pre>func (me LibScenes) Walk(onNode NodeVisitor)</pre>
				
				
				
			
		
			
			
			<h2 id="Mesh">type <a href="/target/mesh.go?s=63:468#L1">Mesh</a></h2>
			<pre>type Mesh struct {
    Models Models
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="NewMesh">func <a href="/target/mesh.go?s=4211:4245#L106">NewMesh</a></h3>
				<pre>func NewMesh(id string) (me *Mesh)</pre>
				<p>
Initializes and returns a new Mesh with default parameters.
</p>

				
			

			
				
				<h3 id="Mesh.GpuDelete">func (*Mesh) <a href="/target/mesh.go?s=587:614#L15">GpuDelete</a></h3>
				<pre>func (me *Mesh) GpuDelete()</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUpload">func (*Mesh) <a href="/target/mesh.go?s=665:704#L21">GpuUpload</a></h3>
				<pre>func (me *Mesh) GpuUpload() (err error)</pre>
				
				
				
			
				
				<h3 id="Mesh.GpuUploaded">func (*Mesh) <a href="/target/mesh.go?s=2212:2246#L50">GpuUploaded</a></h3>
				<pre>func (me *Mesh) GpuUploaded() bool</pre>
				
				
				
			
				
				<h3 id="Mesh.Load">func (*Mesh) <a href="/target/mesh.go?s=2273:2349#L54">Load</a></h3>
				<pre>func (me *Mesh) Load(provider MeshProvider, args ...interface{}) (err error)</pre>
				
				
				
			
				
				<h3 id="Mesh.Loaded">func (*Mesh) <a href="/target/mesh.go?s=4091:4120#L101">Loaded</a></h3>
				<pre>func (me *Mesh) Loaded() bool</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffer">type <a href="/target/mesh-buffer.go?s=1724:2139#L61">MeshBuffer</a></h2>
			<pre>type MeshBuffer struct {
    MemSizeIndices, MemSizeVertices int32
    Params                          *meshBufferParams
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffer.Add">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=3048:3097#L97">Add</a></h3>
				<pre>func (me *MeshBuffer) Add(mesh *Mesh) (err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffer.Remove">func (*MeshBuffer) <a href="/target/mesh-buffer.go?s=3803:3843#L127">Remove</a></h3>
				<pre>func (me *MeshBuffer) Remove(mesh *Mesh)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshBuffers">type <a href="/target/mesh-buffer.go?s=363:419#L4">MeshBuffers</a></h2>
			<pre>type MeshBuffers struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="MeshBuffers.Add">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=531:623#L14">Add</a></h3>
				<pre>func (me *MeshBuffers) Add(id string, params *meshBufferParams) (buf *MeshBuffer, err error)</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.FloatsPerVertex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1011:1057#L35">FloatsPerVertex</a></h3>
				<pre>func (me *MeshBuffers) FloatsPerVertex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.MemSizePerIndex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1218:1264#L40">MemSizePerIndex</a></h3>
				<pre>func (me *MeshBuffers) MemSizePerIndex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.MemSizePerVertex">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1280:1327#L44">MemSizePerVertex</a></h3>
				<pre>func (me *MeshBuffers) MemSizePerVertex() int32</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.NewParams">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1407:1494#L49">NewParams</a></h3>
				<pre>func (me *MeshBuffers) NewParams(numVerts, numIndices int32) (params *meshBufferParams)</pre>
				
				
				
			
				
				<h3 id="MeshBuffers.Remove">func (*MeshBuffers) <a href="/target/mesh-buffer.go?s=1600:1640#L54">Remove</a></h3>
				<pre>func (me *MeshBuffers) Remove(id string)</pre>
				
				
				
			
		
			
			
			<h2 id="MeshData">type <a href="/target/mesh-data.go?s=2044:2252#L78">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">//	Vertex positions</span>
    Positions []MeshVA3

    <span class="comment">//	Vertex texture coordinates</span>
    TexCoords []MeshVA2

    <span class="comment">//	Vertex normals</span>
    Normals []MeshVA3

    <span class="comment">//	Indexed triangle definitions</span>
    Faces []MeshF3
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="MeshProviderPrefabCube">func <a href="/target/mesh-provider.go?s=306:386#L1">MeshProviderPrefabCube</a></h3>
				<pre>func MeshProviderPrefabCube(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a cube with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 12 triangle faces with IDs &#34;t0&#34; through &#34;t11&#34;.
These faces are classified in 6 distinct tags: &#34;front&#34;,&#34;back&#34;,&#34;top&#34;,&#34;bottom&#34;,&#34;right&#34;,&#34;left&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabPlane">func <a href="/target/mesh-provider.go?s=2168:2249#L46">MeshProviderPrefabPlane</a></h3>
				<pre>func MeshProviderPrefabPlane(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a flat ground plane with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 2 triangle faces with IDs &#34;t0&#34; through &#34;t1&#34;.
These faces are all classified with tag: &#34;plane&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabPyramid">func <a href="/target/mesh-provider.go?s=2942:3025#L61">MeshProviderPrefabPyramid</a></h3>
				<pre>func MeshProviderPrefabPyramid(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a pyramid with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 4 triangle faces with IDs &#34;t0&#34; through &#34;t3&#34;.
These faces are all classified with tag: &#34;pyr&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabQuad">func <a href="/target/mesh-provider.go?s=3913:3993#L78">MeshProviderPrefabQuad</a></h3>
				<pre>func MeshProviderPrefabQuad(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a quad with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 2 triangle faces with IDs &#34;t0&#34; through &#34;t1&#34;.
These faces are all classified with tag: &#34;quad&#34;.
</p>

				
			
				
				<h3 id="MeshProviderPrefabTri">func <a href="/target/mesh-provider.go?s=4621:4700#L92">MeshProviderPrefabTri</a></h3>
				<pre>func MeshProviderPrefabTri(args ...interface{}) (meshData *MeshData, err error)</pre>
				<p>
A MeshProvider that creates MeshData for a triangle with extents -1 .. 1.
args is ignored and err is always nil.
The returned MeshData contains 1 triangle face with ID &#34;t0&#34; and tag &#34;tri&#34;.
</p>

				
			
				
				<h3 id="NewMeshData">func <a href="/target/mesh-data.go?s=2308:2341#L93">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
				
				<h3 id="MeshData.AddFaces">func (*MeshData) <a href="/target/mesh-data.go?s=2419:2465#L99">AddFaces</a></h3>
				<pre>func (me *MeshData) AddFaces(faces ...*MeshF3)</pre>
				<p>
Adds all specified Faces to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddNormals">func (*MeshData) <a href="/target/mesh-data.go?s=2748:2798#L111">AddNormals</a></h3>
				<pre>func (me *MeshData) AddNormals(normals ...MeshVA3)</pre>
				<p>
Adds all the specified Normals to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddPositions">func (*MeshData) <a href="/target/mesh-data.go?s=2585:2639#L106">AddPositions</a></h3>
				<pre>func (me *MeshData) AddPositions(positions ...MeshVA3)</pre>
				<p>
Adds all specified Positions to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddTexCoords">func (*MeshData) <a href="/target/mesh-data.go?s=2903:2957#L116">AddTexCoords</a></h3>
				<pre>func (me *MeshData) AddTexCoords(texCoords ...MeshVA2)</pre>
				<p>
Adds all the specified TexCoords to this MeshData.
</p>

				
				
			
		
			
			
			<h2 id="MeshF3">type <a href="/target/mesh-data.go?s=435:547#L11">MeshF3</a></h2>
			<pre>type MeshF3 struct {
    <span class="comment">//	The indexed vertices making up this triangle.</span>
    V [3]MeshV

    <span class="comment">//	ID, Tags</span>
    MeshFaceBase
}</pre>
			<p>
Represents an indexed triangle.
</p>


			

			

			

			
				
				<h3 id="NewMeshF3">func <a href="/target/mesh-data.go?s=759:819#L22">NewMeshF3</a></h3>
				<pre>func NewMeshF3(tags, id string, verts ...MeshV) (me *MeshF3)</pre>
				<p>
Creates and initializes a new MeshV with the specified tags,
ID and verts, and returns it. tags may be empty or contain multiple
classification tags separated by spaces, which will be split into Tags.
</p>

				
			

			
		
			
			
			<h2 id="MeshFaceBase">type <a href="/target/mesh-data.go?s=252:398#L2">MeshFaceBase</a></h2>
			<pre>type MeshFaceBase struct {
    <span class="comment">//	Mesh-unique identifier for this face.</span>
    ID string

    <span class="comment">//	Arbitrary classification tags for this face.</span>
    Tags []string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/mesh-data.go?s=188:250#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Provides MeshData for constructing a Mesh. An implementation
might load a certain file format or procedurally generate
the returned MeshData.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshV">type <a href="/target/mesh-data.go?s=1556:1740#L58">MeshV</a></h2>
			<pre>type MeshV struct {
    <span class="comment">//	Index of the vertex position</span>
    PosIndex uint32

    <span class="comment">//	Index of the texture-coordinate.</span>
    TexCoordIndex uint32

    <span class="comment">//	Index of the vertex normal.</span>
    NormalIndex uint32
}</pre>
			<p>
Represents an indexed vertex in a MeshF3.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVA2">type <a href="/target/mesh-data.go?s=1847:1870#L71">MeshVA2</a></h2>
			<pre>type MeshVA2 [2]float32</pre>
			<p>
Represents a 2-component vertex attribute in a MeshData.
(such as for example texture-coordinates)
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVA3">type <a href="/target/mesh-data.go?s=1971:1994#L75">MeshVA3</a></h2>
			<pre>type MeshVA3 [3]float32</pre>
			<p>
Represents a 3-component vertex attribute in a MeshData
(such as for example vertex-normals)
</p>


			

			

			

			

			
		
			
			
			<h2 id="Model">type <a href="/target/model.go?s=593:674#L8">Model</a></h2>
			<pre>type Model struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Model is a parameterized instantiation of its parent Mesh geometry
with unique appearance, material or other properties.
</p>
<p>
Each Mesh provides at least one Model, the &#34;default model&#34; (with ID &#34;&#34;),
accessible via someMesh.Models.Default(). To create new models for a Mesh,
call someMesh.Models[&#34;sourceModelID&#34;].Clone(&#34;newModelID&#34;).
</p>


			

			

			

			

			
				
				<h3 id="Model.Clone">func (*Model) <a href="/target/model.go?s=881:943#L22">Clone</a></h3>
				<pre>func (me *Model) Clone(newModelID string) (clonedModel *Model)</pre>
				<p>
Creates a copy of me and adds it to the parent Mesh&#39;s Models
hash-table under the specified newModelID.
</p>

				
				
			
				
				<h3 id="Model.MatID">func (*Model) <a href="/target/model.go?s=1116:1147#L30">MatID</a></h3>
				<pre>func (me *Model) MatID() string</pre>
				
				
				
			
				
				<h3 id="Model.SetMatID">func (*Model) <a href="/target/model.go?s=1170:1212#L34">SetMatID</a></h3>
				<pre>func (me *Model) SetMatID(newMatID string)</pre>
				
				
				
			
		
			
			
			<h2 id="Models">type <a href="/target/model.go?s=96:125#L1">Models</a></h2>
			<pre>type Models map[string]*Model</pre>
			<p>
A hash-table of Models associated with their ID.
Used only for Mesh.Models.
</p>


			

			

			

			

			
				
				<h3 id="Models.Default">func (Models) <a href="/target/model.go?s=190:223#L1">Default</a></h3>
				<pre>func (me Models) Default() *Model</pre>
				<p>
Returns the default Model (with ID &#34;&#34;) for the parent Mesh.
</p>

				
				
			
		
			
			
			<h2 id="Node">type <a href="/target/node.go?s=271:1223#L5">Node</a></h2>
			<pre>type Node struct {
    Rendering struct {
        <span class="comment">//	Defaults to true. If false, this Node is ignored by the rendering runtime.</span>
        Enabled bool
        <span class="comment">// contains filtered or unexported fields</span>
    }

    <span class="comment">//	Allows the Node to recursively define hierarchy.</span>
    ChildNodes Nodes

    <span class="comment">//	Encapsulates all parent-relative transformations for this Node.</span>
    Transform NodeTransform
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Declares a point of interest in a Scene.
</p>


			

			

			

			

			
				
				<h3 id="Node.EffectiveMaterial">func (*Node) <a href="/target/node.go?s=1547:1594#L57">EffectiveMaterial</a></h3>
				<pre>func (me *Node) EffectiveMaterial() *FxMaterial</pre>
				
				
				
			
				
				<h3 id="Node.MatID">func (*Node) <a href="/target/node.go?s=2145:2175#L79">MatID</a></h3>
				<pre>func (me *Node) MatID() string</pre>
				
				
				
			
				
				<h3 id="Node.MeshID">func (*Node) <a href="/target/node.go?s=2198:2229#L83">MeshID</a></h3>
				<pre>func (me *Node) MeshID() string</pre>
				
				
				
			
				
				<h3 id="Node.ModelID">func (*Node) <a href="/target/node.go?s=2253:2285#L87">ModelID</a></h3>
				<pre>func (me *Node) ModelID() string</pre>
				
				
				
			
				
				<h3 id="Node.Root">func (*Node) <a href="/target/node.go?s=2310:2345#L91">Root</a></h3>
				<pre>func (me *Node) Root() (root *Node)</pre>
				
				
				
			
				
				<h3 id="Node.SetMatID">func (*Node) <a href="/target/node.go?s=2441:2482#L100">SetMatID</a></h3>
				<pre>func (me *Node) SetMatID(newMatID string)</pre>
				
				
				
			
				
				<h3 id="Node.SetMeshModelID">func (*Node) <a href="/target/node.go?s=2579:2633#L106">SetMeshModelID</a></h3>
				<pre>func (me *Node) SetMeshModelID(meshID, modelID string)</pre>
				
				
				
			
				
				<h3 id="Node.Walk">func (*Node) <a href="/target/node.go?s=2937:2977#L120">Walk</a></h3>
				<pre>func (me *Node) Walk(onNode NodeVisitor)</pre>
				
				
				
			
		
			
			
			<h2 id="NodeTransform">type <a href="/target/node-transform.go?s=487:837#L4">NodeTransform</a></h2>
			<pre>type NodeTransform struct {
    <span class="comment">//	Translation of the from origin.</span>
    Pos unum.Vec3

    <span class="comment">//	Rotation for each axis in radians.</span>
    Rot unum.Vec3

    <span class="comment">//	Scaling of this node, if any. Defaults to (1, 1, 1) for no scaling.</span>
    Scale unum.Vec3

    <span class="comment">//	An arbitrary additional transformation to apply, if any.</span>
    Other *unum.Mat4
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents one or more transformations of a Node.
This is only used by Node objects, which initialize their NodeTransform with the
proper defaults and associate themselves with their NodeTransform. (Any other
NodeTransform are invalid.)
</p>
<p>
A single NodeTransform encapsulates an unexported 4x4 matrix that is recalculated
from its exported fields via the AddFoo(), SetFoo() or ApplyMatrices() methods.
</p>


			

			

			

			

			
				
				<h3 id="NodeTransform.AddRot">func (*NodeTransform) <a href="/target/node-transform.go?s=1065:1112#L29">AddRot</a></h3>
				<pre>func (me *NodeTransform) AddRot(rot *unum.Vec3)</pre>
				<p>
Adds the specified vector to me.Rot and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.AddRotXYZ">func (*NodeTransform) <a href="/target/node-transform.go?s=1221:1272#L35">AddRotXYZ</a></h3>
				<pre>func (me *NodeTransform) AddRotXYZ(x, y, z float64)</pre>
				<p>
Adds the specified values to me.Rot and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.ApplyMatrices">func (*NodeTransform) <a href="/target/node-transform.go?s=1466:1506#L42">ApplyMatrices</a></h3>
				<pre>func (me *NodeTransform) ApplyMatrices()</pre>
				<p>
Updates the internal 4x4 transformation matrix for all transformations
in me. It is only this matrix that is used by the rendering runtime.
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPos">func (*NodeTransform) <a href="/target/node-transform.go?s=2336:2383#L60">SetPos</a></h3>
				<pre>func (me *NodeTransform) SetPos(pos *unum.Vec3)</pre>
				<p>
Sets me.Pos and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPosX">func (*NodeTransform) <a href="/target/node-transform.go?s=2468:2514#L66">SetPosX</a></h3>
				<pre>func (me *NodeTransform) SetPosX(posX float64)</pre>
				<p>
Sets me.Pos.X and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPosXYZ">func (*NodeTransform) <a href="/target/node-transform.go?s=2599:2659#L72">SetPosXYZ</a></h3>
				<pre>func (me *NodeTransform) SetPosXYZ(posX, posY, posZ float64)</pre>
				<p>
Sets me.Pos and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPosY">func (*NodeTransform) <a href="/target/node-transform.go?s=2778:2824#L78">SetPosY</a></h3>
				<pre>func (me *NodeTransform) SetPosY(posY float64)</pre>
				<p>
Sets me.Pos.Y and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetPosZ">func (*NodeTransform) <a href="/target/node-transform.go?s=2911:2957#L84">SetPosZ</a></h3>
				<pre>func (me *NodeTransform) SetPosZ(posZ float64)</pre>
				<p>
Sets me.Pos.Z and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRot">func (*NodeTransform) <a href="/target/node-transform.go?s=3042:3089#L90">SetRot</a></h3>
				<pre>func (me *NodeTransform) SetRot(rot *unum.Vec3)</pre>
				<p>
Sets me.Rot and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRotX">func (*NodeTransform) <a href="/target/node-transform.go?s=3174:3219#L96">SetRotX</a></h3>
				<pre>func (me *NodeTransform) SetRotX(rad float64)</pre>
				<p>
Sets me.Rot.X and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRotXYZ">func (*NodeTransform) <a href="/target/node-transform.go?s=3303:3363#L102">SetRotXYZ</a></h3>
				<pre>func (me *NodeTransform) SetRotXYZ(radX, radY, radZ float64)</pre>
				<p>
Sets me.Rot and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRotY">func (*NodeTransform) <a href="/target/node-transform.go?s=3482:3527#L108">SetRotY</a></h3>
				<pre>func (me *NodeTransform) SetRotY(rad float64)</pre>
				<p>
Sets me.Rot.Y and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetRotZ">func (*NodeTransform) <a href="/target/node-transform.go?s=3613:3658#L114">SetRotZ</a></h3>
				<pre>func (me *NodeTransform) SetRotZ(rad float64)</pre>
				<p>
Sets me.Rot.Z and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetScale">func (*NodeTransform) <a href="/target/node-transform.go?s=3744:3795#L120">SetScale</a></h3>
				<pre>func (me *NodeTransform) SetScale(scale *unum.Vec3)</pre>
				<p>
Sets me.Scale and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetScaleN">func (*NodeTransform) <a href="/target/node-transform.go?s=3884:3933#L126">SetScaleN</a></h3>
				<pre>func (me *NodeTransform) SetScaleN(scale float64)</pre>
				<p>
Sets me.Scale and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.SetScaleXYZ">func (*NodeTransform) <a href="/target/node-transform.go?s=4020:4073#L131">SetScaleXYZ</a></h3>
				<pre>func (me *NodeTransform) SetScaleXYZ(x, y, z float64)</pre>
				<p>
Sets me.Scale and calls ApplyMatrices().
</p>

				
				
			
				
				<h3 id="NodeTransform.StepDelta">func (*NodeTransform) <a href="/target/node-transform.go?s=4224:4290#L137">StepDelta</a></h3>
				<pre>func (me *NodeTransform) StepDelta(deltaPerSecond float64) float64</pre>
				<p>
Returns the result of multiplying deltaPerSecond with EngineLoop.TickDelta.
</p>

				
				
			
		
			
			
			<h2 id="NodeVisitor">type <a href="/target/node.go?s=197:225#L2">NodeVisitor</a></h2>
			<pre>type NodeVisitor func(*Node)</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Nodes">type <a href="/target/nodes.go?s=77:277#L1">Nodes</a></h2>
			<pre>type Nodes struct {
    <span class="comment">//	The underlying hash-table. NOT to be modified directly.</span>
    <span class="comment">//	ONLY use the methods defined on the Nodes type to add,</span>
    <span class="comment">//	remove or move nodes.</span>
    M map[string]*Node
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A hash-table of child nodes. Only used for Node.ChildNodes.
</p>


			

			

			

			

			
				
				<h3 id="Nodes.Add">func (*Nodes) <a href="/target/nodes.go?s=456:488#L10">Add</a></h3>
				<pre>func (me *Nodes) Add(node *Node)</pre>
				<p>
Removes node from its previous parent Node (if any)
and adds it to me.M under its ID.
</p>

				
				
			
				
				<h3 id="Nodes.AddNew">func (*Nodes) <a href="/target/nodes.go?s=743:807#L20">AddNew</a></h3>
				<pre>func (me *Nodes) AddNew(id, meshID, modelID string) (node *Node)</pre>
				<p>
Creates a new Node with the specified ID, binds it to the
specified Mesh and Model, adds it to me.M and returns it.
</p>

				
				
			
				
				<h3 id="Nodes.Remove">func (*Nodes) <a href="/target/nodes.go?s=955:989#L27">Remove</a></h3>
				<pre>func (me *Nodes) Remove(id string)</pre>
				<p>
Removes the Node with the specified ID from me.M.
</p>

				
				
			
		
			
			
			<h2 id="RenderBatch">type <a href="/target/render-batch.go?s=1802:1920#L70">RenderBatch</a></h2>
			<pre>type RenderBatch struct {
    Enabled  bool
    Priority [3]RenderBatchCriteria
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderBatchCriteria">type <a href="/target/render-batch.go?s=14:42#L1">RenderBatchCriteria</a></h2>
			<pre>type RenderBatchCriteria int</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderCanvas">type <a href="/target/render-canvas.go?s=181:764#L1">RenderCanvas</a></h2>
			<pre>type RenderCanvas struct {
    <span class="comment">//	This should be an non-negative integer, it&#39;s a float64 just to avoid a</span>
    <span class="comment">//	type conversion. How often this RenderCanvas is included in rendering:</span>
    <span class="comment">//	1 = every frame (this is the default value)</span>
    <span class="comment">//	2 = every 2nd frame</span>
    <span class="comment">//	3, 5, 8 etc. = every 3rd, 5th, 8th etc. frame</span>
    <span class="comment">//	0 = this RenderCanvas is disabled for rendering</span>
    EveryNthFrame float64

    Cameras Cameras

    Srgb bool
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Represents a surface (texture framebuffer) that can be rendered to.
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvas.AddNewCamera2D">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1540:1612#L42">AddNewCamera2D</a></h3>
				<pre>func (me *RenderCanvas) AddNewCamera2D(allowOverlaps bool) (cam *Camera)</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.AddNewCamera3D">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1729:1783#L49">AddNewCamera3D</a></h3>
				<pre>func (me *RenderCanvas) AddNewCamera3D() (cam *Camera)</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.AddNewCameraQuad">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1885:1941#L56">AddNewCameraQuad</a></h3>
				<pre>func (me *RenderCanvas) AddNewCameraQuad() (cam *Camera)</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.CurrentAbsoluteSize">func (*RenderCanvas) <a href="/target/render-canvas.go?s=1410:1475#L37">CurrentAbsoluteSize</a></h3>
				<pre>func (me *RenderCanvas) CurrentAbsoluteSize() (width, height int)</pre>
				
				
				
			
				
				<h3 id="RenderCanvas.Remove">func (*RenderCanvas) <a href="/target/render-canvas.go?s=2685:2717#L85">Remove</a></h3>
				<pre>func (me *RenderCanvas) Remove()</pre>
				<p>
Removes me from Core.Rendering.Canvases and deletes its associated GPU resources.
This renders me invalid for further use.
</p>

				
				
			
				
				<h3 id="RenderCanvas.SetSize">func (*RenderCanvas) <a href="/target/render-canvas.go?s=3314:3383#L104">SetSize</a></h3>
				<pre>func (me *RenderCanvas) SetSize(relative bool, width, height float64)</pre>
				<p>
Sets the 2 dimensions of this render canvas.
If relative is true, width and height are interpreted relative to the resolution of the OpenGL context&#39;s default framebuffer, with 1 being 100%.
Otherwise, width and height are absolute pixel dimensions.
</p>

				
				
			
		
			
			
			<h2 id="RenderCanvases">type <a href="/target/render-canvas.go?s=3672:3707#L114">RenderCanvases</a></h2>
			<pre>type RenderCanvases []*RenderCanvas</pre>
			<p>
Only used for Core.Rendering.Canvases.
</p>


			

			

			

			

			
				
				<h3 id="RenderCanvases.AddNew">func (RenderCanvases) <a href="/target/render-canvas.go?s=3922:4009#L125">AddNew</a></h3>
				<pre>func (_ RenderCanvases) AddNew(relative bool, width, height float64) (rc *RenderCanvas)</pre>
				<p>
Adds a new RenderCanvas and returns it.
The relative, width and height values are passed to a call to SetSize().
</p>

				
				
			
				
				<h3 id="RenderCanvases.Final">func (RenderCanvases) <a href="/target/render-canvas.go?s=4167:4212#L132">Final</a></h3>
				<pre>func (_ RenderCanvases) Final() *RenderCanvas</pre>
				
				
				
			
				
				<h3 id="RenderCanvases.Walk">func (RenderCanvases) <a href="/target/render-canvas.go?s=4253:4330#L136">Walk</a></h3>
				<pre>func (_ RenderCanvases) Walk(onCanv func(*RenderCanvas), onCam func(*Camera))</pre>
				
				
				
			
		
			
			
			<h2 id="RenderTechnique">type <a href="/target/render-technique.go?s=78:148#L1">RenderTechnique</a></h2>
			<pre>type RenderTechnique interface {
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderTechniqueProvider">type <a href="/target/render-technique.go?s=14:76#L1">RenderTechniqueProvider</a></h2>
			<pre>type RenderTechniqueProvider func(cam *Camera) RenderTechnique</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderTechniqueQuad">type <a href="/target/render-technique-quad.go?s=64:179#L1">RenderTechniqueQuad</a></h2>
			<pre>type RenderTechniqueQuad struct {
    Effect FxEffect
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="RenderTechniqueScene">type <a href="/target/render-technique-scene.go?s=101:177#L1">RenderTechniqueScene</a></h2>
			<pre>type RenderTechniqueScene struct {
    Batch RenderBatch
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="RenderTechniqueScene.ToggleBatching">func (*RenderTechniqueScene) <a href="/target/render-technique-scene.go?s=351:399#L11">ToggleBatching</a></h3>
				<pre>func (me *RenderTechniqueScene) ToggleBatching()</pre>
				
				
				
			
		
			
			
			<h2 id="RenderTechniques">type <a href="/target/render-technique.go?s=469:517#L18">RenderTechniques</a></h2>
			<pre>type RenderTechniques map[string]RenderTechnique</pre>
			<p>
Used only in Core.Rendering.Techniques.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Scene">type <a href="/target/scene.gt.go?s=43:119#L1">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	The root Node for this scene graph.</span>
    RootNode Node
}</pre>
			<p>
Represents a scene graph.
</p>


			

			

			

			
				
				<h3 id="NewScene">func <a href="/target/scene.gt.go?s=542:569#L20">NewScene</a></h3>
				<pre>func NewScene() (me *Scene)</pre>
				<p>
Initializes and returns a new Scene with default parameters.
</p>

				
			

			
		
			
			
			<h2 id="TimingStats">type <a href="/target/ng-stats.go?s=4450:4622#L99">TimingStats</a></h2>
			<pre>type TimingStats struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Helps track average and maximum cost for a variety of performance indicators.
</p>


			

			

			

			

			
				
				<h3 id="TimingStats.Average">func (*TimingStats) <a href="/target/ng-stats.go?s=4691:4731#L105">Average</a></h3>
				<pre>func (me *TimingStats) Average() float64</pre>
				<p>
Returns the average cost tracked by this performance indicator.
</p>

				
				
			
				
				<h3 id="TimingStats.Max">func (*TimingStats) <a href="/target/ng-stats.go?s=5401:5437#L134">Max</a></h3>
				<pre>func (me *TimingStats) Max() float64</pre>
				<p>
Returns the maximum cost tracked by this performance indicator.
</p>

				
				
			
		
			
			
			<h2 id="WindowOptions">type <a href="/target/ng-window.go?s=239:599#L1">WindowOptions</a></h2>
			<pre>type WindowOptions struct {
    <span class="comment">//	Minimum delay, in seconds, to wait after the last window-resize event received from</span>
    <span class="comment">//	the OS before notifying the rendering runtime of the new window dimensions.</span>
    <span class="comment">//	Defaults to 0.15.</span>
    ResizeMinDelay float64
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Only used for core.UserIO.Window after initialization, BUT: core.UserIO.Window gets
initialized from a copy of your NewWindowOptions() that you pass to your NewEngineOptions().
</p>


			

			

			

			

			
				
				<h3 id="WindowOptions.Created">func (*WindowOptions) <a href="/target/ng-window.go?s=601:640#L11">Created</a></h3>
				<pre>func (me *WindowOptions) Created() bool</pre>
				
				
				
			
				
				<h3 id="WindowOptions.Fullscreen">func (*WindowOptions) <a href="/target/ng-window.go?s=688:730#L15">Fullscreen</a></h3>
				<pre>func (me *WindowOptions) Fullscreen() bool</pre>
				
				
				
			
				
				<h3 id="WindowOptions.Height">func (*WindowOptions) <a href="/target/ng-window.go?s=805:842#L20">Height</a></h3>
				<pre>func (me *WindowOptions) Height() int</pre>
				<p>
Returns the height of the window in pixels.
</p>

				
				
			
				
				<h3 id="WindowOptions.SetSize">func (*WindowOptions) <a href="/target/ng-window.go?s=866:917#L24">SetSize</a></h3>
				<pre>func (me *WindowOptions) SetSize(width, height int)</pre>
				
				
				
			
				
				<h3 id="WindowOptions.SetSwapInterval">func (*WindowOptions) <a href="/target/ng-window.go?s=1018:1071#L30">SetSwapInterval</a></h3>
				<pre>func (me *WindowOptions) SetSwapInterval(newSwap int)</pre>
				
				
				
			
				
				<h3 id="WindowOptions.SetTitle">func (*WindowOptions) <a href="/target/ng-window.go?s=1188:1238#L38">SetTitle</a></h3>
				<pre>func (me *WindowOptions) SetTitle(newTitle string)</pre>
				<p>
Sets the window title to newTitle.
</p>

				
				
			
				
				<h3 id="WindowOptions.SwapInterval">func (*WindowOptions) <a href="/target/ng-window.go?s=1319:1362#L45">SwapInterval</a></h3>
				<pre>func (me *WindowOptions) SwapInterval() int</pre>
				
				
				
			
				
				<h3 id="WindowOptions.Title">func (*WindowOptions) <a href="/target/ng-window.go?s=1384:1423#L49">Title</a></h3>
				<pre>func (me *WindowOptions) Title() string</pre>
				
				
				
			
				
				<h3 id="WindowOptions.Width">func (*WindowOptions) <a href="/target/ng-window.go?s=1492:1528#L54">Width</a></h3>
				<pre>func (me *WindowOptions) Width() int</pre>
				<p>
Returns the width of the window in pixels.
</p>

				
				
			
		
		</div>
	

	








		</div></div>
	</body>
</html>