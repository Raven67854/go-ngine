<html>
	<head>
		<title>Package github.com/go3d/go-ngine/assets</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/assets</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/assets"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *assets* package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.
</p>
<p>
________
</p>
<p>
First off, the go:ngine 3 RULES of bugless(er) development:
</p>
<p>
1. you do NOT set exported fields directly, those are provided for simplified read-access. If a field is
meant to be modifiable, there will be a *SetFoo()* method or it will be documented explicitly as directly
modifiable, but such instances will be rare.
</p>
<p>
2. you do NOT instantiate exported struct types directly, as in &#34;new(ImageDef)&#34; or &#34;&amp;ImageDef {}&#34;. Many of
those are exported only for documentation, but are to be instantiated only inside the go:ngine package.
For types to be instantiated by package-external code (ie. your code), go:ngine packages provide constructor
functions -- often in collections, ie. img := ImageDefs.New(&#34;id&#34;) instead of, say, img := NewImageDef(&#34;id&#34;).
</p>
<p>
3. Those 2 are *default* assumptions and modes of operation -- there are a few &#34;if you know what you&#39;re
doing&#34; exemptions and those are (or will be) explicitly documented as such.
</p>
<p>
________
</p>
<p>
The *assets* package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.
These data structures only describe resource definitions and instances, but do not provide
any specific logic or algorithms, such as physics or visual rendering.
</p>
<p>
Context: any go:ngine app uses a variety of both simple and complex resource types, including for
example geometry definitions, image textures, material and light descriptions and many others.
</p>
<p>
While for all these resource types, the go:ngine *core* package manages their respective run-time
representation in its entirety,	some basic part of that representation is &#34;merely descriptive&#34; and
should be readable from or writable to a binary stream (&#34;design-time&#34;). That &#34;merely descriptive&#34;
sub-set of resource definitions is fully contained in this go:ngine *assets* package and thus decoupled
from the go:ngine *core* package.
</p>
<p>
This *assets* package thus allows for things such as server-side procedural asset generators, networked
resource streaming or simple custom asset-import/export/conversion tools, all of which shouldn&#39;t have to
needlessly depend on the graphics, windowing etc. stacks.
</p>
<p>
NOTE: there are essentially TWO distinct &#34;modes&#34; or use-cases in which the *assets* package is active:
</p>
<p>
1. in graphics-independent, server-side or non-interactive &#34;toolage&#34;, dealing only with the raw resource
data where it can be generated, loaded, stored, manipulated at will with no particular repercussions.
</p>
<p>
2. in an interactive graphical go:ngine app that also has the *core* package loaded:
</p>
<p>
All &#34;Sync&#34;-related functions pertain to use-case #2, where the *assets* package essentially becomes the
live repository for all resource definitions loaded, used, or manipulated by the *core* package at runtime.
So now every image definition in *assets* may have a corresponding GPU-bound texture object in *core*, every
*assets* mesh definition may be bound to a *core* *MeshBuffer*, etc.
</p>
<p>
Structure: generally speaking, all resource types are organized in a consistent fashion as follows ---
users familiar with the COLLADA format will notice a stark resemblance in terminology and resource organization:
</p>
<p>
1. First, there is a *FooDef* struct for the one-time definition of a unique resource:
GeometryMeshDef, ImageDef, LightDef, MaterialDef etc.
</p>
<p>
2. Next, there is a smaller *FooInst* struct for handling many individual (sometimes parameterized) instances of
an *FooDef*: GeometryMeshInst, ImageInst, LightInst, MaterialInst etc.
</p>
<p>
3. Finally, there is a light-weight *LibFooDefs* struct type (based on a *map* collection) containing Defs
associated with their ID: LibGeometryMeshDefs, LibImageDefs, LibLightDefs, LibMaterialDefs etc.
</p>
<p>
4. The package also provides a pre-initialized global *FooDefs* variable for each such Lib type, in simple apps
considered the &#34;default / main / only Lib you&#39;ll need&#34;: GeometryMeshDefs, ImageDefs, LightDefs, MaterialDefs etc.
</p>
<p>
5. For more complex use-cases, you can also organize multiple libs for any given resource type in the global
*AllFooDefLibs* variable, essentially a *map* collection of Libs: AllGeometryMeshDefLibs (of type
LibsGeometryMeshDef), AllImageDefLibs (of type LibsImageDef), AllLightDefLibs (of type LibsLightDef),
AllMaterialDefLibs (of type LibsMaterialDef) etc.
</p>
<p>
Any exported types in this package not following the above pattern (such as MeshData etc.) should be
considered &#34;auxiliary helpers&#34; rather than primary / &#34;first-class&#34; resource types.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#SyncChanges">func SyncChanges()</a></dd>
			
			
				
				<dd><a href="#Base">type Base</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SetDirty">func (me *Base) SetDirty()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SyncChanges">func (me *Base) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#BaseDef">type BaseDef</a></dd>
				
				
			
				
				<dd><a href="#BaseInst">type BaseInst</a></dd>
				
				
			
				
				<dd><a href="#BaseLib">type BaseLib</a></dd>
				
				
			
				
				<dd><a href="#CameraDef">type CameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.NewInst">func (me *CameraDef) NewInst(id string) (inst *CameraInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetFovY">func (me *CameraDef) SetFovY(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetMagX">func (me *CameraDef) SetMagX(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetMagY">func (me *CameraDef) SetMagY(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetOrtho">func (me *CameraDef) SetOrtho(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetZfar">func (me *CameraDef) SetZfar(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetZnear">func (me *CameraDef) SetZnear(v float64)</a></dd>
				
			
				
				<dd><a href="#CameraInst">type CameraInst</a></dd>
				
				
			
				
				<dd><a href="#ImageDef">type ImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ImageDef.NewInst">func (me *ImageDef) NewInst(id string) (inst *ImageInst)</a></dd>
				
			
				
				<dd><a href="#ImageInitFrom">type ImageInitFrom</a></dd>
				
				
			
				
				<dd><a href="#ImageInst">type ImageInst</a></dd>
				
				
			
				
				<dd><a href="#LibCameraDefs">type LibCameraDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Add">func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.AddNew">func (me *LibCameraDefs) AddNew(id string) *CameraDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.New">func (me *LibCameraDefs) New(id string) (def *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Remove">func (me *LibCameraDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.SyncChanges">func (me *LibCameraDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibImageDefs">type LibImageDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.Add">func (me *LibImageDefs) Add(d *ImageDef) (n *ImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.AddNew">func (me *LibImageDefs) AddNew(id string) *ImageDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.New">func (me *LibImageDefs) New(id string) (def *ImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.Remove">func (me *LibImageDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.SyncChanges">func (me *LibImageDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibMaterialDefs">type LibMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.Add">func (me *LibMaterialDefs) Add(d *MaterialDef) (n *MaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.AddNew">func (me *LibMaterialDefs) AddNew(id string) *MaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.New">func (me *LibMaterialDefs) New(id string) (def *MaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.Remove">func (me *LibMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.SyncChanges">func (me *LibMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibNodeDefs">type LibNodeDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Add">func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.AddNew">func (me *LibNodeDefs) AddNew(id string) *NodeDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.New">func (me *LibNodeDefs) New(id string) (def *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Remove">func (me *LibNodeDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.SyncChanges">func (me *LibNodeDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibSceneDefs">type LibSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibSceneDefs.Add">func (me *LibSceneDefs) Add(d *SceneDef) (n *SceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibSceneDefs.AddNew">func (me *LibSceneDefs) AddNew(id string) *SceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibSceneDefs.New">func (me *LibSceneDefs) New(id string) (def *SceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibSceneDefs.Remove">func (me *LibSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibSceneDefs.SyncChanges">func (me *LibSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibVisualSceneDefs">type LibVisualSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Add">func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.AddNew">func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.New">func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Remove">func (me *LibVisualSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.SyncChanges">func (me *LibVisualSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibsCameraDef">type LibsCameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsCameraDef.AddNew">func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</a></dd>
				
			
				
				<dd><a href="#LibsImageDef">type LibsImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsImageDef.AddNew">func (me LibsImageDef) AddNew(id string) (lib *LibImageDefs)</a></dd>
				
			
				
				<dd><a href="#LibsMaterialDef">type LibsMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsMaterialDef.AddNew">func (me LibsMaterialDef) AddNew(id string) (lib *LibMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsNodeDef">type LibsNodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsNodeDef.AddNew">func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</a></dd>
				
			
				
				<dd><a href="#LibsSceneDef">type LibsSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsSceneDef.AddNew">func (me LibsSceneDef) AddNew(id string) (lib *LibSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LibsVisualSceneDef">type LibsVisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsVisualSceneDef.AddNew">func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</a></dd>
				
			
				
				<dd><a href="#MaterialDef">type MaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MaterialDef.NewInst">func (me *MaterialDef) NewInst(id string) (inst *MaterialInst)</a></dd>
				
			
				
				<dd><a href="#MaterialInst">type MaterialInst</a></dd>
				
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddFaces">func (me *MeshData) AddFaces(faces ...MeshFace3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddNormals">func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddPositions">func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddTexCoords">func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</a></dd>
				
			
				
				<dd><a href="#MeshFace3">type MeshFace3</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#MeshRaw">type MeshRaw</a></dd>
				
				
			
				
				<dd><a href="#MeshRawFace">type MeshRawFace</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshRawFace">func NewMeshRawFace() (me *MeshRawFace)</a></dd>
				
				
			
				
				<dd><a href="#MeshVert">type MeshVert</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt2">type MeshVertAtt2</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt3">type MeshVertAtt3</a></dd>
				
				
			
				
				<dd><a href="#NodeDef">type NodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.NewInst">func (me *NodeDef) NewInst(id string) (inst *NodeInst)</a></dd>
				
			
				
				<dd><a href="#NodeInst">type NodeInst</a></dd>
				
				
			
				
				<dd><a href="#SceneDef">type SceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SceneDef.NewInst">func (me *SceneDef) NewInst(id string) (inst *SceneInst)</a></dd>
				
			
				
				<dd><a href="#SceneInst">type SceneInst</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneDef">type VisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneDef.NewInst">func (me *VisualSceneDef) NewInst(id string) (inst *VisualSceneInst)</a></dd>
				
			
				
				<dd><a href="#VisualSceneInst">type VisualSceneInst</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/assets.go">assets.go</a>
			
				<a href="/target/base.go">base.go</a>
			
				<a href="/target/camera.gt.go">camera.gt.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/image.gt.go">image.gt.go</a>
			
				<a href="/target/material.gt.go">material.gt.go</a>
			
				<a href="/target/meshdata.go">meshdata.go</a>
			
				<a href="/target/node.gt.go">node.gt.go</a>
			
				<a href="/target/scene.gt.go">scene.gt.go</a>
			
				<a href="/target/visualscene.gt.go">visualscene.gt.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">//	This callback, set by *core* (or your custom package), gets called before SyncChanges() proceeds with syncing.</span>
    OnBeforeSyncAll func()

    <span class="comment">//	This callback, set by *core* (or your custom package), gets called after SyncChanges() has finished syncing.</span>
    OnAfterSyncAll func()

    <span class="comment">//	Your default unit-in-meters for geometry, coordinates and transformations.</span>
    <span class="comment">//	If a unit represents:</span>
    <span class="comment">//	- a meter, set to 1;</span>
    <span class="comment">//	- a centimeter, set to 0.01;</span>
    <span class="comment">//	- a kilometer, set to 1000;</span>
    <span class="comment">//	- an inch, set to 0.02539999969303608... etc.</span>
    <span class="comment">//	The *assets* package does not support multiple different or individual per-asset units.</span>
    UnitInMeters float64 = 1
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibCameraDefs* libraries associated by their *ID*.</span>
    AllCameraDefLibs = LibsCameraDef{}

    <span class="comment">//	The &#34;default&#34; *LibCameraDefs* library for *CameraDef*s.</span>
    CameraDefs = AllCameraDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibImageDefs* libraries associated by their *ID*.</span>
    AllImageDefLibs = LibsImageDef{}

    <span class="comment">//	The &#34;default&#34; *LibImageDefs* library for *ImageDef*s.</span>
    ImageDefs = AllImageDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibMaterialDefs* libraries associated by their *ID*.</span>
    AllMaterialDefLibs = LibsMaterialDef{}

    <span class="comment">//	The &#34;default&#34; *LibMaterialDefs* library for *MaterialDef*s.</span>
    MaterialDefs = AllMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibNodeDefs* libraries associated by their *ID*.</span>
    AllNodeDefLibs = LibsNodeDef{}

    <span class="comment">//	The &#34;default&#34; *LibNodeDefs* library for *NodeDef*s.</span>
    NodeDefs = AllNodeDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibSceneDefs* libraries associated by their *ID*.</span>
    AllSceneDefLibs = LibsSceneDef{}

    <span class="comment">//	The &#34;default&#34; *LibSceneDefs* library for *SceneDef*s.</span>
    SceneDefs = AllSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibVisualSceneDefs* libraries associated by their *ID*.</span>
    AllVisualSceneDefLibs = LibsVisualSceneDef{}

    <span class="comment">//	The &#34;default&#34; *LibVisualSceneDefs* library for *VisualSceneDef*s.</span>
    VisualSceneDefs = AllVisualSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
		
		
			
			
			<h2 id="SyncChanges">func <a href="/target/assets.go?s=1065:1083#L26">SyncChanges</a></h2>
			<pre>func SyncChanges()</pre>
			<p>
Signals to *core* (or your custom package) that changes have been made that need to be picked up. Call this after you have made any number of changes to your Defs, Insts or Libs.
</p>

			
		
		
			
			
			<h2 id="Base">type <a href="/target/base.go?s=74:523#L1">Base</a></h2>
			<pre>type Base struct {
    <span class="comment">//	The unique identifier of this *Def*, *Inst* or *Lib*.</span>
    ID string

    <span class="comment">//	This callback, set by *core* (or your custom package), gets called by the *SyncChanges()* method.</span>
    <span class="comment">//	This is the ultimate point in the sync chain where *core* (or your custom package) picks up the changed</span>
    <span class="comment">//	contents of this *Def*, *Inst* or *Lib*. If this is a *Lib* this gets called after all *Defs* in it</span>
    <span class="comment">//	have synced.</span>
    OnSync func()
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Provides a common base for *Def*s, *Inst*s and *Lib*s.
</p>


			

			

			

			

			
				
				<h3 id="Base.SetDirty">func (*Base) <a href="/target/base.go?s=748:774#L9">SetDirty</a></h3>
				<pre>func (me *Base) SetDirty()</pre>
				<p>
You NEED to call this method if you modified this *Def* or *Inst* by setting its fields directly
(instead of using the provided *SetFoo()* methods) for your changes to be picked up by *core* (or your custom package).
</p>

				
				
			
				
				<h3 id="Base.SyncChanges">func (*Base) <a href="/target/base.go?s=1163:1192#L22">SyncChanges</a></h3>
				<pre>func (me *Base) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *Def*, *Inst* or *Lib* that need to be picked up.
Call this after you have made any number of changes to this this *Def*, *Inst* or *Lib*.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="BaseDef">type <a href="/target/base.go?s=1287:1344#L30">BaseDef</a></h2>
			<pre>type BaseDef struct {
    <span class="comment">//	Provides ID and syncing</span>
    Base
}</pre>
			<p>
Provides a common base for *Def*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseInst">type <a href="/target/base.go?s=1443:1501#L40">BaseInst</a></h2>
			<pre>type BaseInst struct {
    <span class="comment">//	Provides ID and syncing</span>
    Base
}</pre>
			<p>
Provides a common base for *Inst*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseLib">type <a href="/target/base.go?s=1541:1598#L46">BaseLib</a></h2>
			<pre>type BaseLib struct {
    <span class="comment">//	Provides ID and syncing</span>
    Base
}</pre>
			<p>
Provides a common base for *Lib*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraDef">type <a href="/target/camera.gt.go?s=119:706#L1">CameraDef</a></h2>
			<pre>type CameraDef struct {
    BaseDef

    <span class="comment">//	Vertical field-of-view for perspective camera.</span>
    FovY float64

    <span class="comment">//	Horizontal magnification for orthographic camera.</span>
    MagX float64

    <span class="comment">//	Verticial magnification for orthographic camera.</span>
    MagY float64

    <span class="comment">//	The distance of the lens to the far-plane. Camera cannot see anything behind the far-plane.</span>
    Zfar float64

    <span class="comment">//	The distance of the lens to the near-plane. Camera cannot see anything in front of the near-plane.</span>
    Znear float64

    <span class="comment">//	Specifies whether this camera is an orthographic (rather than a perspective) camera.</span>
    Ortho bool
}</pre>
			<p>
Defines a perspective or orthographic camera. Only perspective cameras are supported at this point.
</p>


			

			

			

			

			
				
				<h3 id="CameraDef.NewInst">func (*CameraDef) <a href="/target/camera.gt.go?s=2659:2717#L100">NewInst</a></h3>
				<pre>func (me *CameraDef) NewInst(id string) (inst *CameraInst)</pre>
				<p>
Creates and returns a new *CameraInst* instance referencing this *CameraDef* definition.
</p>

				
				
			
				
				<h3 id="CameraDef.SetFovY">func (*CameraDef) <a href="/target/camera.gt.go?s=1072:1111#L32">SetFovY</a></h3>
				<pre>func (me *CameraDef) SetFovY(v float64)</pre>
				<p>
Sets the *FovY* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetMagX">func (*CameraDef) <a href="/target/camera.gt.go?s=1283:1322#L40">SetMagX</a></h3>
				<pre>func (me *CameraDef) SetMagX(v float64)</pre>
				<p>
Sets the *MagX* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetMagY">func (*CameraDef) <a href="/target/camera.gt.go?s=1494:1533#L48">SetMagY</a></h3>
				<pre>func (me *CameraDef) SetMagY(v float64)</pre>
				<p>
Sets the *MagY* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetOrtho">func (*CameraDef) <a href="/target/camera.gt.go?s=1706:1743#L56">SetOrtho</a></h3>
				<pre>func (me *CameraDef) SetOrtho(v bool)</pre>
				<p>
Sets the *Ortho* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetZfar">func (*CameraDef) <a href="/target/camera.gt.go?s=1917:1956#L64">SetZfar</a></h3>
				<pre>func (me *CameraDef) SetZfar(v float64)</pre>
				<p>
Sets the *Zfar* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetZnear">func (*CameraDef) <a href="/target/camera.gt.go?s=2129:2169#L72">SetZnear</a></h3>
				<pre>func (me *CameraDef) SetZnear(v float64)</pre>
				<p>
Sets the *Znear* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
		
			
			
			<h2 id="CameraInst">type <a href="/target/camera.gt.go?s=2277:2385#L80">CameraInst</a></h2>
			<pre>type CameraInst struct {
    BaseInst

    <span class="comment">//	The camera definition referenced by this instance.</span>
    Def *CameraDef
}</pre>
			<p>
An instance referencing a camera definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ImageDef">type <a href="/target/image.gt.go?s=477:625#L7">ImageDef</a></h2>
			<pre>type ImageDef struct {
    BaseDef
    <span class="comment">//	Initializes an entire Image or portions of an Image from referenced or embedded data.</span>
    InitFrom *ImageInitFrom
}</pre>
			<p>
Declares the storage for the graphical representation of an object.
</p>


			

			

			

			

			
				
				<h3 id="ImageDef.NewInst">func (*ImageDef) <a href="/target/image.gt.go?s=1124:1180#L38">NewInst</a></h3>
				<pre>func (me *ImageDef) NewInst(id string) (inst *ImageInst)</pre>
				<p>
Creates and returns a new *ImageInst* instance referencing this *ImageDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="ImageInitFrom">type <a href="/target/image.gt.go?s=57:404#L1">ImageInitFrom</a></h2>
			<pre>type ImageInitFrom struct {
    <span class="comment">//	Initializes higher MIP levels if data does not exist in a file. Defaults to true.</span>
    AutoMip bool

    <span class="comment">//	Contains the embedded image data as a sequence of bytes.</span>
    RawData []byte

    <span class="comment">//	The URL of a file from which to take initialization data. Can be a relative path</span>
    <span class="comment">//	such as &#34;walltextures/wall01.jpg&#34;.</span>
    RefUrl string
}</pre>
			<p>
Used for the ImageDef.InitFrom field.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ImageInst">type <a href="/target/image.gt.go?s=752:857#L18">ImageInst</a></h2>
			<pre>type ImageInst struct {
    BaseInst

    <span class="comment">//	The image definition referenced by this instance.</span>
    Def *ImageDef
}</pre>
			<p>
An instance referencing an Image definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LibCameraDefs">type <a href="/target/camera.gt.go?s=4032:4298#L146">LibCameraDefs</a></h2>
			<pre>type LibCameraDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*CameraDef
}</pre>
			<p>
A library that contains *CameraDef*s associated by their *ID*. To create a new *LibCameraDefs* library, ONLY
use the *LibsCameraDef.New()* or *LibsCameraDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibCameraDefs.Add">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4644:4701#L162">Add</a></h3>
				<pre>func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</pre>
				<p>
Adds the specified *CameraDef* definition to this *LibCameraDefs*, and returns it.
</p>
<p>
If this *LibCameraDefs* already contains a *CameraDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.AddNew">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5025:5078#L173">AddNew</a></h3>
				<pre>func (me *LibCameraDefs) AddNew(id string) *CameraDef</pre>
				<p>
Creates a new *CameraDef* definition with the specified *ID*, adds it to this *LibCameraDefs*, and returns it.
</p>
<p>
If this *LibCameraDefs* already contains a *CameraDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.New">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5235:5291#L176">New</a></h3>
				<pre>func (me *LibCameraDefs) New(id string) (def *CameraDef)</pre>
				<p>
Creates a new *CameraDef* definition with the specified *ID* and returns it, but does not add it to this *LibCameraDefs*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Remove">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5406:5448#L179">Remove</a></h3>
				<pre>func (me *LibCameraDefs) Remove(id string)</pre>
				<p>
Removes the *CameraDef* with the specified *ID* from this *LibCameraDefs*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.SyncChanges">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5785:5823#L184">SyncChanges</a></h3>
				<pre>func (me *LibCameraDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibCameraDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibCameraDefs* library or its *CameraDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibImageDefs">type <a href="/target/image.gt.go?s=2469:2733#L84">LibImageDefs</a></h2>
			<pre>type LibImageDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*ImageDef
}</pre>
			<p>
A library that contains *ImageDef*s associated by their *ID*. To create a new *LibImageDefs* library, ONLY
use the *LibsImageDef.New()* or *LibsImageDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibImageDefs.Add">func (*LibImageDefs) <a href="/target/image.gt.go?s=3071:3125#L100">Add</a></h3>
				<pre>func (me *LibImageDefs) Add(d *ImageDef) (n *ImageDef)</pre>
				<p>
Adds the specified *ImageDef* definition to this *LibImageDefs*, and returns it.
</p>
<p>
If this *LibImageDefs* already contains a *ImageDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.AddNew">func (*LibImageDefs) <a href="/target/image.gt.go?s=3445:3496#L111">AddNew</a></h3>
				<pre>func (me *LibImageDefs) AddNew(id string) *ImageDef</pre>
				<p>
Creates a new *ImageDef* definition with the specified *ID*, adds it to this *LibImageDefs*, and returns it.
</p>
<p>
If this *LibImageDefs* already contains a *ImageDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.New">func (*LibImageDefs) <a href="/target/image.gt.go?s=3651:3705#L114">New</a></h3>
				<pre>func (me *LibImageDefs) New(id string) (def *ImageDef)</pre>
				<p>
Creates a new *ImageDef* definition with the specified *ID* and returns it, but does not add it to this *LibImageDefs*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.Remove">func (*LibImageDefs) <a href="/target/image.gt.go?s=3817:3858#L117">Remove</a></h3>
				<pre>func (me *LibImageDefs) Remove(id string)</pre>
				<p>
Removes the *ImageDef* with the specified *ID* from this *LibImageDefs*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.SyncChanges">func (*LibImageDefs) <a href="/target/image.gt.go?s=4192:4229#L122">SyncChanges</a></h3>
				<pre>func (me *LibImageDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibImageDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibImageDefs* library or its *ImageDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibMaterialDefs">type <a href="/target/material.gt.go?s=2078:2348#L68">LibMaterialDefs</a></h2>
			<pre>type LibMaterialDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*MaterialDef
}</pre>
			<p>
A library that contains *MaterialDef*s associated by their *ID*. To create a new *LibMaterialDefs* library, ONLY
use the *LibsMaterialDef.New()* or *LibsMaterialDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibMaterialDefs.Add">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=2710:2773#L84">Add</a></h3>
				<pre>func (me *LibMaterialDefs) Add(d *MaterialDef) (n *MaterialDef)</pre>
				<p>
Adds the specified *MaterialDef* definition to this *LibMaterialDefs*, and returns it.
</p>
<p>
If this *LibMaterialDefs* already contains a *MaterialDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.AddNew">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3105:3162#L95">AddNew</a></h3>
				<pre>func (me *LibMaterialDefs) AddNew(id string) *MaterialDef</pre>
				<p>
Creates a new *MaterialDef* definition with the specified *ID*, adds it to this *LibMaterialDefs*, and returns it.
</p>
<p>
If this *LibMaterialDefs* already contains a *MaterialDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.New">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3323:3383#L98">New</a></h3>
				<pre>func (me *LibMaterialDefs) New(id string) (def *MaterialDef)</pre>
				<p>
Creates a new *MaterialDef* definition with the specified *ID* and returns it, but does not add it to this *LibMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.Remove">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3504:3548#L101">Remove</a></h3>
				<pre>func (me *LibMaterialDefs) Remove(id string)</pre>
				<p>
Removes the *MaterialDef* with the specified *ID* from this *LibMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.SyncChanges">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3891:3931#L106">SyncChanges</a></h3>
				<pre>func (me *LibMaterialDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibMaterialDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibMaterialDefs* library or its *MaterialDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibNodeDefs">type <a href="/target/node.gt.go?s=2335:2597#L80">LibNodeDefs</a></h2>
			<pre>type LibNodeDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*NodeDef
}</pre>
			<p>
A library that contains *NodeDef*s associated by their *ID*. To create a new *LibNodeDefs* library, ONLY
use the *LibsNodeDef.New()* or *LibsNodeDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibNodeDefs.Add">func (*LibNodeDefs) <a href="/target/node.gt.go?s=2927:2978#L96">Add</a></h3>
				<pre>func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</pre>
				<p>
Adds the specified *NodeDef* definition to this *LibNodeDefs*, and returns it.
</p>
<p>
If this *LibNodeDefs* already contains a *NodeDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.AddNew">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3294:3343#L107">AddNew</a></h3>
				<pre>func (me *LibNodeDefs) AddNew(id string) *NodeDef</pre>
				<p>
Creates a new *NodeDef* definition with the specified *ID*, adds it to this *LibNodeDefs*, and returns it.
</p>
<p>
If this *LibNodeDefs* already contains a *NodeDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.New">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3496:3548#L110">New</a></h3>
				<pre>func (me *LibNodeDefs) New(id string) (def *NodeDef)</pre>
				<p>
Creates a new *NodeDef* definition with the specified *ID* and returns it, but does not add it to this *LibNodeDefs*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Remove">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3657:3697#L113">Remove</a></h3>
				<pre>func (me *LibNodeDefs) Remove(id string)</pre>
				<p>
Removes the *NodeDef* with the specified *ID* from this *LibNodeDefs*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.SyncChanges">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4028:4064#L118">SyncChanges</a></h3>
				<pre>func (me *LibNodeDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibNodeDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibNodeDefs* library or its *NodeDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibSceneDefs">type <a href="/target/scene.gt.go?s=2136:2400#L72">LibSceneDefs</a></h2>
			<pre>type LibSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*SceneDef
}</pre>
			<p>
A library that contains *SceneDef*s associated by their *ID*. To create a new *LibSceneDefs* library, ONLY
use the *LibsSceneDef.New()* or *LibsSceneDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibSceneDefs.Add">func (*LibSceneDefs) <a href="/target/scene.gt.go?s=2738:2792#L88">Add</a></h3>
				<pre>func (me *LibSceneDefs) Add(d *SceneDef) (n *SceneDef)</pre>
				<p>
Adds the specified *SceneDef* definition to this *LibSceneDefs*, and returns it.
</p>
<p>
If this *LibSceneDefs* already contains a *SceneDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibSceneDefs.AddNew">func (*LibSceneDefs) <a href="/target/scene.gt.go?s=3112:3163#L99">AddNew</a></h3>
				<pre>func (me *LibSceneDefs) AddNew(id string) *SceneDef</pre>
				<p>
Creates a new *SceneDef* definition with the specified *ID*, adds it to this *LibSceneDefs*, and returns it.
</p>
<p>
If this *LibSceneDefs* already contains a *SceneDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibSceneDefs.New">func (*LibSceneDefs) <a href="/target/scene.gt.go?s=3318:3372#L102">New</a></h3>
				<pre>func (me *LibSceneDefs) New(id string) (def *SceneDef)</pre>
				<p>
Creates a new *SceneDef* definition with the specified *ID* and returns it, but does not add it to this *LibSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibSceneDefs.Remove">func (*LibSceneDefs) <a href="/target/scene.gt.go?s=3484:3525#L105">Remove</a></h3>
				<pre>func (me *LibSceneDefs) Remove(id string)</pre>
				<p>
Removes the *SceneDef* with the specified *ID* from this *LibSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibSceneDefs.SyncChanges">func (*LibSceneDefs) <a href="/target/scene.gt.go?s=3859:3896#L110">SyncChanges</a></h3>
				<pre>func (me *LibSceneDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibSceneDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibSceneDefs* library or its *SceneDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibVisualSceneDefs">type <a href="/target/visualscene.gt.go?s=2413:2689#L70">LibVisualSceneDefs</a></h2>
			<pre>type LibVisualSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*VisualSceneDef
}</pre>
			<p>
A library that contains *VisualSceneDef*s associated by their *ID*. To create a new *LibVisualSceneDefs* library, ONLY
use the *LibsVisualSceneDef.New()* or *LibsVisualSceneDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibVisualSceneDefs.Add">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3075:3147#L86">Add</a></h3>
				<pre>func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</pre>
				<p>
Adds the specified *VisualSceneDef* definition to this *LibVisualSceneDefs*, and returns it.
</p>
<p>
If this *LibVisualSceneDefs* already contains a *VisualSceneDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.AddNew">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3491:3554#L97">AddNew</a></h3>
				<pre>func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</pre>
				<p>
Creates a new *VisualSceneDef* definition with the specified *ID*, adds it to this *LibVisualSceneDefs*, and returns it.
</p>
<p>
If this *LibVisualSceneDefs* already contains a *VisualSceneDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.New">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3721:3787#L100">New</a></h3>
				<pre>func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</pre>
				<p>
Creates a new *VisualSceneDef* definition with the specified *ID* and returns it, but does not add it to this *LibVisualSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Remove">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3917:3964#L103">Remove</a></h3>
				<pre>func (me *LibVisualSceneDefs) Remove(id string)</pre>
				<p>
Removes the *VisualSceneDef* with the specified *ID* from this *LibVisualSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.SyncChanges">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=4316:4359#L108">SyncChanges</a></h3>
				<pre>func (me *LibVisualSceneDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibVisualSceneDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibVisualSceneDefs* library or its *VisualSceneDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibsCameraDef">type <a href="/target/camera.gt.go?s=3317:3361#L125">LibsCameraDef</a></h2>
			<pre>type LibsCameraDef map[string]*LibCameraDefs</pre>
			<p>
The underlying type of the global *AllCameraDefLibs* variable: a *map* collection that contains
*LibCameraDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsCameraDef.AddNew">func (LibsCameraDef) <a href="/target/camera.gt.go?s=3609:3671#L130">AddNew</a></h3>
				<pre>func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</pre>
				<p>
Creates a new *LibCameraDefs* library with the specified *ID*, adds it to this *LibsCameraDef*, and returns it.
</p>
<p>
If this *LibsCameraDef* already contains a *LibCameraDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsImageDef">type <a href="/target/image.gt.go?s=1769:1811#L63">LibsImageDef</a></h2>
			<pre>type LibsImageDef map[string]*LibImageDefs</pre>
			<p>
The underlying type of the global *AllImageDefLibs* variable: a *map* collection that contains
*LibImageDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsImageDef.AddNew">func (LibsImageDef) <a href="/target/image.gt.go?s=2055:2115#L68">AddNew</a></h3>
				<pre>func (me LibsImageDef) AddNew(id string) (lib *LibImageDefs)</pre>
				<p>
Creates a new *LibImageDefs* library with the specified *ID*, adds it to this *LibsImageDef*, and returns it.
</p>
<p>
If this *LibsImageDef* already contains a *LibImageDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsMaterialDef">type <a href="/target/material.gt.go?s=1333:1381#L47">LibsMaterialDef</a></h2>
			<pre>type LibsMaterialDef map[string]*LibMaterialDefs</pre>
			<p>
The underlying type of the global *AllMaterialDefLibs* variable: a *map* collection that contains
*LibMaterialDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsMaterialDef.AddNew">func (LibsMaterialDef) <a href="/target/material.gt.go?s=1637:1703#L52">AddNew</a></h3>
				<pre>func (me LibsMaterialDef) AddNew(id string) (lib *LibMaterialDefs)</pre>
				<p>
Creates a new *LibMaterialDefs* library with the specified *ID*, adds it to this *LibsMaterialDef*, and returns it.
</p>
<p>
If this *LibsMaterialDef* already contains a *LibMaterialDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsNodeDef">type <a href="/target/node.gt.go?s=1650:1690#L59">LibsNodeDef</a></h2>
			<pre>type LibsNodeDef map[string]*LibNodeDefs</pre>
			<p>
The underlying type of the global *AllNodeDefLibs* variable: a *map* collection that contains
*LibNodeDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsNodeDef.AddNew">func (LibsNodeDef) <a href="/target/node.gt.go?s=1930:1988#L64">AddNew</a></h3>
				<pre>func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</pre>
				<p>
Creates a new *LibNodeDefs* library with the specified *ID*, adds it to this *LibsNodeDef*, and returns it.
</p>
<p>
If this *LibsNodeDef* already contains a *LibNodeDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsSceneDef">type <a href="/target/scene.gt.go?s=1436:1478#L51">LibsSceneDef</a></h2>
			<pre>type LibsSceneDef map[string]*LibSceneDefs</pre>
			<p>
The underlying type of the global *AllSceneDefLibs* variable: a *map* collection that contains
*LibSceneDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsSceneDef.AddNew">func (LibsSceneDef) <a href="/target/scene.gt.go?s=1722:1782#L56">AddNew</a></h3>
				<pre>func (me LibsSceneDef) AddNew(id string) (lib *LibSceneDefs)</pre>
				<p>
Creates a new *LibSceneDefs* library with the specified *ID*, adds it to this *LibsSceneDef*, and returns it.
</p>
<p>
If this *LibsSceneDef* already contains a *LibSceneDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsVisualSceneDef">type <a href="/target/visualscene.gt.go?s=1623:1677#L49">LibsVisualSceneDef</a></h2>
			<pre>type LibsVisualSceneDef map[string]*LibVisualSceneDefs</pre>
			<p>
The underlying type of the global *AllVisualSceneDefLibs* variable: a *map* collection that contains
*LibVisualSceneDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsVisualSceneDef.AddNew">func (LibsVisualSceneDef) <a href="/target/visualscene.gt.go?s=1945:2017#L54">AddNew</a></h3>
				<pre>func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</pre>
				<p>
Creates a new *LibVisualSceneDefs* library with the specified *ID*, adds it to this *LibsVisualSceneDef*, and returns it.
</p>
<p>
If this *LibsVisualSceneDef* already contains a *LibVisualSceneDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="MaterialDef">type <a href="/target/material.gt.go?s=124:160#L1">MaterialDef</a></h2>
			<pre>type MaterialDef struct {
    BaseDef
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry and screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="MaterialDef.NewInst">func (*MaterialDef) <a href="/target/material.gt.go?s=649:711#L22">NewInst</a></h3>
				<pre>func (me *MaterialDef) NewInst(id string) (inst *MaterialInst)</pre>
				<p>
Creates and returns a new *MaterialInst* instance referencing this *MaterialDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="MaterialInst">type <a href="/target/material.gt.go?s=247:361#L2">MaterialInst</a></h2>
			<pre>type MaterialInst struct {
    BaseInst

    <span class="comment">//	The material definition referenced by this instance.</span>
    Def *MaterialDef
}</pre>
			<p>
An instance referencing a material definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshData">type <a href="/target/meshdata.go?s=1164:1387#L40">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">//	Vertex positions</span>
    Positions []MeshVertAtt3
    <span class="comment">//	Vertex texture coordinates</span>
    TexCoords []MeshVertAtt2
    <span class="comment">//	Vertex normals</span>
    Normals []MeshVertAtt3
    <span class="comment">//	Indexed triangle definitions</span>
    Faces []MeshFace3
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="NewMeshData">func <a href="/target/meshdata.go?s=1443:1476#L52">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
				
				<h3 id="MeshData.AddFaces">func (*MeshData) <a href="/target/meshdata.go?s=1554:1602#L58">AddFaces</a></h3>
				<pre>func (me *MeshData) AddFaces(faces ...MeshFace3)</pre>
				<p>
Adds all specified Faces to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddNormals">func (*MeshData) <a href="/target/meshdata.go?s=1865:1920#L68">AddNormals</a></h3>
				<pre>func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</pre>
				<p>
Adds all the specified Normals to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddPositions">func (*MeshData) <a href="/target/meshdata.go?s=1697:1756#L63">AddPositions</a></h3>
				<pre>func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</pre>
				<p>
Adds all specified Positions to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddTexCoords">func (*MeshData) <a href="/target/meshdata.go?s=2025:2084#L73">AddTexCoords</a></h3>
				<pre>func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</pre>
				<p>
Adds all the specified TexCoords to this MeshData.
</p>

				
				
			
		
			
			
			<h2 id="MeshFace3">type <a href="/target/meshdata.go?s=140:166#L1">MeshFace3</a></h2>
			<pre>type MeshFace3 [3]MeshVert</pre>
			<p>
Represents an indexed triangle.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/meshdata.go?s=41:103#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Temporary concoction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRaw">type <a href="/target/meshdata.go?s=255:400#L1">MeshRaw</a></h2>
			<pre>type MeshRaw struct {
    <span class="comment">//	Raw vertices</span>
    MeshVerts []float32
    <span class="comment">//	Vertex indices</span>
    Indices []uint32
    <span class="comment">//	Raw face definitions</span>
    Faces []*MeshRawFace
}</pre>
			<p>
Represents semi-processed loaded mesh data &#34;almost ready&#34; to core.Mesh.GpuUpload().
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRawFace">type <a href="/target/meshdata.go?s=450:532#L10">MeshRawFace</a></h2>
			<pre>type MeshRawFace struct {
    <span class="comment">//	Indices of the triangle corners</span>
    Entries [3]uint32
}</pre>
			<p>
Represents a triangle face inside a MeshRaw.
</p>


			

			

			

			
				
				<h3 id="NewMeshRawFace">func <a href="/target/meshdata.go?s=591:630#L16">NewMeshRawFace</a></h3>
				<pre>func NewMeshRawFace() (me *MeshRawFace)</pre>
				<p>
Initializes and returns a new *MeshRawFace* instance.
</p>

				
			

			
		
			
			
			<h2 id="MeshVert">type <a href="/target/meshdata.go?s=698:885#L22">MeshVert</a></h2>
			<pre>type MeshVert struct {
    <span class="comment">//	Index of the vertex position</span>
    PosIndex uint32

    <span class="comment">//	Index of the texture-coordinate.</span>
    TexCoordIndex uint32

    <span class="comment">//	Index of the vertex normal.</span>
    NormalIndex uint32
}</pre>
			<p>
Represents an indexed vertex.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt2">type <a href="/target/meshdata.go?s=974:1002#L34">MeshVertAtt2</a></h2>
			<pre>type MeshVertAtt2 [2]float32</pre>
			<p>
Represents a 2-component vertex attribute (such as for example texture-coordinates)
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt3">type <a href="/target/meshdata.go?s=1086:1114#L37">MeshVertAtt3</a></h2>
			<pre>type MeshVertAtt3 [3]float32</pre>
			<p>
Represents a 3-component vertex attribute (such as for example vertex-normals)
</p>


			

			

			

			

			
		
			
			
			<h2 id="NodeDef">type <a href="/target/node.gt.go?s=271:546#L1">NodeDef</a></h2>
			<pre>type NodeDef struct {
    BaseDef

    <span class="comment">//	The names of the layers to which this Node belongs.</span>
    Layers map[string]bool

    <span class="comment">//	Allows the Node to recursively define hierarchy.</span>
    NodeDefs []*NodeDef

    <span class="comment">//	Allows the Node to instantiate a hierarchy of other Nodes.</span>
    NodeInsts []*NodeInst
}</pre>
			<p>
A Node embodies the hierarchical relationship of elements in a Scene by declaring a point of
interest in a Scene. A Node denotes one point on a branch of the Scene graph. The Node is
essentially the root of a sub-graph of the entire Scene graph.
</p>


			

			

			

			

			
				
				<h3 id="NodeDef.NewInst">func (*NodeDef) <a href="/target/node.gt.go?s=1018:1072#L34">NewInst</a></h3>
				<pre>func (me *NodeDef) NewInst(id string) (inst *NodeInst)</pre>
				<p>
Creates and returns a new *NodeInst* instance referencing this *NodeDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="NodeInst">type <a href="/target/node.gt.go?s=656:758#L14">NodeInst</a></h2>
			<pre>type NodeInst struct {
    BaseInst

    <span class="comment">//	The Node definition referenced by this instance.</span>
    Def *NodeDef
}</pre>
			<p>
An instance referencing a Node definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SceneDef">type <a href="/target/scene.gt.go?s=221:338#L1">SceneDef</a></h2>
			<pre>type SceneDef struct {
    BaseDef

    <span class="comment">//	The Visual Scene associated with this Scene.</span>
    VisualSceneInst *VisualSceneInst
}</pre>
			<p>
Declares a complete, self-contained base of a Scene hierarchy or Scene graph. Currently just defined by a
Visual Scene, later to be augmented by optional &#34;kinematics scenes&#34; and/or &#34;physics scenes&#34;.
</p>


			

			

			

			

			
				
				<h3 id="SceneDef.NewInst">func (*SceneDef) <a href="/target/scene.gt.go?s=791:847#L26">NewInst</a></h3>
				<pre>func (me *SceneDef) NewInst(id string) (inst *SceneInst)</pre>
				<p>
Creates and returns a new *SceneInst* instance referencing this *SceneDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="SceneInst">type <a href="/target/scene.gt.go?s=419:524#L6">SceneInst</a></h2>
			<pre>type SceneInst struct {
    BaseInst

    <span class="comment">//	The Scene definition referenced by this instance.</span>
    Def *SceneDef
}</pre>
			<p>
An instance referencing a Scene definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="VisualSceneDef">type <a href="/target/visualscene.gt.go?s=334:373#L1">VisualSceneDef</a></h2>
			<pre>type VisualSceneDef struct {
    BaseDef
}</pre>
			<p>
Embodies the entire set of information that can be visualized from the contents of the *Lib* libraries.
The hierarchical structure of the Visual Scene is organized into a scene graph. A scene graph is a
directed acyclic graph or tree data structure that contains nodes of visual information and related data.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneDef.NewInst">func (*VisualSceneDef) <a href="/target/visualscene.gt.go?s=900:968#L24">NewInst</a></h3>
				<pre>func (me *VisualSceneDef) NewInst(id string) (inst *VisualSceneInst)</pre>
				<p>
Creates and returns a new *VisualSceneInst* instance referencing this *VisualSceneDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneInst">type <a href="/target/visualscene.gt.go?s=467:591#L4">VisualSceneInst</a></h2>
			<pre>type VisualSceneInst struct {
    BaseInst

    <span class="comment">//	The Visual Scene definition referenced by this instance.</span>
    Def *VisualSceneDef
}</pre>
			<p>
An instance referencing a Visual Scene definition.
</p>


			

			

			

			

			
		
		</div>
	

	







	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="collada/">collada</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>
	


		</div></div>
	</body>
</html>