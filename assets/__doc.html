<html>
	<head>
		<title>Package github.com/go3d/go-ngine/assets</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/assets</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/assets"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
File generated by github.com/ungerik/pkgreflect
</p>
<pre>The assets package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.

________

First off, the go:ngine 3 RULES of bugless(er) development:

1. you do NOT set exported fields directly, those are provided for simplified read-access. If a field is
meant to be modifiable, there will be a SetFoo() method or it will be documented explicitly as directly
modifiable, but such instances will be rare.

2. you do NOT instantiate exported struct types directly, as in &#34;new(ImageDef)&#34; or &#34;&amp;ImageDef {}&#34;. Many of
those are exported only for documentation, but are to be instantiated only inside the go:ngine package.
For types to be instantiated by package-external code (ie. your code), go:ngine packages provide constructor
functions -- often in collections, ie. img := ImageDefs.New(&#34;id&#34;) instead of, say, img := NewImageDef(&#34;id&#34;).

3. Those 2 are *default* assumptions and modes of operation -- there are a few &#34;if you know what you&#39;re
doing&#34; exemptions and those are (or will be) explicitly documented as such.

________

The assets package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.
These data structures only describe resource definitions and instances, but do not provide
any specific logic or algorithms, such as physics or visual rendering.

Context: any go:ngine app uses a variety of both simple and complex resource types, including for
example geometry definitions, image textures, material and light descriptions and many others.

While for all these resource types, the go:ngine core package manages their respective run-time
representation in its entirety,	some basic part of that representation is &#34;merely descriptive&#34; and
should be readable from or writable to a binary stream (&#34;design-time&#34;). That &#34;merely descriptive&#34;
sub-set of resource definitions is fully contained in this go:ngine assets package and thus decoupled
from the go:ngine core package.

This assets package thus allows for things such as server-side procedural asset generators, networked
resource streaming or simple custom asset-import/export/conversion tools, all of which shouldn&#39;t have to
needlessly depend on the graphics, windowing etc. stacks.

NOTE: there are essentially TWO distinct &#34;modes&#34; or use-cases in which the assets package is active:

1. in graphics-independent, server-side or non-interactive &#34;toolage&#34;, dealing only with the raw resource
data where it can be generated, loaded, stored, manipulated at will with no particular repercussions.

2. in an interactive graphical go:ngine app that also has the core package loaded:

All &#34;Sync&#34;-related functions pertain to use-case #2, where the assets package essentially becomes the
live repository for all resource definitions loaded, used, or manipulated by the core package at runtime.
So now every image definition in assets may have a corresponding GPU-bound texture object in core, every
assets mesh definition may be bound to a core.MeshBuffer, etc.

Structure: generally speaking, all resource types are organized in a consistent fashion as follows ---
users familiar with the COLLADA format will notice a stark resemblance in terminology and resource organization:

1. First, there is a FooDef struct for the one-time definition of a unique resource:
GeometryMeshDef, ImageDef, LightDef, MaterialDef etc.

2. Next, there is a smaller FooInst struct for handling many individual (sometimes parameterized) instantiations of
a FooDef: GeometryMeshInst, ImageInst, LightInst, MaterialInst etc.

3. Finally, there is a light-weight LibFooDefs struct type (aliasing a typed hash-table) containing Defs
associated with their Id: LibGeometryMeshDefs, LibImageDefs, LibLightDefs, LibMaterialDefs etc.

4. The package also provides a pre-initialized global FooDefs variable for each such Lib type, in simple apps
considered the &#34;default / main / only Lib you&#39;ll need&#34;: GeometryMeshDefs, ImageDefs, LightDefs, MaterialDefs etc.

5. For more complex use-cases, you can also organize multiple libs for any given resource type in the global
AllFooDefLibs variable, essentially a hash-table of Libs: AllGeometryMeshDefLibs (of type
LibsGeometryMeshDef), AllImageDefLibs (of type LibsImageDef), AllLightDefLibs (of type LibsLightDef),
AllMaterialDefLibs (of type LibsMaterialDef) etc.

Any exported types in this package not following the above pattern (such as MeshData etc.) should be
considered &#34;auxiliary helpers&#34; rather than primary / &#34;first-class&#34; resource types.
</pre>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#SyncChanges">func SyncChanges()</a></dd>
			
			
				
				<dd><a href="#AnimationChannel">type AnimationChannel</a></dd>
				
				
			
				
				<dd><a href="#AnimationClipDef">type AnimationClipDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipDef.Init">func (me *AnimationClipDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipDef.NewInst">func (me *AnimationClipDef) NewInst() (inst *AnimationClipInst)</a></dd>
				
			
				
				<dd><a href="#AnimationClipInst">type AnimationClipInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipInst.EnsureDef">func (me *AnimationClipInst) EnsureDef() *AnimationClipDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipInst.Init">func (me *AnimationClipInst) Init()</a></dd>
				
			
				
				<dd><a href="#AnimationDef">type AnimationDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationDef.Init">func (me *AnimationDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationDef.NewInst">func (me *AnimationDef) NewInst() (inst *AnimationInst)</a></dd>
				
			
				
				<dd><a href="#AnimationInst">type AnimationInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationInst.EnsureDef">func (me *AnimationInst) EnsureDef() *AnimationDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationInst.Init">func (me *AnimationInst) Init()</a></dd>
				
			
				
				<dd><a href="#AnimationSampler">type AnimationSampler</a></dd>
				
				
			
				
				<dd><a href="#Asset">type Asset</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAsset">func NewAsset() (me *Asset)</a></dd>
				
				
			
				
				<dd><a href="#AssetContributor">type AssetContributor</a></dd>
				
				
			
				
				<dd><a href="#AssetGeographicLocation">type AssetGeographicLocation</a></dd>
				
				
			
				
				<dd><a href="#BaseDef">type BaseDef</a></dd>
				
				
			
				
				<dd><a href="#BaseInst">type BaseInst</a></dd>
				
				
			
				
				<dd><a href="#BaseLib">type BaseLib</a></dd>
				
				
			
				
				<dd><a href="#BaseSync">type BaseSync</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseSync.SetDirty">func (me *BaseSync) SetDirty()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseSync.SetFieldB">func (me *BaseSync) SetFieldB(field *bool, val bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseSync.SetFieldF">func (me *BaseSync) SetFieldF(field *float64, val float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseSync.SyncChanges">func (me *BaseSync) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#Bool2">type Bool2</a></dd>
				
				
			
				
				<dd><a href="#Bool3">type Bool3</a></dd>
				
				
			
				
				<dd><a href="#Bool4">type Bool4</a></dd>
				
				
			
				
				<dd><a href="#CameraDef">type CameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.Init">func (me *CameraDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.NewInst">func (me *CameraDef) NewInst() (inst *CameraInst)</a></dd>
				
			
				
				<dd><a href="#CameraImager">type CameraImager</a></dd>
				
				
			
				
				<dd><a href="#CameraInst">type CameraInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraInst.EnsureDef">func (me *CameraInst) EnsureDef() *CameraDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraInst.Init">func (me *CameraInst) Init()</a></dd>
				
			
				
				<dd><a href="#CameraOptics">type CameraOptics</a></dd>
				
				
			
				
				<dd><a href="#CameraOrthographic">type CameraOrthographic</a></dd>
				
				
			
				
				<dd><a href="#CameraPerspective">type CameraPerspective</a></dd>
				
				
			
				
				<dd><a href="#ChildNode">type ChildNode</a></dd>
				
				
			
				
				<dd><a href="#ControllerDef">type ControllerDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerDef.Init">func (me *ControllerDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerDef.NewInst">func (me *ControllerDef) NewInst() (inst *ControllerInst)</a></dd>
				
			
				
				<dd><a href="#ControllerInputs">type ControllerInputs</a></dd>
				
				
			
				
				<dd><a href="#ControllerInst">type ControllerInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerInst.EnsureDef">func (me *ControllerInst) EnsureDef() *ControllerDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerInst.Init">func (me *ControllerInst) Init()</a></dd>
				
			
				
				<dd><a href="#ControllerMorph">type ControllerMorph</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerMorph">func NewControllerMorph() (me *ControllerMorph)</a></dd>
				
				
			
				
				<dd><a href="#ControllerSkin">type ControllerSkin</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerSkin">func NewControllerSkin() (me *ControllerSkin)</a></dd>
				
				
			
				
				<dd><a href="#Document">type Document</a></dd>
				
				
			
				
				<dd><a href="#Extra">type Extra</a></dd>
				
				
			
				
				<dd><a href="#Float2">type Float2</a></dd>
				
				
			
				
				<dd><a href="#Float2x2">type Float2x2</a></dd>
				
				
			
				
				<dd><a href="#Float2x3">type Float2x3</a></dd>
				
				
			
				
				<dd><a href="#Float2x4">type Float2x4</a></dd>
				
				
			
				
				<dd><a href="#Float3">type Float3</a></dd>
				
				
			
				
				<dd><a href="#Float3x2">type Float3x2</a></dd>
				
				
			
				
				<dd><a href="#Float3x3">type Float3x3</a></dd>
				
				
			
				
				<dd><a href="#Float3x4">type Float3x4</a></dd>
				
				
			
				
				<dd><a href="#Float4">type Float4</a></dd>
				
				
			
				
				<dd><a href="#Float4x2">type Float4x2</a></dd>
				
				
			
				
				<dd><a href="#Float4x3">type Float4x3</a></dd>
				
				
			
				
				<dd><a href="#Float4x4">type Float4x4</a></dd>
				
				
			
				
				<dd><a href="#Float7">type Float7</a></dd>
				
				
			
				
				<dd><a href="#Formula">type Formula</a></dd>
				
				
			
				
				<dd><a href="#FormulaDef">type FormulaDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaDef.Init">func (me *FormulaDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaDef.NewInst">func (me *FormulaDef) NewInst() (inst *FormulaInst)</a></dd>
				
			
				
				<dd><a href="#FormulaInst">type FormulaInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaInst.EnsureDef">func (me *FormulaInst) EnsureDef() *FormulaDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaInst.Init">func (me *FormulaInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxAnnotation">type FxAnnotation</a></dd>
				
				
			
				
				<dd><a href="#FxBinding">type FxBinding</a></dd>
				
				
			
				
				<dd><a href="#FxColorOrTexture">type FxColorOrTexture</a></dd>
				
				
			
				
				<dd><a href="#FxCreate">type FxCreate</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2D">type FxCreate2D</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2DSizeExact">type FxCreate2DSizeExact</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2DSizeRatio">type FxCreate2DSizeRatio</a></dd>
				
				
			
				
				<dd><a href="#FxCreate3D">type FxCreate3D</a></dd>
				
				
			
				
				<dd><a href="#FxCreate3DInitFrom">type FxCreate3DInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateCube">type FxCreateCube</a></dd>
				
				
			
				
				<dd><a href="#FxCreateCubeInitFrom">type FxCreateCubeInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateFormat">type FxCreateFormat</a></dd>
				
				
			
				
				<dd><a href="#FxCreateFormatHint">type FxCreateFormatHint</a></dd>
				
				
			
				
				<dd><a href="#FxCreateInitFrom">type FxCreateInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateMips">type FxCreateMips</a></dd>
				
				
			
				
				<dd><a href="#FxEffectDef">type FxEffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectDef.Init">func (me *FxEffectDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectDef.NewInst">func (me *FxEffectDef) NewInst() (inst *FxEffectInst)</a></dd>
				
			
				
				<dd><a href="#FxEffectInst">type FxEffectInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectInst.EnsureDef">func (me *FxEffectInst) EnsureDef() *FxEffectDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectInst.Init">func (me *FxEffectInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxEffectInstTechniqueHint">type FxEffectInstTechniqueHint</a></dd>
				
				
			
				
				<dd><a href="#FxImageDef">type FxImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageDef.Init">func (me *FxImageDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageDef.NewInst">func (me *FxImageDef) NewInst() (inst *FxImageInst)</a></dd>
				
			
				
				<dd><a href="#FxImageInitFrom">type FxImageInitFrom</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxImageInitFrom">func NewFxImageInitFrom(refUrl string) (me *FxImageInitFrom)</a></dd>
				
				
			
				
				<dd><a href="#FxImageInst">type FxImageInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageInst.EnsureDef">func (me *FxImageInst) EnsureDef() *FxImageDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageInst.Init">func (me *FxImageInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxInitFrom">type FxInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxMaterialDef">type FxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialDef.Init">func (me *FxMaterialDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialDef.NewInst">func (me *FxMaterialDef) NewInst() (inst *FxMaterialInst)</a></dd>
				
			
				
				<dd><a href="#FxMaterialInst">type FxMaterialInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialInst.EnsureDef">func (me *FxMaterialInst) EnsureDef() *FxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialInst.Init">func (me *FxMaterialInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxParamDef">type FxParamDef</a></dd>
				
				
			
				
				<dd><a href="#FxParamDefs">type FxParamDefs</a></dd>
				
				
			
				
				<dd><a href="#FxPass">type FxPass</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxPass">func NewFxPass() (me *FxPass)</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluation">type FxPassEvaluation</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearColor">type FxPassEvaluationClearColor</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearDepth">type FxPassEvaluationClearDepth</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearStencil">type FxPassEvaluationClearStencil</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationTarget">type FxPassEvaluationTarget</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxPassEvaluationTarget">func NewFxPassEvaluationTarget() (me *FxPassEvaluationTarget)</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgram">type FxPassProgram</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramBindAttribute">type FxPassProgramBindAttribute</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramBindUniform">type FxPassProgramBindUniform</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramShader">type FxPassProgramShader</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramShaderSources">type FxPassProgramShaderSources</a></dd>
				
				
			
				
				<dd><a href="#FxPassState">type FxPassState</a></dd>
				
				
			
				
				<dd><a href="#FxProfile">type FxProfile</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProfile">func NewProfile() (me *FxProfile)</a></dd>
				
				
			
				
				<dd><a href="#FxProfileCommon">type FxProfileCommon</a></dd>
				
				
			
				
				<dd><a href="#FxProfileGlsl">type FxProfileGlsl</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxProfileGlsl">func NewFxProfileGlsl() (me *FxProfileGlsl)</a></dd>
				
				
			
				
				<dd><a href="#FxProfileGlslCodeInclude">type FxProfileGlslCodeInclude</a></dd>
				
				
			
				
				<dd><a href="#FxSampler">type FxSampler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSampler">func NewFxSampler() (me *FxSampler)</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerFiltering">type FxSamplerFiltering</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerImage">type FxSamplerImage</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerStates">type FxSamplerStates</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSamplerStates">func NewFxSamplerStates() (me *FxSamplerStates)</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerWrapping">type FxSamplerWrapping</a></dd>
				
				
			
				
				<dd><a href="#FxTechnique">type FxTechnique</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommon">type FxTechniqueCommon</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommonBlinn">type FxTechniqueCommonBlinn</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommonConstant">type FxTechniqueCommonConstant</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommonLambert">type FxTechniqueCommonLambert</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommonPhong">type FxTechniqueCommonPhong</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueGlsl">type FxTechniqueGlsl</a></dd>
				
				
			
				
				<dd><a href="#FxTexture">type FxTexture</a></dd>
				
				
			
				
				<dd><a href="#FxVertexInputBinding">type FxVertexInputBinding</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrep">type GeometryBrep</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrep">func NewGeometryBrep() (me *GeometryBrep)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepBox">type GeometryBrepBox</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCapsule">type GeometryBrepCapsule</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCircle">type GeometryBrepCircle</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCone">type GeometryBrepCone</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCurve">type GeometryBrepCurve</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCurves">type GeometryBrepCurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCylinder">type GeometryBrepCylinder</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepEdges">type GeometryBrepEdges</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepEllipse">type GeometryBrepEllipse</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepFaces">type GeometryBrepFaces</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepHyperbola">type GeometryBrepHyperbola</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepLine">type GeometryBrepLine</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepNurbs">type GeometryBrepNurbs</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrepNurbs">func NewGeometryBrepNurbs() (me *GeometryBrepNurbs)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepNurbsSurface">type GeometryBrepNurbsSurface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrepNurbsSurface">func NewGeometryBrepNurbsSurface() (me *GeometryBrepNurbsSurface)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepOrientation">type GeometryBrepOrientation</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepParabola">type GeometryBrepParabola</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepPcurves">type GeometryBrepPcurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepPlane">type GeometryBrepPlane</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepShells">type GeometryBrepShells</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSolids">type GeometryBrepSolids</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSphere">type GeometryBrepSphere</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurface">type GeometryBrepSurface</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurfaceCurves">type GeometryBrepSurfaceCurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurfaces">type GeometryBrepSurfaces</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSweptSurface">type GeometryBrepSweptSurface</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryBrepSweptSurface.IsExtrusion">func (me *GeometryBrepSweptSurface) IsExtrusion() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryBrepSweptSurface.IsRevolution">func (me *GeometryBrepSweptSurface) IsRevolution() bool</a></dd>
				
			
				
				<dd><a href="#GeometryBrepTorus">type GeometryBrepTorus</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepWires">type GeometryBrepWires</a></dd>
				
				
			
				
				<dd><a href="#GeometryControlVertices">type GeometryControlVertices</a></dd>
				
				
			
				
				<dd><a href="#GeometryDef">type GeometryDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryDef.Init">func (me *GeometryDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryDef.NewInst">func (me *GeometryDef) NewInst() (inst *GeometryInst)</a></dd>
				
			
				
				<dd><a href="#GeometryInst">type GeometryInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryInst.EnsureDef">func (me *GeometryInst) EnsureDef() *GeometryDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryInst.Init">func (me *GeometryInst) Init()</a></dd>
				
			
				
				<dd><a href="#GeometryMesh">type GeometryMesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryMesh">func NewGeometryMesh() (me *GeometryMesh)</a></dd>
				
				
			
				
				<dd><a href="#GeometryPolygonHole">type GeometryPolygonHole</a></dd>
				
				
			
				
				<dd><a href="#GeometryPositioning">type GeometryPositioning</a></dd>
				
				
			
				
				<dd><a href="#GeometryPrimitives">type GeometryPrimitives</a></dd>
				
				
			
				
				<dd><a href="#GeometrySpline">type GeometrySpline</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometrySpline">func NewGeometrySpline() (me *GeometrySpline)</a></dd>
				
				
			
				
				<dd><a href="#GeometryVertices">type GeometryVertices</a></dd>
				
				
			
				
				<dd><a href="#HasAsset">type HasAsset</a></dd>
				
				
			
				
				<dd><a href="#HasExtras">type HasExtras</a></dd>
				
				
			
				
				<dd><a href="#HasFxParamDefs">type HasFxParamDefs</a></dd>
				
				
			
				
				<dd><a href="#HasId">type HasId</a></dd>
				
				
			
				
				<dd><a href="#HasInputs">type HasInputs</a></dd>
				
				
			
				
				<dd><a href="#HasName">type HasName</a></dd>
				
				
			
				
				<dd><a href="#HasParamDefs">type HasParamDefs</a></dd>
				
				
			
				
				<dd><a href="#HasParamInsts">type HasParamInsts</a></dd>
				
				
			
				
				<dd><a href="#HasSid">type HasSid</a></dd>
				
				
			
				
				<dd><a href="#HasSources">type HasSources</a></dd>
				
				
			
				
				<dd><a href="#HasTechniques">type HasTechniques</a></dd>
				
				
			
				
				<dd><a href="#IndexedInputs">type IndexedInputs</a></dd>
				
				
			
				
				<dd><a href="#Input">type Input</a></dd>
				
				
			
				
				<dd><a href="#InputShared">type InputShared</a></dd>
				
				
			
				
				<dd><a href="#Int2">type Int2</a></dd>
				
				
			
				
				<dd><a href="#Int2x2">type Int2x2</a></dd>
				
				
			
				
				<dd><a href="#Int3">type Int3</a></dd>
				
				
			
				
				<dd><a href="#Int3x3">type Int3x3</a></dd>
				
				
			
				
				<dd><a href="#Int4">type Int4</a></dd>
				
				
			
				
				<dd><a href="#Int4x4">type Int4x4</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemDef">type KxArticulatedSystemDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemDef.Init">func (me *KxArticulatedSystemDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemDef.NewInst">func (me *KxArticulatedSystemDef) NewInst() (inst *KxArticulatedSystemInst)</a></dd>
				
			
				
				<dd><a href="#KxArticulatedSystemInst">type KxArticulatedSystemInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemInst.EnsureDef">func (me *KxArticulatedSystemInst) EnsureDef() *KxArticulatedSystemDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemInst.Init">func (me *KxArticulatedSystemInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxAttachment">type KxAttachment</a></dd>
				
				
			
				
				<dd><a href="#KxAxisIndex">type KxAxisIndex</a></dd>
				
				
			
				
				<dd><a href="#KxAxisLimits">type KxAxisLimits</a></dd>
				
				
			
				
				<dd><a href="#KxBinding">type KxBinding</a></dd>
				
				
			
				
				<dd><a href="#KxEffector">type KxEffector</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxEffector">func NewKxEffector() (me *KxEffector)</a></dd>
				
				
			
				
				<dd><a href="#KxFrame">type KxFrame</a></dd>
				
				
			
				
				<dd><a href="#KxJoint">type KxJoint</a></dd>
				
				
			
				
				<dd><a href="#KxJointAxisBinding">type KxJointAxisBinding</a></dd>
				
				
			
				
				<dd><a href="#KxJointDef">type KxJointDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointDef.Init">func (me *KxJointDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointDef.NewInst">func (me *KxJointDef) NewInst() (inst *KxJointInst)</a></dd>
				
			
				
				<dd><a href="#KxJointInst">type KxJointInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointInst.EnsureDef">func (me *KxJointInst) EnsureDef() *KxJointDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointInst.Init">func (me *KxJointInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxJointLimits">type KxJointLimits</a></dd>
				
				
			
				
				<dd><a href="#KxKinematicsAxis">type KxKinematicsAxis</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxKinematicsAxis">func NewKxKinematicsAxis() (me *KxKinematicsAxis)</a></dd>
				
				
			
				
				<dd><a href="#KxKinematicsSystem">type KxKinematicsSystem</a></dd>
				
				
			
				
				<dd><a href="#KxLink">type KxLink</a></dd>
				
				
			
				
				<dd><a href="#KxModelBinding">type KxModelBinding</a></dd>
				
				
			
				
				<dd><a href="#KxModelDef">type KxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelDef.Init">func (me *KxModelDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelDef.NewInst">func (me *KxModelDef) NewInst() (inst *KxModelInst)</a></dd>
				
			
				
				<dd><a href="#KxModelInst">type KxModelInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelInst.EnsureDef">func (me *KxModelInst) EnsureDef() *KxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelInst.Init">func (me *KxModelInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxMotionAxis">type KxMotionAxis</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxMotionAxis">func NewKxMotionAxis() (me *KxMotionAxis)</a></dd>
				
				
			
				
				<dd><a href="#KxMotionSystem">type KxMotionSystem</a></dd>
				
				
			
				
				<dd><a href="#KxSceneDef">type KxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneDef.Init">func (me *KxSceneDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneDef.NewInst">func (me *KxSceneDef) NewInst() (inst *KxSceneInst)</a></dd>
				
			
				
				<dd><a href="#KxSceneInst">type KxSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneInst.EnsureDef">func (me *KxSceneInst) EnsureDef() *KxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneInst.Init">func (me *KxSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#Layers">type Layers</a></dd>
				
				
			
				
				<dd><a href="#LibAnimationClipDefs">type LibAnimationClipDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Add">func (me *LibAnimationClipDefs) Add(d *AnimationClipDef) (n *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.AddNew">func (me *LibAnimationClipDefs) AddNew(id string) *AnimationClipDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Len">func (me *LibAnimationClipDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.New">func (me *LibAnimationClipDefs) New(id string) (def *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Remove">func (me *LibAnimationClipDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.SyncChanges">func (me *LibAnimationClipDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibAnimationDefs">type LibAnimationDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Add">func (me *LibAnimationDefs) Add(d *AnimationDef) (n *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.AddNew">func (me *LibAnimationDefs) AddNew(id string) *AnimationDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Len">func (me *LibAnimationDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.New">func (me *LibAnimationDefs) New(id string) (def *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Remove">func (me *LibAnimationDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.SyncChanges">func (me *LibAnimationDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibCameraDefs">type LibCameraDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Add">func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.AddNew">func (me *LibCameraDefs) AddNew(id string) *CameraDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Len">func (me *LibCameraDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.New">func (me *LibCameraDefs) New(id string) (def *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Remove">func (me *LibCameraDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.SyncChanges">func (me *LibCameraDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibControllerDefs">type LibControllerDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Add">func (me *LibControllerDefs) Add(d *ControllerDef) (n *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.AddNew">func (me *LibControllerDefs) AddNew(id string) *ControllerDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Len">func (me *LibControllerDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.New">func (me *LibControllerDefs) New(id string) (def *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Remove">func (me *LibControllerDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.SyncChanges">func (me *LibControllerDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFormulaDefs">type LibFormulaDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Add">func (me *LibFormulaDefs) Add(d *FormulaDef) (n *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.AddNew">func (me *LibFormulaDefs) AddNew(id string) *FormulaDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Len">func (me *LibFormulaDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.New">func (me *LibFormulaDefs) New(id string) (def *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Remove">func (me *LibFormulaDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.SyncChanges">func (me *LibFormulaDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxEffectDefs">type LibFxEffectDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Add">func (me *LibFxEffectDefs) Add(d *FxEffectDef) (n *FxEffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.AddNew">func (me *LibFxEffectDefs) AddNew(id string) *FxEffectDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Len">func (me *LibFxEffectDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.New">func (me *LibFxEffectDefs) New(id string) (def *FxEffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Remove">func (me *LibFxEffectDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.SyncChanges">func (me *LibFxEffectDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxImageDefs">type LibFxImageDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Add">func (me *LibFxImageDefs) Add(d *FxImageDef) (n *FxImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.AddFromRefUrls">func (me *LibFxImageDefs) AddFromRefUrls(idRefUrls map[string]string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.AddNew">func (me *LibFxImageDefs) AddNew(id string) *FxImageDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Len">func (me *LibFxImageDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.New">func (me *LibFxImageDefs) New(id string) (def *FxImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Remove">func (me *LibFxImageDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.SyncChanges">func (me *LibFxImageDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxMaterialDefs">type LibFxMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Add">func (me *LibFxMaterialDefs) Add(d *FxMaterialDef) (n *FxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.AddNew">func (me *LibFxMaterialDefs) AddNew(id string) *FxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Len">func (me *LibFxMaterialDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.New">func (me *LibFxMaterialDefs) New(id string) (def *FxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Remove">func (me *LibFxMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.SyncChanges">func (me *LibFxMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibGeometryDefs">type LibGeometryDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Add">func (me *LibGeometryDefs) Add(d *GeometryDef) (n *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.AddNew">func (me *LibGeometryDefs) AddNew(id string) *GeometryDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Len">func (me *LibGeometryDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.New">func (me *LibGeometryDefs) New(id string) (def *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Remove">func (me *LibGeometryDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.SyncChanges">func (me *LibGeometryDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxArticulatedSystemDefs">type LibKxArticulatedSystemDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Add">func (me *LibKxArticulatedSystemDefs) Add(d *KxArticulatedSystemDef) (n *KxArticulatedSystemDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.AddNew">func (me *LibKxArticulatedSystemDefs) AddNew(id string) *KxArticulatedSystemDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Len">func (me *LibKxArticulatedSystemDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.New">func (me *LibKxArticulatedSystemDefs) New(id string) (def *KxArticulatedSystemDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Remove">func (me *LibKxArticulatedSystemDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.SyncChanges">func (me *LibKxArticulatedSystemDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxJointDefs">type LibKxJointDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Add">func (me *LibKxJointDefs) Add(d *KxJointDef) (n *KxJointDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.AddNew">func (me *LibKxJointDefs) AddNew(id string) *KxJointDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Len">func (me *LibKxJointDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.New">func (me *LibKxJointDefs) New(id string) (def *KxJointDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Remove">func (me *LibKxJointDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.SyncChanges">func (me *LibKxJointDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxModelDefs">type LibKxModelDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Add">func (me *LibKxModelDefs) Add(d *KxModelDef) (n *KxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.AddNew">func (me *LibKxModelDefs) AddNew(id string) *KxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Len">func (me *LibKxModelDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.New">func (me *LibKxModelDefs) New(id string) (def *KxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Remove">func (me *LibKxModelDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.SyncChanges">func (me *LibKxModelDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxSceneDefs">type LibKxSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Add">func (me *LibKxSceneDefs) Add(d *KxSceneDef) (n *KxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.AddNew">func (me *LibKxSceneDefs) AddNew(id string) *KxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Len">func (me *LibKxSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.New">func (me *LibKxSceneDefs) New(id string) (def *KxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Remove">func (me *LibKxSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.SyncChanges">func (me *LibKxSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibLightDefs">type LibLightDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Add">func (me *LibLightDefs) Add(d *LightDef) (n *LightDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.AddNew">func (me *LibLightDefs) AddNew(id string) *LightDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Len">func (me *LibLightDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.New">func (me *LibLightDefs) New(id string) (def *LightDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Remove">func (me *LibLightDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.SyncChanges">func (me *LibLightDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibNodeDefs">type LibNodeDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Add">func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.AddNew">func (me *LibNodeDefs) AddNew(id string) *NodeDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Len">func (me *LibNodeDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.New">func (me *LibNodeDefs) New(id string) (def *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Remove">func (me *LibNodeDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.SyncChanges">func (me *LibNodeDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxForceFieldDefs">type LibPxForceFieldDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Add">func (me *LibPxForceFieldDefs) Add(d *PxForceFieldDef) (n *PxForceFieldDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.AddNew">func (me *LibPxForceFieldDefs) AddNew(id string) *PxForceFieldDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Len">func (me *LibPxForceFieldDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.New">func (me *LibPxForceFieldDefs) New(id string) (def *PxForceFieldDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Remove">func (me *LibPxForceFieldDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.SyncChanges">func (me *LibPxForceFieldDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxMaterialDefs">type LibPxMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Add">func (me *LibPxMaterialDefs) Add(d *PxMaterialDef) (n *PxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.AddNew">func (me *LibPxMaterialDefs) AddNew(id string) *PxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Len">func (me *LibPxMaterialDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.New">func (me *LibPxMaterialDefs) New(id string) (def *PxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Remove">func (me *LibPxMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.SyncChanges">func (me *LibPxMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxModelDefs">type LibPxModelDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Add">func (me *LibPxModelDefs) Add(d *PxModelDef) (n *PxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.AddNew">func (me *LibPxModelDefs) AddNew(id string) *PxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Len">func (me *LibPxModelDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.New">func (me *LibPxModelDefs) New(id string) (def *PxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Remove">func (me *LibPxModelDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.SyncChanges">func (me *LibPxModelDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxSceneDefs">type LibPxSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Add">func (me *LibPxSceneDefs) Add(d *PxSceneDef) (n *PxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.AddNew">func (me *LibPxSceneDefs) AddNew(id string) *PxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Len">func (me *LibPxSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.New">func (me *LibPxSceneDefs) New(id string) (def *PxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Remove">func (me *LibPxSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.SyncChanges">func (me *LibPxSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibVisualSceneDefs">type LibVisualSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Add">func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.AddNew">func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Len">func (me *LibVisualSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.New">func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Remove">func (me *LibVisualSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.SyncChanges">func (me *LibVisualSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibsAnimationClipDef">type LibsAnimationClipDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsAnimationClipDef.AddNew">func (me LibsAnimationClipDef) AddNew(id string) (lib *LibAnimationClipDefs)</a></dd>
				
			
				
				<dd><a href="#LibsAnimationDef">type LibsAnimationDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsAnimationDef.AddNew">func (me LibsAnimationDef) AddNew(id string) (lib *LibAnimationDefs)</a></dd>
				
			
				
				<dd><a href="#LibsCameraDef">type LibsCameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsCameraDef.AddNew">func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</a></dd>
				
			
				
				<dd><a href="#LibsControllerDef">type LibsControllerDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsControllerDef.AddNew">func (me LibsControllerDef) AddNew(id string) (lib *LibControllerDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFormulaDef">type LibsFormulaDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFormulaDef.AddNew">func (me LibsFormulaDef) AddNew(id string) (lib *LibFormulaDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxEffectDef">type LibsFxEffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxEffectDef.AddNew">func (me LibsFxEffectDef) AddNew(id string) (lib *LibFxEffectDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxImageDef">type LibsFxImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxImageDef.AddNew">func (me LibsFxImageDef) AddNew(id string) (lib *LibFxImageDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxMaterialDef">type LibsFxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxMaterialDef.AddNew">func (me LibsFxMaterialDef) AddNew(id string) (lib *LibFxMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsGeometryDef">type LibsGeometryDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsGeometryDef.AddNew">func (me LibsGeometryDef) AddNew(id string) (lib *LibGeometryDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxArticulatedSystemDef">type LibsKxArticulatedSystemDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxArticulatedSystemDef.AddNew">func (me LibsKxArticulatedSystemDef) AddNew(id string) (lib *LibKxArticulatedSystemDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxJointDef">type LibsKxJointDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxJointDef.AddNew">func (me LibsKxJointDef) AddNew(id string) (lib *LibKxJointDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxModelDef">type LibsKxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxModelDef.AddNew">func (me LibsKxModelDef) AddNew(id string) (lib *LibKxModelDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxSceneDef">type LibsKxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxSceneDef.AddNew">func (me LibsKxSceneDef) AddNew(id string) (lib *LibKxSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LibsLightDef">type LibsLightDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsLightDef.AddNew">func (me LibsLightDef) AddNew(id string) (lib *LibLightDefs)</a></dd>
				
			
				
				<dd><a href="#LibsNodeDef">type LibsNodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsNodeDef.AddNew">func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxForceFieldDef">type LibsPxForceFieldDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxForceFieldDef.AddNew">func (me LibsPxForceFieldDef) AddNew(id string) (lib *LibPxForceFieldDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxMaterialDef">type LibsPxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxMaterialDef.AddNew">func (me LibsPxMaterialDef) AddNew(id string) (lib *LibPxMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxModelDef">type LibsPxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxModelDef.AddNew">func (me LibsPxModelDef) AddNew(id string) (lib *LibPxModelDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxSceneDef">type LibsPxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxSceneDef.AddNew">func (me LibsPxSceneDef) AddNew(id string) (lib *LibPxSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LibsVisualSceneDef">type LibsVisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsVisualSceneDef.AddNew">func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LightAmbient">type LightAmbient</a></dd>
				
				
			
				
				<dd><a href="#LightAttenuation">type LightAttenuation</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightAttenuation">func NewLightAttenuation() (me *LightAttenuation)</a></dd>
				
				
			
				
				<dd><a href="#LightBase">type LightBase</a></dd>
				
				
			
				
				<dd><a href="#LightDef">type LightDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LightDef.Init">func (me *LightDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LightDef.NewInst">func (me *LightDef) NewInst() (inst *LightInst)</a></dd>
				
			
				
				<dd><a href="#LightDirectional">type LightDirectional</a></dd>
				
				
			
				
				<dd><a href="#LightInst">type LightInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LightInst.EnsureDef">func (me *LightInst) EnsureDef() *LightDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LightInst.Init">func (me *LightInst) Init()</a></dd>
				
			
				
				<dd><a href="#LightPoint">type LightPoint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightPoint">func NewLightPoint() (me *LightPoint)</a></dd>
				
				
			
				
				<dd><a href="#LightSpot">type LightSpot</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightSpot">func NewLightSpot() (me *LightSpot)</a></dd>
				
				
			
				
				<dd><a href="#MaterialBinding">type MaterialBinding</a></dd>
				
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddFaces">func (me *MeshData) AddFaces(faces ...MeshFace3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddNormals">func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddPositions">func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddTexCoords">func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</a></dd>
				
			
				
				<dd><a href="#MeshFace3">type MeshFace3</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#MeshRaw">type MeshRaw</a></dd>
				
				
			
				
				<dd><a href="#MeshRawFace">type MeshRawFace</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshRawFace">func NewMeshRawFace() (me *MeshRawFace)</a></dd>
				
				
			
				
				<dd><a href="#MeshVert">type MeshVert</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt2">type MeshVertAtt2</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt3">type MeshVertAtt3</a></dd>
				
				
			
				
				<dd><a href="#NodeDef">type NodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.Init">func (me *NodeDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.NewInst">func (me *NodeDef) NewInst() (inst *NodeInst)</a></dd>
				
			
				
				<dd><a href="#NodeInst">type NodeInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeInst.EnsureDef">func (me *NodeInst) EnsureDef() *NodeDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeInst.Init">func (me *NodeInst) Init()</a></dd>
				
			
				
				<dd><a href="#Param">type Param</a></dd>
				
				
			
				
				<dd><a href="#ParamDef">type ParamDef</a></dd>
				
				
			
				
				<dd><a href="#ParamDefs">type ParamDefs</a></dd>
				
				
			
				
				<dd><a href="#ParamInst">type ParamInst</a></dd>
				
				
			
				
				<dd><a href="#ParamInsts">type ParamInsts</a></dd>
				
				
			
				
				<dd><a href="#ParamOrBool">type ParamOrBool</a></dd>
				
				
			
				
				<dd><a href="#ParamOrFloat">type ParamOrFloat</a></dd>
				
				
			
				
				<dd><a href="#ParamOrFloat2">type ParamOrFloat2</a></dd>
				
				
			
				
				<dd><a href="#ParamOrInt">type ParamOrInt</a></dd>
				
				
			
				
				<dd><a href="#ParamOrRefSid">type ParamOrRefSid</a></dd>
				
				
			
				
				<dd><a href="#ParamOrSidFloat">type ParamOrSidFloat</a></dd>
				
				
			
				
				<dd><a href="#ParamOrUint">type ParamOrUint</a></dd>
				
				
			
				
				<dd><a href="#PxCylinder">type PxCylinder</a></dd>
				
				
			
				
				<dd><a href="#PxForceFieldDef">type PxForceFieldDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldDef.Init">func (me *PxForceFieldDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldDef.NewInst">func (me *PxForceFieldDef) NewInst() (inst *PxForceFieldInst)</a></dd>
				
			
				
				<dd><a href="#PxForceFieldInst">type PxForceFieldInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldInst.EnsureDef">func (me *PxForceFieldInst) EnsureDef() *PxForceFieldDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldInst.Init">func (me *PxForceFieldInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxMaterial">type PxMaterial</a></dd>
				
				
			
				
				<dd><a href="#PxMaterialDef">type PxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialDef.Init">func (me *PxMaterialDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialDef.NewInst">func (me *PxMaterialDef) NewInst() (inst *PxMaterialInst)</a></dd>
				
			
				
				<dd><a href="#PxMaterialInst">type PxMaterialInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialInst.EnsureDef">func (me *PxMaterialInst) EnsureDef() *PxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialInst.Init">func (me *PxMaterialInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxModelDef">type PxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelDef.Init">func (me *PxModelDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelDef.NewInst">func (me *PxModelDef) NewInst() (inst *PxModelInst)</a></dd>
				
			
				
				<dd><a href="#PxModelInst">type PxModelInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelInst.EnsureDef">func (me *PxModelInst) EnsureDef() *PxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelInst.Init">func (me *PxModelInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidBodyCommon">type PxRigidBodyCommon</a></dd>
				
				
			
				
				<dd><a href="#PxRigidBodyDef">type PxRigidBodyDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidBodyDef.Init">func (me *PxRigidBodyDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidBodyInst">type PxRigidBodyInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidBodyInst.Init">func (me *PxRigidBodyInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintAttachment">type PxRigidConstraintAttachment</a></dd>
				
				
			
				
				<dd><a href="#PxRigidConstraintDef">type PxRigidConstraintDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidConstraintDef.Init">func (me *PxRigidConstraintDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintInst">type PxRigidConstraintInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidConstraintInst.Init">func (me *PxRigidConstraintInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintLimit">type PxRigidConstraintLimit</a></dd>
				
				
			
				
				<dd><a href="#PxRigidConstraintSpring">type PxRigidConstraintSpring</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPxRigidConstraintSpring">func NewPxRigidConstraintSpring() (me *PxRigidConstraintSpring)</a></dd>
				
				
			
				
				<dd><a href="#PxSceneDef">type PxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneDef.Init">func (me *PxSceneDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneDef.NewInst">func (me *PxSceneDef) NewInst() (inst *PxSceneInst)</a></dd>
				
			
				
				<dd><a href="#PxSceneInst">type PxSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneInst.EnsureDef">func (me *PxSceneInst) EnsureDef() *PxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneInst.Init">func (me *PxSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxShape">type PxShape</a></dd>
				
				
			
				
				<dd><a href="#RefId">type RefId</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.AnimationClipDef">func (me RefId) AnimationClipDef() (def *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.AnimationDef">func (me RefId) AnimationDef() (def *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.AnimationSampler">func (me RefId) AnimationSampler() (as *AnimationSampler)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ArrayInAnimationDef">func (me RefId) ArrayInAnimationDef() *SourceArray</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ArrayInControllerDef">func (me RefId) ArrayInControllerDef() *SourceArray</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ArrayInGeometryDef">func (me RefId) ArrayInGeometryDef() (sa *SourceArray)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.CameraDef">func (me RefId) CameraDef() (def *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.ControllerDef">func (me RefId) ControllerDef() (def *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FormulaDef">func (me RefId) FormulaDef() (def *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxEffectDef">func (me RefId) FxEffectDef() (def *FxEffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxImageDef">func (me RefId) FxImageDef() (def *FxImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxMaterialDef">func (me RefId) FxMaterialDef() (def *FxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxProfile">func (me RefId) FxProfile() (fp *FxProfile)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxTechniqueCommon">func (me RefId) FxTechniqueCommon() *FxTechniqueCommon</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.FxTechniqueGlsl">func (me RefId) FxTechniqueGlsl() (t *FxTechniqueGlsl)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepEdges">func (me RefId) GeometryBrepEdges() *GeometryBrepEdges</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepFaces">func (me RefId) GeometryBrepFaces() *GeometryBrepFaces</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepPcurves">func (me RefId) GeometryBrepPcurves() *GeometryBrepPcurves</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepShells">func (me RefId) GeometryBrepShells() *GeometryBrepShells</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepSolids">func (me RefId) GeometryBrepSolids() *GeometryBrepSolids</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryBrepWires">func (me RefId) GeometryBrepWires() *GeometryBrepWires</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryDef">func (me RefId) GeometryDef() (def *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryMesh">func (me RefId) GeometryMesh() (gm *GeometryMesh)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.GeometryVertices">func (me RefId) GeometryVertices() *GeometryVertices</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.KxArticulatedSystemDef">func (me RefId) KxArticulatedSystemDef() (def *KxArticulatedSystemDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.KxJointDef">func (me RefId) KxJointDef() (def *KxJointDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.KxModelDef">func (me RefId) KxModelDef() (def *KxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.KxSceneDef">func (me RefId) KxSceneDef() (def *KxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.LightDef">func (me RefId) LightDef() (def *LightDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.NodeDef">func (me RefId) NodeDef() (def *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.PxForceFieldDef">func (me RefId) PxForceFieldDef() (def *PxForceFieldDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.PxMaterialDef">func (me RefId) PxMaterialDef() (def *PxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.PxModelDef">func (me RefId) PxModelDef() (def *PxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.PxSceneDef">func (me RefId) PxSceneDef() (def *PxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.S">func (me RefId) S() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SetIdRef">func (me *RefId) SetIdRef(v string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SourceInAnimationDef">func (me RefId) SourceInAnimationDef() (s *Source)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SourceInControllerDef">func (me RefId) SourceInControllerDef() (s *Source)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.SourceInGeometryDef">func (me RefId) SourceInGeometryDef() (s *Source)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.VisualSceneDef">func (me RefId) VisualSceneDef() (def *VisualSceneDef)</a></dd>
				
			
				
				<dd><a href="#RefParam">type RefParam</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefParam.S">func (me RefParam) S() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefParam.SetParamRef">func (me *RefParam) SetParamRef(v string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefParam.Sr">func (me RefParam) Sr() RefSid</a></dd>
				
			
				
				<dd><a href="#RefSid">type RefSid</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefSid.S">func (me RefSid) S() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefSid.SetSidRef">func (me *RefSid) SetSidRef(v string)</a></dd>
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
				
			
				
				<dd><a href="#SidBool">type SidBool</a></dd>
				
				
			
				
				<dd><a href="#SidFloat">type SidFloat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SidF">func SidF(f float64) (sf *SidFloat)</a></dd>
				
				
			
				
				<dd><a href="#SidFloat3">type SidFloat3</a></dd>
				
				
			
				
				<dd><a href="#SidString">type SidString</a></dd>
				
				
			
				
				<dd><a href="#SidVec3">type SidVec3</a></dd>
				
				
			
				
				<dd><a href="#Source">type Source</a></dd>
				
				
			
				
				<dd><a href="#SourceAccessor">type SourceAccessor</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSourceAccessor">func NewSourceAccessor() (me *SourceAccessor)</a></dd>
				
				
			
				
				<dd><a href="#SourceArray">type SourceArray</a></dd>
				
				
			
				
				<dd><a href="#Sources">type Sources</a></dd>
				
				
			
				
				<dd><a href="#Technique">type Technique</a></dd>
				
				
			
				
				<dd><a href="#Transform">type Transform</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneDef">type VisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneDef.Init">func (me *VisualSceneDef) Init()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneDef.NewInst">func (me *VisualSceneDef) NewInst() (inst *VisualSceneInst)</a></dd>
				
			
				
				<dd><a href="#VisualSceneEvaluation">type VisualSceneEvaluation</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneInst">type VisualSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneInst.EnsureDef">func (me *VisualSceneInst) EnsureDef() *VisualSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneInst.Init">func (me *VisualSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#VisualSceneRendering">type VisualSceneRendering</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewVisualSceneRendering">func NewVisualSceneRendering() (me *VisualSceneRendering)</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneRenderingMaterialInst">type VisualSceneRenderingMaterialInst</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-pkgreflect.go">-pkgreflect.go</a>
			
				<a href="/target/animation.gt.go">animation.gt.go</a>
			
				<a href="/target/animationclip.gt.go">animationclip.gt.go</a>
			
				<a href="/target/assets.go">assets.go</a>
			
				<a href="/target/base.go">base.go</a>
			
				<a href="/target/camera.gt.go">camera.gt.go</a>
			
				<a href="/target/common.go">common.go</a>
			
				<a href="/target/controller.gt.go">controller.gt.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/formula.gt.go">formula.gt.go</a>
			
				<a href="/target/fxeffect.gt.go">fxeffect.gt.go</a>
			
				<a href="/target/fximage.gt.go">fximage.gt.go</a>
			
				<a href="/target/fxmaterial.gt.go">fxmaterial.gt.go</a>
			
				<a href="/target/fxsampler.go">fxsampler.go</a>
			
				<a href="/target/geometry.gt.go">geometry.gt.go</a>
			
				<a href="/target/geometrybrep.go">geometrybrep.go</a>
			
				<a href="/target/kxarticulatedsystem.gt.go">kxarticulatedsystem.gt.go</a>
			
				<a href="/target/kxjoint.gt.go">kxjoint.gt.go</a>
			
				<a href="/target/kxmodel.gt.go">kxmodel.gt.go</a>
			
				<a href="/target/kxscene.gt.go">kxscene.gt.go</a>
			
				<a href="/target/light.gt.go">light.gt.go</a>
			
				<a href="/target/meshdata.go">meshdata.go</a>
			
				<a href="/target/node.gt.go">node.gt.go</a>
			
				<a href="/target/pxforcefield.gt.go">pxforcefield.gt.go</a>
			
				<a href="/target/pxmaterial.gt.go">pxmaterial.gt.go</a>
			
				<a href="/target/pxmodel.gt.go">pxmodel.gt.go</a>
			
				<a href="/target/pxrigidbody.go">pxrigidbody.go</a>
			
				<a href="/target/pxrigidconstraint.go">pxrigidconstraint.go</a>
			
				<a href="/target/pxscene.gt.go">pxscene.gt.go</a>
			
				<a href="/target/refid.go">refid.go</a>
			
				<a href="/target/refparam.go">refparam.go</a>
			
				<a href="/target/refsid.go">refsid.go</a>
			
				<a href="/target/source.go">source.go</a>
			
				<a href="/target/types.go">types.go</a>
			
				<a href="/target/visualscene.gt.go">visualscene.gt.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    <span class="comment">//	The before and after behaviors are not defined.</span>
    ANIM_SAMPLER_BEHAVIOR_UNDEFINED = 0
    <span class="comment">//	The value for the first (PreBehavior) or last (PostBehavior) is returned.</span>
    ANIM_SAMPLER_BEHAVIOR_CONSTANT = iota
    <span class="comment">//	The key is mapped in the [first_key , last_key] interval so that the animation cycles.</span>
    ANIM_SAMPLER_BEHAVIOR_CYCLE = iota
    <span class="comment">//	The animation continues indefinitely.</span>
    ANIM_SAMPLER_BEHAVIOR_CYCLE_RELATIVE = iota
    <span class="comment">//	The value follows the line given by the last two keys in the sample.</span>
    ANIM_SAMPLER_BEHAVIOR_GRADIENT = iota
    <span class="comment">//	The key is mapped in the [first_key , last_key] interval so that the animation oscillates.</span>
    ANIM_SAMPLER_BEHAVIOR_OSCILLATE = iota
)</pre>
				
			
				<pre>const (
    <span class="comment">//	A position and orientation transformation suitable for aiming a camera.</span>
    TRANSFORM_TYPE_LOOKAT = 1
    <span class="comment">//	A transformation that embodies mathematical changes to points within a coordinate system</span>
    <span class="comment">//	or the coordinate system itself.</span>
    TRANSFORM_TYPE_MATRIX = iota
    <span class="comment">//	A transformation that specifies how to rotate an object around an axis.</span>
    TRANSFORM_TYPE_ROTATE = iota
    <span class="comment">//	A transformation that specifies how to deform an object along one axis.</span>
    TRANSFORM_TYPE_SKEW = iota
    <span class="comment">//	A transformation that specifies how to change an object&#39;s size.</span>
    TRANSFORM_TYPE_SCALE = iota
    <span class="comment">//	A transformation that changes the position of an object in a local coordinate system.</span>
    TRANSFORM_TYPE_TRANSLATE = iota
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Takes the transparency information from the color&#39;s alpha channel,</span>
    <span class="comment">//	where the value 1.0 is opaque.</span>
    FX_COLOR_TEXTURE_OPAQUE_A_ZERO = 0
    <span class="comment">//	Takes the transparency information from the color&#39;s red, green, and blue channels,</span>
    <span class="comment">//	where the value 0.0 is opaque, with each channel modulated independently.</span>
    FX_COLOR_TEXTURE_OPAQUE_A_ONE = 1
    <span class="comment">//	Takes the transparency information from the color&#39;s alpha channel,</span>
    <span class="comment">//	where the value 0.0 is opaque.</span>
    FX_COLOR_TEXTURE_OPAQUE_RGB_ZERO = 2
    <span class="comment">//	Takes the transparency information from the color&#39;s red, green, and blue channels,</span>
    <span class="comment">//	where the value 1.0 is opaque, with each channel modulated independently.</span>
    FX_COLOR_TEXTURE_OPAQUE_RGB_ONE = 3

    <span class="comment">//	This programmable shader is designed to execute in the Tessellation pipeline stage.</span>
    FX_PASS_PROGRAM_SHADER_STAGE_TESSELLATION = 0
    <span class="comment">//	This programmable shader is designed to execute in the Vertex pipeline stage.</span>
    FX_PASS_PROGRAM_SHADER_STAGE_VERTEX = 1
    <span class="comment">//	This programmable shader is designed to execute in the Geometry pipeline stage.</span>
    FX_PASS_PROGRAM_SHADER_STAGE_GEOMETRY = 2
    <span class="comment">//	This programmable shader is designed to execute in the Fragment pipeline stage.</span>
    FX_PASS_PROGRAM_SHADER_STAGE_FRAGMENT = 3
    <span class="comment">//	This programmable shader is designed to execute in the Compute pipeline stage.</span>
    FX_PASS_PROGRAM_SHADER_STAGE_COMPUTE = 4
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Depth map, often used for displacement, parellax, relief, or shadow mapping.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_D = 1
    <span class="comment">//	Luminance map, often used for light mapping.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_L = iota
    <span class="comment">//	Luminance with alpha map, often used for light mapping.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_LA = iota
    <span class="comment">//	RGB color map</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_RGB = iota
    <span class="comment">//	RGB color with alpha map. Often used for color plus transparency</span>
    <span class="comment">//	or other things packed into channel A, such as specular power.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_RGBA = iota
    <span class="comment">//	RGB color with shared exponent for HDR.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_RGBE = iota

    <span class="comment">//	Designer does not care as long as it provides &#34;reasonable&#34; precision and performance.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_DEFAULT = 1
    <span class="comment">//	For integers, this typically represents 16 to 32 bits. For floating points, typically</span>
    <span class="comment">//	24 to 32 bits.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_HIGH = iota
    <span class="comment">//	For integers, this typically represents 8 bits. For floating points, typically 16 bits.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_LOW = iota
    <span class="comment">//	Typically 32 bits or 64 bits if available. 64 bits has been separated into its own category</span>
    <span class="comment">//	beyond HIGH because it typically has significant performance impact.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_MAX = iota
    <span class="comment">//	For integers, this typically represents 8 to 24 bits.</span>
    <span class="comment">//	For floating points, typically 16 to 32 bits.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_MID = iota

    <span class="comment">//	Format should support full floating-point ranges.</span>
    <span class="comment">//	High precision is expected to be 32 bits.</span>
    <span class="comment">//	Mid precision may be 16 to 32 bits.</span>
    <span class="comment">//	Low precision is expected to be 16 bits.</span>
    FX_CREATE_FORMAT_HINT_RANGE_FLOAT = 1
    <span class="comment">//	Format represents signed integer numbers. For example, 8 bits is -128 to 127.</span>
    FX_CREATE_FORMAT_HINT_RANGE_SINT = iota
    <span class="comment">//	Format represents a decimal value that remains within the -1 to 1 range.</span>
    <span class="comment">//	Implementation could be integer-fixed-point or floating point.</span>
    FX_CREATE_FORMAT_HINT_RANGE_SNORM = iota
    <span class="comment">//	Format represent unsigned integer numbers. For example, 8 bits is 0 to 255.</span>
    FX_CREATE_FORMAT_HINT_RANGE_UINT = iota
    <span class="comment">//	Format represents a decimal value that remains within the 0 to 1 range.</span>
    <span class="comment">//	Implementation could be integer-fixed-point or floating point.</span>
    FX_CREATE_FORMAT_HINT_RANGE_UNORM = iota

    <span class="comment">//	Cube-map face target &#34;X negative&#34;</span>
    FX_CUBE_FACE_NEGATIVE_X = 0x8516
    <span class="comment">//	Cube-map face target &#34;Y negative&#34;</span>
    FX_CUBE_FACE_NEGATIVE_Y = 0x8518
    <span class="comment">//	Cube-map face target &#34;Z negative&#34;</span>
    FX_CUBE_FACE_NEGATIVE_Z = 0x851A
    <span class="comment">//	Cube-map face target &#34;X positive&#34;</span>
    FX_CUBE_FACE_POSITIVE_X = 0x8515
    <span class="comment">//	Cube-map face target &#34;Y positive&#34;</span>
    FX_CUBE_FACE_POSITIVE_Y = 0x8517
    <span class="comment">//	Cube-map face target &#34;Z positive&#34;</span>
    FX_CUBE_FACE_POSITIVE_Z = 0x8519
)</pre>
				
			
				<pre>const (
    <span class="comment">//	No MIP-mapped minification.</span>
    FX_SAMPLER_FILTER_NONE = 20
    <span class="comment">//	Bilinear filtering.</span>
    FX_SAMPLER_FILTER_NEAREST = 0x2600
    <span class="comment">//	Trilinear filtering.</span>
    FX_SAMPLER_FILTER_LINEAR = 0x2601
    <span class="comment">//	Compensates for distortion caused by the difference in angle between a polygon and the view plane.</span>
    FX_SAMPLER_FILTER_ANISOTROPIC = 21

    <span class="comment">//	Declares a one-dimensional texture sampler.</span>
    FX_SAMPLER_TYPE_1D = 0x8B5D
    <span class="comment">//	Declares a two-dimensional texture sampler.</span>
    FX_SAMPLER_TYPE_2D = 0x8B5E
    <span class="comment">//	Declares a three-dimensional texture sampler.</span>
    FX_SAMPLER_TYPE_3D = 0x8B5F
    <span class="comment">//	Declares a texture sampler for cube maps.</span>
    FX_SAMPLER_TYPE_CUBE = 0x8B60
    <span class="comment">//	Declares a texture sampler for depth maps.</span>
    FX_SAMPLER_TYPE_DEPTH = 30
    <span class="comment">//	Declares a rectangular texture sampler.</span>
    FX_SAMPLER_TYPE_RECT = 31

    <span class="comment">//	Ignores the integer part of texture coordinates, using only the fractional part and tiling the</span>
    <span class="comment">//	texture at every integer junction. For example, for u values between 0 and 3, the texture is</span>
    <span class="comment">//	repeated three times; no mirroring is performed.</span>
    FX_SAMPLER_WRAP_WRAP = 0x2901
    <span class="comment">//	First mirrors the texture coordinate. The mirrored coordinate is then clamped as described for</span>
    <span class="comment">//	FX_SAMPLER_WRAP_CLAMP. Flips the texture at every integer junction. For u values between 0 and 1,</span>
    <span class="comment">//	for example, the texture is addressed normally; between 1 and 2, the texture is flipped (mirrored);</span>
    <span class="comment">//	between 2 and 3, the texture is normal again; and so on.</span>
    FX_SAMPLER_WRAP_MIRROR = 0x8370
    <span class="comment">//	Clamps texture coordinates at all MIPmap levels such that</span>
    <span class="comment">//	the texture filter never samples a border texel.</span>
    FX_SAMPLER_WRAP_CLAMP = 0x812F
    <span class="comment">//	Clamps texture coordinates at all MIPmaps such that the texture filter always samples border</span>
    <span class="comment">//	texels for fragments whose corresponding texture coordinate is sufficiently far outside</span>
    <span class="comment">//	the range [0, 1]. Much like FX_SAMPLER_WRAP_CLAMP, except texture coordinates outside</span>
    <span class="comment">//	the range [0.0, 1.0] are set to the border color.</span>
    FX_SAMPLER_WRAP_BORDER = 0x812D
    <span class="comment">//	Takes the absolute value of the texture coordinate (thus, mirroring around 0),</span>
    <span class="comment">//	and then clamps to the maximum value.</span>
    FX_SAMPLER_WRAP_MIRROR_ONCE = 40
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Organizes vertices into individual lines.</span>
    GEOMETRY_PRIMITIVE_TYPE_LINES = 0x0001
    <span class="comment">//	Organizes vertices into connected line-strips.</span>
    GEOMETRY_PRIMITIVE_TYPE_LINE_STRIPS = 0x0003
    <span class="comment">//	Organizes vertices into individual polygons that may contain holes.</span>
    GEOMETRY_PRIMITIVE_TYPE_POLYGONS = 2
    <span class="comment">//	Organizes vertices into individual polygons that cannot contain holes.</span>
    GEOMETRY_PRIMITIVE_TYPE_POLYLIST = 7
    <span class="comment">//	Organizes vertices into individual triangles.</span>
    GEOMETRY_PRIMITIVE_TYPE_TRIANGLES = 0x0004
    <span class="comment">//	Organizes vertices into fan-connected triangles.</span>
    GEOMETRY_PRIMITIVE_TYPE_TRIFANS = 0x0006
    <span class="comment">//	Organizes vertices into strip-connected triangles.</span>
    GEOMETRY_PRIMITIVE_TYPE_TRISTRIPS = 0x0005
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Defines the base frame for kinematics calculation.</span>
    KX_FRAME_TYPE_ORIGIN = 1
    <span class="comment">//	Defines the frame at the end of the kinematics chain.</span>
    KX_FRAME_TYPE_TIP = iota
    <span class="comment">//	Defines the offset frame from the kinematics KX_FRAME_TYPE_TIP frame,</span>
    <span class="comment">//	which usually represents the work point of the end effector (for example, a welding gun).</span>
    KX_FRAME_TYPE_TCP = iota
    <span class="comment">//	Defines the offset frame from the kinematics KX_FRAME_TYPE_ORIGIN frame;</span>
    <span class="comment">//	this offset usually represents the transformation to a work piece.</span>
    KX_FRAME_TYPE_OBJECT = iota
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Defines a single translational degree of freedom of a joint.</span>
    KX_JOINT_TYPE_PRISMATIC = 1
    <span class="comment">//	Defines a single rotational degree of freedom of a joint.</span>
    KX_JOINT_TYPE_REVOLUTE = iota
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Connects two links, describing a real parent-child dependency between them.</span>
    KX_ATTACHMENT_TYPE_FULL = 1
    <span class="comment">//	Connects two links and defines one end of a closed loop.</span>
    KX_ATTACHMENT_TYPE_START = iota
    <span class="comment">//	Defines one end of the closed loop in an attachment.</span>
    KX_ATTACHMENT_TYPE_END = iota
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibAnimationDefs libraries associated by their Id.</span>
    AllAnimationDefLibs = LibsAnimationDef{}

    <span class="comment">//	The &#34;default&#34; LibAnimationDefs library for AnimationDefs.</span>
    AnimationDefs = AllAnimationDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibAnimationClipDefs libraries associated by their Id.</span>
    AllAnimationClipDefLibs = LibsAnimationClipDef{}

    <span class="comment">//	The &#34;default&#34; LibAnimationClipDefs library for AnimationClipDefs.</span>
    AnimationClipDefs = AllAnimationClipDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	This callback, set by the core package (or your custom package),</span>
    <span class="comment">//	gets called before SyncChanges() proceeds with syncing.</span>
    OnBeforeSyncAll func()
    <span class="comment">//	This callback, set by the core package (or your custom package),</span>
    <span class="comment">//	gets called after SyncChanges() has finished syncing.</span>
    OnAfterSyncAll func()
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibCameraDefs libraries associated by their Id.</span>
    AllCameraDefLibs = LibsCameraDef{}

    <span class="comment">//	The &#34;default&#34; LibCameraDefs library for CameraDefs.</span>
    CameraDefs = AllCameraDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibControllerDefs libraries associated by their Id.</span>
    AllControllerDefLibs = LibsControllerDef{}

    <span class="comment">//	The &#34;default&#34; LibControllerDefs library for ControllerDefs.</span>
    ControllerDefs = AllControllerDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibFormulaDefs libraries associated by their Id.</span>
    AllFormulaDefLibs = LibsFormulaDef{}

    <span class="comment">//	The &#34;default&#34; LibFormulaDefs library for FormulaDefs.</span>
    FormulaDefs = AllFormulaDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibFxEffectDefs libraries associated by their Id.</span>
    AllFxEffectDefLibs = LibsFxEffectDef{}

    <span class="comment">//	The &#34;default&#34; LibFxEffectDefs library for FxEffectDefs.</span>
    FxEffectDefs = AllFxEffectDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibFxImageDefs libraries associated by their Id.</span>
    AllFxImageDefLibs = LibsFxImageDef{}

    <span class="comment">//	The &#34;default&#34; LibFxImageDefs library for FxImageDefs.</span>
    FxImageDefs = AllFxImageDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibFxMaterialDefs libraries associated by their Id.</span>
    AllFxMaterialDefLibs = LibsFxMaterialDef{}

    <span class="comment">//	The &#34;default&#34; LibFxMaterialDefs library for FxMaterialDefs.</span>
    FxMaterialDefs = AllFxMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	Default texture minification, magnification and MIP-mapping.</span>
    DefaultFxSamplerFiltering = &amp;FxSamplerFiltering{
        FilterMag:     FX_SAMPLER_FILTER_LINEAR,
        FilterMin:     FX_SAMPLER_FILTER_LINEAR,
        FilterMip:     FX_SAMPLER_FILTER_LINEAR,
        MaxAnisotropy: 1,
    }
    <span class="comment">//	Default texture repeating and clamping.</span>
    DefaultFxSamplerWrapping = &amp;FxSamplerWrapping{
        BorderColor: ugfx.Rgba32{R: 0, G: 0, B: 0, A: 1},
        WrapS:       FX_SAMPLER_WRAP_WRAP,
        WrapT:       FX_SAMPLER_WRAP_WRAP,
        WrapP:       FX_SAMPLER_WRAP_WRAP,
    }
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibGeometryDefs libraries associated by their Id.</span>
    AllGeometryDefLibs = LibsGeometryDef{}

    <span class="comment">//	The &#34;default&#34; LibGeometryDefs library for GeometryDefs.</span>
    GeometryDefs = AllGeometryDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibKxArticulatedSystemDefs libraries associated by their Id.</span>
    AllKxArticulatedSystemDefLibs = LibsKxArticulatedSystemDef{}

    <span class="comment">//	The &#34;default&#34; LibKxArticulatedSystemDefs library for KxArticulatedSystemDefs.</span>
    KxArticulatedSystemDefs = AllKxArticulatedSystemDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibKxJointDefs libraries associated by their Id.</span>
    AllKxJointDefLibs = LibsKxJointDef{}

    <span class="comment">//	The &#34;default&#34; LibKxJointDefs library for KxJointDefs.</span>
    KxJointDefs = AllKxJointDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibKxModelDefs libraries associated by their Id.</span>
    AllKxModelDefLibs = LibsKxModelDef{}

    <span class="comment">//	The &#34;default&#34; LibKxModelDefs library for KxModelDefs.</span>
    KxModelDefs = AllKxModelDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibKxSceneDefs libraries associated by their Id.</span>
    AllKxSceneDefLibs = LibsKxSceneDef{}

    <span class="comment">//	The &#34;default&#34; LibKxSceneDefs library for KxSceneDefs.</span>
    KxSceneDefs = AllKxSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibLightDefs libraries associated by their Id.</span>
    AllLightDefLibs = LibsLightDef{}

    <span class="comment">//	The &#34;default&#34; LibLightDefs library for LightDefs.</span>
    LightDefs = AllLightDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibNodeDefs libraries associated by their Id.</span>
    AllNodeDefLibs = LibsNodeDef{}

    <span class="comment">//	The &#34;default&#34; LibNodeDefs library for NodeDefs.</span>
    NodeDefs = AllNodeDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibPxForceFieldDefs libraries associated by their Id.</span>
    AllPxForceFieldDefLibs = LibsPxForceFieldDef{}

    <span class="comment">//	The &#34;default&#34; LibPxForceFieldDefs library for PxForceFieldDefs.</span>
    PxForceFieldDefs = AllPxForceFieldDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibPxMaterialDefs libraries associated by their Id.</span>
    AllPxMaterialDefLibs = LibsPxMaterialDef{}

    <span class="comment">//	The &#34;default&#34; LibPxMaterialDefs library for PxMaterialDefs.</span>
    PxMaterialDefs = AllPxMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibPxModelDefs libraries associated by their Id.</span>
    AllPxModelDefLibs = LibsPxModelDef{}

    <span class="comment">//	The &#34;default&#34; LibPxModelDefs library for PxModelDefs.</span>
    PxModelDefs = AllPxModelDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibPxSceneDefs libraries associated by their Id.</span>
    AllPxSceneDefLibs = LibsPxSceneDef{}

    <span class="comment">//	The &#34;default&#34; LibPxSceneDefs library for PxSceneDefs.</span>
    PxSceneDefs = AllPxSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A hash-table that contains LibVisualSceneDefs libraries associated by their Id.</span>
    AllVisualSceneDefLibs = LibsVisualSceneDef{}

    <span class="comment">//	The &#34;default&#34; LibVisualSceneDefs library for VisualSceneDefs.</span>
    VisualSceneDefs = AllVisualSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var Functions = map[string]reflect.Value{
    &#34;NewGeometryBrepNurbsSurface&#34;: reflect.ValueOf(NewGeometryBrepNurbsSurface),
    &#34;NewGeometryBrep&#34;:             reflect.ValueOf(NewGeometryBrep),
    &#34;NewGeometryBrepNurbs&#34;:        reflect.ValueOf(NewGeometryBrepNurbs),
    &#34;NewVisualSceneRendering&#34;:     reflect.ValueOf(NewVisualSceneRendering),
    &#34;NewGeometryMesh&#34;:             reflect.ValueOf(NewGeometryMesh),
    &#34;NewGeometrySpline&#34;:           reflect.ValueOf(NewGeometrySpline),
    &#34;NewSourceAccessor&#34;:           reflect.ValueOf(NewSourceAccessor),
    &#34;NewFxImageInitFrom&#34;:          reflect.ValueOf(NewFxImageInitFrom),
    &#34;NewAsset&#34;:                    reflect.ValueOf(NewAsset),
    &#34;NewProfile&#34;:                  reflect.ValueOf(NewProfile),
    &#34;NewFxPass&#34;:                   reflect.ValueOf(NewFxPass),
    &#34;NewFxPassEvaluationTarget&#34;:   reflect.ValueOf(NewFxPassEvaluationTarget),
    &#34;NewFxProfileGlsl&#34;:            reflect.ValueOf(NewFxProfileGlsl),
    &#34;NewPxRigidConstraintSpring&#34;:  reflect.ValueOf(NewPxRigidConstraintSpring),
    &#34;NewLightPoint&#34;:               reflect.ValueOf(NewLightPoint),
    &#34;NewLightSpot&#34;:                reflect.ValueOf(NewLightSpot),
    &#34;NewLightAttenuation&#34;:         reflect.ValueOf(NewLightAttenuation),
    &#34;NewKxEffector&#34;:               reflect.ValueOf(NewKxEffector),
    &#34;NewKxMotionAxis&#34;:             reflect.ValueOf(NewKxMotionAxis),
    &#34;NewKxKinematicsAxis&#34;:         reflect.ValueOf(NewKxKinematicsAxis),
    &#34;NewMeshData&#34;:                 reflect.ValueOf(NewMeshData),
    &#34;NewMeshRawFace&#34;:              reflect.ValueOf(NewMeshRawFace),
    &#34;NewFxSamplerStates&#34;:          reflect.ValueOf(NewFxSamplerStates),
    &#34;NewFxSampler&#34;:                reflect.ValueOf(NewFxSampler),
    &#34;NewControllerSkin&#34;:           reflect.ValueOf(NewControllerSkin),
    &#34;NewControllerMorph&#34;:          reflect.ValueOf(NewControllerMorph),
    &#34;SidF&#34;:                        reflect.ValueOf(SidF),
    &#34;SyncChanges&#34;:                 reflect.ValueOf(SyncChanges),
}</pre>
				
			
				<pre>var Types = map[string]reflect.Type{
    &#34;NodeInst&#34;:                         reflect.TypeOf((*NodeInst)(nil)).Elem(),
    &#34;NodeDef&#34;:                          reflect.TypeOf((*NodeDef)(nil)).Elem(),
    &#34;LibNodeDefs&#34;:                      reflect.TypeOf((*LibNodeDefs)(nil)).Elem(),
    &#34;ChildNode&#34;:                        reflect.TypeOf((*ChildNode)(nil)).Elem(),
    &#34;LibsNodeDef&#34;:                      reflect.TypeOf((*LibsNodeDef)(nil)).Elem(),
    &#34;FxPassProgramShaderSources&#34;:       reflect.TypeOf((*FxPassProgramShaderSources)(nil)).Elem(),
    &#34;FxTechnique&#34;:                      reflect.TypeOf((*FxTechnique)(nil)).Elem(),
    &#34;LibsFxEffectDef&#34;:                  reflect.TypeOf((*LibsFxEffectDef)(nil)).Elem(),
    &#34;FxParamDef&#34;:                       reflect.TypeOf((*FxParamDef)(nil)).Elem(),
    &#34;FxPassEvaluation&#34;:                 reflect.TypeOf((*FxPassEvaluation)(nil)).Elem(),
    &#34;FxPassState&#34;:                      reflect.TypeOf((*FxPassState)(nil)).Elem(),
    &#34;FxParamDefs&#34;:                      reflect.TypeOf((*FxParamDefs)(nil)).Elem(),
    &#34;FxPassProgramShader&#34;:              reflect.TypeOf((*FxPassProgramShader)(nil)).Elem(),
    &#34;FxProfile&#34;:                        reflect.TypeOf((*FxProfile)(nil)).Elem(),
    &#34;FxPassProgramBindAttribute&#34;:       reflect.TypeOf((*FxPassProgramBindAttribute)(nil)).Elem(),
    &#34;FxPassProgram&#34;:                    reflect.TypeOf((*FxPassProgram)(nil)).Elem(),
    &#34;FxTechniqueGlsl&#34;:                  reflect.TypeOf((*FxTechniqueGlsl)(nil)).Elem(),
    &#34;FxPassEvaluationClearStencil&#34;:     reflect.TypeOf((*FxPassEvaluationClearStencil)(nil)).Elem(),
    &#34;FxPassEvaluationTarget&#34;:           reflect.TypeOf((*FxPassEvaluationTarget)(nil)).Elem(),
    &#34;FxEffectInst&#34;:                     reflect.TypeOf((*FxEffectInst)(nil)).Elem(),
    &#34;FxAnnotation&#34;:                     reflect.TypeOf((*FxAnnotation)(nil)).Elem(),
    &#34;FxEffectInstTechniqueHint&#34;:        reflect.TypeOf((*FxEffectInstTechniqueHint)(nil)).Elem(),
    &#34;FxTechniqueCommonBlinn&#34;:           reflect.TypeOf((*FxTechniqueCommonBlinn)(nil)).Elem(),
    &#34;LibFxEffectDefs&#34;:                  reflect.TypeOf((*LibFxEffectDefs)(nil)).Elem(),
    &#34;FxTechniqueCommonLambert&#34;:         reflect.TypeOf((*FxTechniqueCommonLambert)(nil)).Elem(),
    &#34;FxTexture&#34;:                        reflect.TypeOf((*FxTexture)(nil)).Elem(),
    &#34;FxPass&#34;:                           reflect.TypeOf((*FxPass)(nil)).Elem(),
    &#34;FxTechniqueCommonConstant&#34;:        reflect.TypeOf((*FxTechniqueCommonConstant)(nil)).Elem(),
    &#34;FxEffectDef&#34;:                      reflect.TypeOf((*FxEffectDef)(nil)).Elem(),
    &#34;FxColorOrTexture&#34;:                 reflect.TypeOf((*FxColorOrTexture)(nil)).Elem(),
    &#34;FxProfileGlsl&#34;:                    reflect.TypeOf((*FxProfileGlsl)(nil)).Elem(),
    &#34;FxProfileCommon&#34;:                  reflect.TypeOf((*FxProfileCommon)(nil)).Elem(),
    &#34;FxProfileGlslCodeInclude&#34;:         reflect.TypeOf((*FxProfileGlslCodeInclude)(nil)).Elem(),
    &#34;FxPassEvaluationClearDepth&#34;:       reflect.TypeOf((*FxPassEvaluationClearDepth)(nil)).Elem(),
    &#34;FxTechniqueCommonPhong&#34;:           reflect.TypeOf((*FxTechniqueCommonPhong)(nil)).Elem(),
    &#34;FxPassProgramBindUniform&#34;:         reflect.TypeOf((*FxPassProgramBindUniform)(nil)).Elem(),
    &#34;FxPassEvaluationClearColor&#34;:       reflect.TypeOf((*FxPassEvaluationClearColor)(nil)).Elem(),
    &#34;FxTechniqueCommon&#34;:                reflect.TypeOf((*FxTechniqueCommon)(nil)).Elem(),
    &#34;RefId&#34;:                            reflect.TypeOf((*RefId)(nil)).Elem(),
    &#34;PxMaterialInst&#34;:                   reflect.TypeOf((*PxMaterialInst)(nil)).Elem(),
    &#34;PxMaterialDef&#34;:                    reflect.TypeOf((*PxMaterialDef)(nil)).Elem(),
    &#34;LibPxMaterialDefs&#34;:                reflect.TypeOf((*LibPxMaterialDefs)(nil)).Elem(),
    &#34;LibsPxMaterialDef&#34;:                reflect.TypeOf((*LibsPxMaterialDef)(nil)).Elem(),
    &#34;PxRigidConstraintLimit&#34;:           reflect.TypeOf((*PxRigidConstraintLimit)(nil)).Elem(),
    &#34;PxRigidConstraintSpring&#34;:          reflect.TypeOf((*PxRigidConstraintSpring)(nil)).Elem(),
    &#34;PxRigidConstraintDef&#34;:             reflect.TypeOf((*PxRigidConstraintDef)(nil)).Elem(),
    &#34;PxRigidConstraintAttachment&#34;:      reflect.TypeOf((*PxRigidConstraintAttachment)(nil)).Elem(),
    &#34;PxRigidConstraintInst&#34;:            reflect.TypeOf((*PxRigidConstraintInst)(nil)).Elem(),
    &#34;LightAttenuation&#34;:                 reflect.TypeOf((*LightAttenuation)(nil)).Elem(),
    &#34;LightAmbient&#34;:                     reflect.TypeOf((*LightAmbient)(nil)).Elem(),
    &#34;LightSpot&#34;:                        reflect.TypeOf((*LightSpot)(nil)).Elem(),
    &#34;LibLightDefs&#34;:                     reflect.TypeOf((*LibLightDefs)(nil)).Elem(),
    &#34;LightDef&#34;:                         reflect.TypeOf((*LightDef)(nil)).Elem(),
    &#34;LightPoint&#34;:                       reflect.TypeOf((*LightPoint)(nil)).Elem(),
    &#34;LibsLightDef&#34;:                     reflect.TypeOf((*LibsLightDef)(nil)).Elem(),
    &#34;LightDirectional&#34;:                 reflect.TypeOf((*LightDirectional)(nil)).Elem(),
    &#34;LightBase&#34;:                        reflect.TypeOf((*LightBase)(nil)).Elem(),
    &#34;LightInst&#34;:                        reflect.TypeOf((*LightInst)(nil)).Elem(),
    &#34;LibKxArticulatedSystemDefs&#34;:       reflect.TypeOf((*LibKxArticulatedSystemDefs)(nil)).Elem(),
    &#34;LibsKxArticulatedSystemDef&#34;:       reflect.TypeOf((*LibsKxArticulatedSystemDef)(nil)).Elem(),
    &#34;KxKinematicsAxis&#34;:                 reflect.TypeOf((*KxKinematicsAxis)(nil)).Elem(),
    &#34;KxArticulatedSystemInst&#34;:          reflect.TypeOf((*KxArticulatedSystemInst)(nil)).Elem(),
    &#34;KxMotionAxis&#34;:                     reflect.TypeOf((*KxMotionAxis)(nil)).Elem(),
    &#34;KxAxisIndex&#34;:                      reflect.TypeOf((*KxAxisIndex)(nil)).Elem(),
    &#34;KxMotionSystem&#34;:                   reflect.TypeOf((*KxMotionSystem)(nil)).Elem(),
    &#34;KxBinding&#34;:                        reflect.TypeOf((*KxBinding)(nil)).Elem(),
    &#34;KxArticulatedSystemDef&#34;:           reflect.TypeOf((*KxArticulatedSystemDef)(nil)).Elem(),
    &#34;KxAxisLimits&#34;:                     reflect.TypeOf((*KxAxisLimits)(nil)).Elem(),
    &#34;KxKinematicsSystem&#34;:               reflect.TypeOf((*KxKinematicsSystem)(nil)).Elem(),
    &#34;KxFrame&#34;:                          reflect.TypeOf((*KxFrame)(nil)).Elem(),
    &#34;KxEffector&#34;:                       reflect.TypeOf((*KxEffector)(nil)).Elem(),
    &#34;KxAttachment&#34;:                     reflect.TypeOf((*KxAttachment)(nil)).Elem(),
    &#34;LibKxModelDefs&#34;:                   reflect.TypeOf((*LibKxModelDefs)(nil)).Elem(),
    &#34;LibsKxModelDef&#34;:                   reflect.TypeOf((*LibsKxModelDef)(nil)).Elem(),
    &#34;KxModelInst&#34;:                      reflect.TypeOf((*KxModelInst)(nil)).Elem(),
    &#34;KxModelDef&#34;:                       reflect.TypeOf((*KxModelDef)(nil)).Elem(),
    &#34;KxLink&#34;:                           reflect.TypeOf((*KxLink)(nil)).Elem(),
    &#34;AnimationSampler&#34;:                 reflect.TypeOf((*AnimationSampler)(nil)).Elem(),
    &#34;AnimationDef&#34;:                     reflect.TypeOf((*AnimationDef)(nil)).Elem(),
    &#34;LibsAnimationDef&#34;:                 reflect.TypeOf((*LibsAnimationDef)(nil)).Elem(),
    &#34;AnimationInst&#34;:                    reflect.TypeOf((*AnimationInst)(nil)).Elem(),
    &#34;AnimationChannel&#34;:                 reflect.TypeOf((*AnimationChannel)(nil)).Elem(),
    &#34;LibAnimationDefs&#34;:                 reflect.TypeOf((*LibAnimationDefs)(nil)).Elem(),
    &#34;LibPxForceFieldDefs&#34;:              reflect.TypeOf((*LibPxForceFieldDefs)(nil)).Elem(),
    &#34;PxForceFieldDef&#34;:                  reflect.TypeOf((*PxForceFieldDef)(nil)).Elem(),
    &#34;PxForceFieldInst&#34;:                 reflect.TypeOf((*PxForceFieldInst)(nil)).Elem(),
    &#34;LibsPxForceFieldDef&#34;:              reflect.TypeOf((*LibsPxForceFieldDef)(nil)).Elem(),
    &#34;KxJointInst&#34;:                      reflect.TypeOf((*KxJointInst)(nil)).Elem(),
    &#34;LibKxJointDefs&#34;:                   reflect.TypeOf((*LibKxJointDefs)(nil)).Elem(),
    &#34;KxJointLimits&#34;:                    reflect.TypeOf((*KxJointLimits)(nil)).Elem(),
    &#34;KxJoint&#34;:                          reflect.TypeOf((*KxJoint)(nil)).Elem(),
    &#34;LibsKxJointDef&#34;:                   reflect.TypeOf((*LibsKxJointDef)(nil)).Elem(),
    &#34;KxJointDef&#34;:                       reflect.TypeOf((*KxJointDef)(nil)).Elem(),
    &#34;MeshProvider&#34;:                     reflect.TypeOf((*MeshProvider)(nil)).Elem(),
    &#34;MeshVertAtt2&#34;:                     reflect.TypeOf((*MeshVertAtt2)(nil)).Elem(),
    &#34;MeshVert&#34;:                         reflect.TypeOf((*MeshVert)(nil)).Elem(),
    &#34;MeshData&#34;:                         reflect.TypeOf((*MeshData)(nil)).Elem(),
    &#34;MeshRaw&#34;:                          reflect.TypeOf((*MeshRaw)(nil)).Elem(),
    &#34;MeshVertAtt3&#34;:                     reflect.TypeOf((*MeshVertAtt3)(nil)).Elem(),
    &#34;MeshRawFace&#34;:                      reflect.TypeOf((*MeshRawFace)(nil)).Elem(),
    &#34;MeshFace3&#34;:                        reflect.TypeOf((*MeshFace3)(nil)).Elem(),
    &#34;Document&#34;:                         reflect.TypeOf((*Document)(nil)).Elem(),
    &#34;LibPxSceneDefs&#34;:                   reflect.TypeOf((*LibPxSceneDefs)(nil)).Elem(),
    &#34;PxSceneInst&#34;:                      reflect.TypeOf((*PxSceneInst)(nil)).Elem(),
    &#34;LibsPxSceneDef&#34;:                   reflect.TypeOf((*LibsPxSceneDef)(nil)).Elem(),
    &#34;PxSceneDef&#34;:                       reflect.TypeOf((*PxSceneDef)(nil)).Elem(),
    &#34;RefParam&#34;:                         reflect.TypeOf((*RefParam)(nil)).Elem(),
    &#34;FxSamplerImage&#34;:                   reflect.TypeOf((*FxSamplerImage)(nil)).Elem(),
    &#34;FxSamplerStates&#34;:                  reflect.TypeOf((*FxSamplerStates)(nil)).Elem(),
    &#34;FxSamplerFiltering&#34;:               reflect.TypeOf((*FxSamplerFiltering)(nil)).Elem(),
    &#34;FxSampler&#34;:                        reflect.TypeOf((*FxSampler)(nil)).Elem(),
    &#34;FxSamplerWrapping&#34;:                reflect.TypeOf((*FxSamplerWrapping)(nil)).Elem(),
    &#34;KxModelBinding&#34;:                   reflect.TypeOf((*KxModelBinding)(nil)).Elem(),
    &#34;LibKxSceneDefs&#34;:                   reflect.TypeOf((*LibKxSceneDefs)(nil)).Elem(),
    &#34;KxJointAxisBinding&#34;:               reflect.TypeOf((*KxJointAxisBinding)(nil)).Elem(),
    &#34;KxSceneDef&#34;:                       reflect.TypeOf((*KxSceneDef)(nil)).Elem(),
    &#34;KxSceneInst&#34;:                      reflect.TypeOf((*KxSceneInst)(nil)).Elem(),
    &#34;LibsKxSceneDef&#34;:                   reflect.TypeOf((*LibsKxSceneDef)(nil)).Elem(),
    &#34;ControllerInst&#34;:                   reflect.TypeOf((*ControllerInst)(nil)).Elem(),
    &#34;ControllerMorph&#34;:                  reflect.TypeOf((*ControllerMorph)(nil)).Elem(),
    &#34;ControllerInputs&#34;:                 reflect.TypeOf((*ControllerInputs)(nil)).Elem(),
    &#34;LibsControllerDef&#34;:                reflect.TypeOf((*LibsControllerDef)(nil)).Elem(),
    &#34;ControllerDef&#34;:                    reflect.TypeOf((*ControllerDef)(nil)).Elem(),
    &#34;LibControllerDefs&#34;:                reflect.TypeOf((*LibControllerDefs)(nil)).Elem(),
    &#34;ControllerSkin&#34;:                   reflect.TypeOf((*ControllerSkin)(nil)).Elem(),
    &#34;BaseSync&#34;:                         reflect.TypeOf((*BaseSync)(nil)).Elem(),
    &#34;BaseInst&#34;:                         reflect.TypeOf((*BaseInst)(nil)).Elem(),
    &#34;BaseDef&#34;:                          reflect.TypeOf((*BaseDef)(nil)).Elem(),
    &#34;BaseLib&#34;:                          reflect.TypeOf((*BaseLib)(nil)).Elem(),
    &#34;SidString&#34;:                        reflect.TypeOf((*SidString)(nil)).Elem(),
    &#34;Float4x4&#34;:                         reflect.TypeOf((*Float4x4)(nil)).Elem(),
    &#34;Float2x2&#34;:                         reflect.TypeOf((*Float2x2)(nil)).Elem(),
    &#34;Float3x2&#34;:                         reflect.TypeOf((*Float3x2)(nil)).Elem(),
    &#34;Float7&#34;:                           reflect.TypeOf((*Float7)(nil)).Elem(),
    &#34;ParamOrInt&#34;:                       reflect.TypeOf((*ParamOrInt)(nil)).Elem(),
    &#34;Bool2&#34;:                            reflect.TypeOf((*Bool2)(nil)).Elem(),
    &#34;ParamOrSidFloat&#34;:                  reflect.TypeOf((*ParamOrSidFloat)(nil)).Elem(),
    &#34;Float2&#34;:                           reflect.TypeOf((*Float2)(nil)).Elem(),
    &#34;ParamOrFloat&#34;:                     reflect.TypeOf((*ParamOrFloat)(nil)).Elem(),
    &#34;Float2x3&#34;:                         reflect.TypeOf((*Float2x3)(nil)).Elem(),
    &#34;Float3x3&#34;:                         reflect.TypeOf((*Float3x3)(nil)).Elem(),
    &#34;Float3&#34;:                           reflect.TypeOf((*Float3)(nil)).Elem(),
    &#34;Float2x4&#34;:                         reflect.TypeOf((*Float2x4)(nil)).Elem(),
    &#34;Float4x3&#34;:                         reflect.TypeOf((*Float4x3)(nil)).Elem(),
    &#34;Int2x2&#34;:                           reflect.TypeOf((*Int2x2)(nil)).Elem(),
    &#34;Int2&#34;:                             reflect.TypeOf((*Int2)(nil)).Elem(),
    &#34;ParamOrUint&#34;:                      reflect.TypeOf((*ParamOrUint)(nil)).Elem(),
    &#34;Bool4&#34;:                            reflect.TypeOf((*Bool4)(nil)).Elem(),
    &#34;Bool3&#34;:                            reflect.TypeOf((*Bool3)(nil)).Elem(),
    &#34;ParamOrBool&#34;:                      reflect.TypeOf((*ParamOrBool)(nil)).Elem(),
    &#34;SidFloat3&#34;:                        reflect.TypeOf((*SidFloat3)(nil)).Elem(),
    &#34;Float4&#34;:                           reflect.TypeOf((*Float4)(nil)).Elem(),
    &#34;Float4x2&#34;:                         reflect.TypeOf((*Float4x2)(nil)).Elem(),
    &#34;Int3x3&#34;:                           reflect.TypeOf((*Int3x3)(nil)).Elem(),
    &#34;Int4x4&#34;:                           reflect.TypeOf((*Int4x4)(nil)).Elem(),
    &#34;Int3&#34;:                             reflect.TypeOf((*Int3)(nil)).Elem(),
    &#34;Float3x4&#34;:                         reflect.TypeOf((*Float3x4)(nil)).Elem(),
    &#34;ParamOrRefSid&#34;:                    reflect.TypeOf((*ParamOrRefSid)(nil)).Elem(),
    &#34;SidBool&#34;:                          reflect.TypeOf((*SidBool)(nil)).Elem(),
    &#34;SidFloat&#34;:                         reflect.TypeOf((*SidFloat)(nil)).Elem(),
    &#34;SidVec3&#34;:                          reflect.TypeOf((*SidVec3)(nil)).Elem(),
    &#34;Int4&#34;:                             reflect.TypeOf((*Int4)(nil)).Elem(),
    &#34;ParamOrFloat2&#34;:                    reflect.TypeOf((*ParamOrFloat2)(nil)).Elem(),
    &#34;LibsPxModelDef&#34;:                   reflect.TypeOf((*LibsPxModelDef)(nil)).Elem(),
    &#34;PxModelInst&#34;:                      reflect.TypeOf((*PxModelInst)(nil)).Elem(),
    &#34;LibPxModelDefs&#34;:                   reflect.TypeOf((*LibPxModelDefs)(nil)).Elem(),
    &#34;PxModelDef&#34;:                       reflect.TypeOf((*PxModelDef)(nil)).Elem(),
    &#34;FormulaDef&#34;:                       reflect.TypeOf((*FormulaDef)(nil)).Elem(),
    &#34;LibFormulaDefs&#34;:                   reflect.TypeOf((*LibFormulaDefs)(nil)).Elem(),
    &#34;Formula&#34;:                          reflect.TypeOf((*Formula)(nil)).Elem(),
    &#34;FormulaInst&#34;:                      reflect.TypeOf((*FormulaInst)(nil)).Elem(),
    &#34;LibsFormulaDef&#34;:                   reflect.TypeOf((*LibsFormulaDef)(nil)).Elem(),
    &#34;GeometryBrep&#34;:                     reflect.TypeOf((*GeometryBrep)(nil)).Elem(),
    &#34;GeometryBrepNurbs&#34;:                reflect.TypeOf((*GeometryBrepNurbs)(nil)).Elem(),
    &#34;GeometryBrepOrientation&#34;:          reflect.TypeOf((*GeometryBrepOrientation)(nil)).Elem(),
    &#34;GeometryBrepCurve&#34;:                reflect.TypeOf((*GeometryBrepCurve)(nil)).Elem(),
    &#34;GeometryBrepSurfaceCurves&#34;:        reflect.TypeOf((*GeometryBrepSurfaceCurves)(nil)).Elem(),
    &#34;GeometryBrepBox&#34;:                  reflect.TypeOf((*GeometryBrepBox)(nil)).Elem(),
    &#34;GeometryBrepPcurves&#34;:              reflect.TypeOf((*GeometryBrepPcurves)(nil)).Elem(),
    &#34;GeometryBrepHyperbola&#34;:            reflect.TypeOf((*GeometryBrepHyperbola)(nil)).Elem(),
    &#34;GeometryBrepPlane&#34;:                reflect.TypeOf((*GeometryBrepPlane)(nil)).Elem(),
    &#34;GeometryBrepShells&#34;:               reflect.TypeOf((*GeometryBrepShells)(nil)).Elem(),
    &#34;GeometryBrepSurfaces&#34;:             reflect.TypeOf((*GeometryBrepSurfaces)(nil)).Elem(),
    &#34;GeometryBrepNurbsSurface&#34;:         reflect.TypeOf((*GeometryBrepNurbsSurface)(nil)).Elem(),
    &#34;GeometryBrepCurves&#34;:               reflect.TypeOf((*GeometryBrepCurves)(nil)).Elem(),
    &#34;GeometryBrepSphere&#34;:               reflect.TypeOf((*GeometryBrepSphere)(nil)).Elem(),
    &#34;GeometryBrepWires&#34;:                reflect.TypeOf((*GeometryBrepWires)(nil)).Elem(),
    &#34;GeometryBrepCylinder&#34;:             reflect.TypeOf((*GeometryBrepCylinder)(nil)).Elem(),
    &#34;GeometryBrepSweptSurface&#34;:         reflect.TypeOf((*GeometryBrepSweptSurface)(nil)).Elem(),
    &#34;GeometryBrepTorus&#34;:                reflect.TypeOf((*GeometryBrepTorus)(nil)).Elem(),
    &#34;GeometryBrepParabola&#34;:             reflect.TypeOf((*GeometryBrepParabola)(nil)).Elem(),
    &#34;GeometryBrepEllipse&#34;:              reflect.TypeOf((*GeometryBrepEllipse)(nil)).Elem(),
    &#34;GeometryBrepEdges&#34;:                reflect.TypeOf((*GeometryBrepEdges)(nil)).Elem(),
    &#34;GeometryBrepCone&#34;:                 reflect.TypeOf((*GeometryBrepCone)(nil)).Elem(),
    &#34;GeometryBrepCircle&#34;:               reflect.TypeOf((*GeometryBrepCircle)(nil)).Elem(),
    &#34;GeometryBrepSurface&#34;:              reflect.TypeOf((*GeometryBrepSurface)(nil)).Elem(),
    &#34;GeometryBrepLine&#34;:                 reflect.TypeOf((*GeometryBrepLine)(nil)).Elem(),
    &#34;GeometryPositioning&#34;:              reflect.TypeOf((*GeometryPositioning)(nil)).Elem(),
    &#34;GeometryBrepFaces&#34;:                reflect.TypeOf((*GeometryBrepFaces)(nil)).Elem(),
    &#34;GeometryBrepSolids&#34;:               reflect.TypeOf((*GeometryBrepSolids)(nil)).Elem(),
    &#34;GeometryBrepCapsule&#34;:              reflect.TypeOf((*GeometryBrepCapsule)(nil)).Elem(),
    &#34;LibVisualSceneDefs&#34;:               reflect.TypeOf((*LibVisualSceneDefs)(nil)).Elem(),
    &#34;VisualSceneEvaluation&#34;:            reflect.TypeOf((*VisualSceneEvaluation)(nil)).Elem(),
    &#34;VisualSceneInst&#34;:                  reflect.TypeOf((*VisualSceneInst)(nil)).Elem(),
    &#34;VisualSceneRendering&#34;:             reflect.TypeOf((*VisualSceneRendering)(nil)).Elem(),
    &#34;LibsVisualSceneDef&#34;:               reflect.TypeOf((*LibsVisualSceneDef)(nil)).Elem(),
    &#34;VisualSceneRenderingMaterialInst&#34;: reflect.TypeOf((*VisualSceneRenderingMaterialInst)(nil)).Elem(),
    &#34;VisualSceneDef&#34;:                   reflect.TypeOf((*VisualSceneDef)(nil)).Elem(),
    &#34;LibsCameraDef&#34;:                    reflect.TypeOf((*LibsCameraDef)(nil)).Elem(),
    &#34;CameraPerspective&#34;:                reflect.TypeOf((*CameraPerspective)(nil)).Elem(),
    &#34;CameraOptics&#34;:                     reflect.TypeOf((*CameraOptics)(nil)).Elem(),
    &#34;CameraImager&#34;:                     reflect.TypeOf((*CameraImager)(nil)).Elem(),
    &#34;CameraDef&#34;:                        reflect.TypeOf((*CameraDef)(nil)).Elem(),
    &#34;CameraOrthographic&#34;:               reflect.TypeOf((*CameraOrthographic)(nil)).Elem(),
    &#34;LibCameraDefs&#34;:                    reflect.TypeOf((*LibCameraDefs)(nil)).Elem(),
    &#34;CameraInst&#34;:                       reflect.TypeOf((*CameraInst)(nil)).Elem(),
    &#34;LibGeometryDefs&#34;:                  reflect.TypeOf((*LibGeometryDefs)(nil)).Elem(),
    &#34;GeometryPolygonHole&#34;:              reflect.TypeOf((*GeometryPolygonHole)(nil)).Elem(),
    &#34;GeometryPrimitives&#34;:               reflect.TypeOf((*GeometryPrimitives)(nil)).Elem(),
    &#34;GeometryVertices&#34;:                 reflect.TypeOf((*GeometryVertices)(nil)).Elem(),
    &#34;GeometryDef&#34;:                      reflect.TypeOf((*GeometryDef)(nil)).Elem(),
    &#34;LibsGeometryDef&#34;:                  reflect.TypeOf((*LibsGeometryDef)(nil)).Elem(),
    &#34;GeometryInst&#34;:                     reflect.TypeOf((*GeometryInst)(nil)).Elem(),
    &#34;GeometryControlVertices&#34;:          reflect.TypeOf((*GeometryControlVertices)(nil)).Elem(),
    &#34;GeometrySpline&#34;:                   reflect.TypeOf((*GeometrySpline)(nil)).Elem(),
    &#34;GeometryMesh&#34;:                     reflect.TypeOf((*GeometryMesh)(nil)).Elem(),
    &#34;SourceArray&#34;:                      reflect.TypeOf((*SourceArray)(nil)).Elem(),
    &#34;Source&#34;:                           reflect.TypeOf((*Source)(nil)).Elem(),
    &#34;SourceAccessor&#34;:                   reflect.TypeOf((*SourceAccessor)(nil)).Elem(),
    &#34;Sources&#34;:                          reflect.TypeOf((*Sources)(nil)).Elem(),
    &#34;RefSid&#34;:                           reflect.TypeOf((*RefSid)(nil)).Elem(),
    &#34;LibAnimationClipDefs&#34;:             reflect.TypeOf((*LibAnimationClipDefs)(nil)).Elem(),
    &#34;AnimationClipInst&#34;:                reflect.TypeOf((*AnimationClipInst)(nil)).Elem(),
    &#34;AnimationClipDef&#34;:                 reflect.TypeOf((*AnimationClipDef)(nil)).Elem(),
    &#34;LibsAnimationClipDef&#34;:             reflect.TypeOf((*LibsAnimationClipDef)(nil)).Elem(),
    &#34;FxCreate3DInitFrom&#34;:               reflect.TypeOf((*FxCreate3DInitFrom)(nil)).Elem(),
    &#34;FxCreateFormat&#34;:                   reflect.TypeOf((*FxCreateFormat)(nil)).Elem(),
    &#34;FxCreateCubeInitFrom&#34;:             reflect.TypeOf((*FxCreateCubeInitFrom)(nil)).Elem(),
    &#34;LibsFxImageDef&#34;:                   reflect.TypeOf((*LibsFxImageDef)(nil)).Elem(),
    &#34;FxImageInst&#34;:                      reflect.TypeOf((*FxImageInst)(nil)).Elem(),
    &#34;FxCreate2D&#34;:                       reflect.TypeOf((*FxCreate2D)(nil)).Elem(),
    &#34;FxCreate2DSizeExact&#34;:              reflect.TypeOf((*FxCreate2DSizeExact)(nil)).Elem(),
    &#34;FxCreateMips&#34;:                     reflect.TypeOf((*FxCreateMips)(nil)).Elem(),
    &#34;FxCreateCube&#34;:                     reflect.TypeOf((*FxCreateCube)(nil)).Elem(),
    &#34;FxCreate&#34;:                         reflect.TypeOf((*FxCreate)(nil)).Elem(),
    &#34;FxImageDef&#34;:                       reflect.TypeOf((*FxImageDef)(nil)).Elem(),
    &#34;FxCreateInitFrom&#34;:                 reflect.TypeOf((*FxCreateInitFrom)(nil)).Elem(),
    &#34;FxImageInitFrom&#34;:                  reflect.TypeOf((*FxImageInitFrom)(nil)).Elem(),
    &#34;FxCreateFormatHint&#34;:               reflect.TypeOf((*FxCreateFormatHint)(nil)).Elem(),
    &#34;LibFxImageDefs&#34;:                   reflect.TypeOf((*LibFxImageDefs)(nil)).Elem(),
    &#34;FxCreate3D&#34;:                       reflect.TypeOf((*FxCreate3D)(nil)).Elem(),
    &#34;FxInitFrom&#34;:                       reflect.TypeOf((*FxInitFrom)(nil)).Elem(),
    &#34;FxCreate2DSizeRatio&#34;:              reflect.TypeOf((*FxCreate2DSizeRatio)(nil)).Elem(),
    &#34;ParamDef&#34;:                         reflect.TypeOf((*ParamDef)(nil)).Elem(),
    &#34;HasSid&#34;:                           reflect.TypeOf((*HasSid)(nil)).Elem(),
    &#34;Scene&#34;:                            reflect.TypeOf((*Scene)(nil)).Elem(),
    &#34;HasParamInsts&#34;:                    reflect.TypeOf((*HasParamInsts)(nil)).Elem(),
    &#34;Transform&#34;:                        reflect.TypeOf((*Transform)(nil)).Elem(),
    &#34;HasTechniques&#34;:                    reflect.TypeOf((*HasTechniques)(nil)).Elem(),
    &#34;MaterialBinding&#34;:                  reflect.TypeOf((*MaterialBinding)(nil)).Elem(),
    &#34;AssetContributor&#34;:                 reflect.TypeOf((*AssetContributor)(nil)).Elem(),
    &#34;HasFxParamDefs&#34;:                   reflect.TypeOf((*HasFxParamDefs)(nil)).Elem(),
    &#34;ParamDefs&#34;:                        reflect.TypeOf((*ParamDefs)(nil)).Elem(),
    &#34;Param&#34;:                            reflect.TypeOf((*Param)(nil)).Elem(),
    &#34;IndexedInputs&#34;:                    reflect.TypeOf((*IndexedInputs)(nil)).Elem(),
    &#34;HasInputs&#34;:                        reflect.TypeOf((*HasInputs)(nil)).Elem(),
    &#34;HasName&#34;:                          reflect.TypeOf((*HasName)(nil)).Elem(),
    &#34;HasSources&#34;:                       reflect.TypeOf((*HasSources)(nil)).Elem(),
    &#34;Extra&#34;:                            reflect.TypeOf((*Extra)(nil)).Elem(),
    &#34;AssetGeographicLocation&#34;:          reflect.TypeOf((*AssetGeographicLocation)(nil)).Elem(),
    &#34;Asset&#34;:                            reflect.TypeOf((*Asset)(nil)).Elem(),
    &#34;HasParamDefs&#34;:                     reflect.TypeOf((*HasParamDefs)(nil)).Elem(),
    &#34;HasId&#34;:                            reflect.TypeOf((*HasId)(nil)).Elem(),
    &#34;InputShared&#34;:                      reflect.TypeOf((*InputShared)(nil)).Elem(),
    &#34;ParamInsts&#34;:                       reflect.TypeOf((*ParamInsts)(nil)).Elem(),
    &#34;HasAsset&#34;:                         reflect.TypeOf((*HasAsset)(nil)).Elem(),
    &#34;ParamInst&#34;:                        reflect.TypeOf((*ParamInst)(nil)).Elem(),
    &#34;Input&#34;:                            reflect.TypeOf((*Input)(nil)).Elem(),
    &#34;Layers&#34;:                           reflect.TypeOf((*Layers)(nil)).Elem(),
    &#34;Technique&#34;:                        reflect.TypeOf((*Technique)(nil)).Elem(),
    &#34;HasExtras&#34;:                        reflect.TypeOf((*HasExtras)(nil)).Elem(),
    &#34;PxRigidBodyInst&#34;:                  reflect.TypeOf((*PxRigidBodyInst)(nil)).Elem(),
    &#34;PxMaterial&#34;:                       reflect.TypeOf((*PxMaterial)(nil)).Elem(),
    &#34;PxRigidBodyDef&#34;:                   reflect.TypeOf((*PxRigidBodyDef)(nil)).Elem(),
    &#34;PxCylinder&#34;:                       reflect.TypeOf((*PxCylinder)(nil)).Elem(),
    &#34;PxRigidBodyCommon&#34;:                reflect.TypeOf((*PxRigidBodyCommon)(nil)).Elem(),
    &#34;PxShape&#34;:                          reflect.TypeOf((*PxShape)(nil)).Elem(),
    &#34;FxBinding&#34;:                        reflect.TypeOf((*FxBinding)(nil)).Elem(),
    &#34;FxVertexInputBinding&#34;:             reflect.TypeOf((*FxVertexInputBinding)(nil)).Elem(),
    &#34;FxMaterialDef&#34;:                    reflect.TypeOf((*FxMaterialDef)(nil)).Elem(),
    &#34;LibsFxMaterialDef&#34;:                reflect.TypeOf((*LibsFxMaterialDef)(nil)).Elem(),
    &#34;LibFxMaterialDefs&#34;:                reflect.TypeOf((*LibFxMaterialDefs)(nil)).Elem(),
    &#34;FxMaterialInst&#34;:                   reflect.TypeOf((*FxMaterialInst)(nil)).Elem(),
}</pre>
				
			
		
		
			
			
			<h2 id="SyncChanges">func <a href="/target/assets.go?s=874:892#L25">SyncChanges</a></h2>
			<pre>func SyncChanges()</pre>
			<p>
Signals to the core package (or your custom package) that changes have been made that need to be
picked up. Call this after you have made any number of changes to your Defs, Insts or Libs.
</p>

			
		
		
			
			
			<h2 id="AnimationChannel">type <a href="/target/animation.gt.go?s=741:918#L9">AnimationChannel</a></h2>
			<pre>type AnimationChannel struct {
    <span class="comment">//	Refers to the source animation sampler.</span>
    Source RefId
    <span class="comment">//	Refers to the resource property bound to the output of the sampler.</span>
    Target RefSid
}</pre>
			<p>
Declares an output channel of an animation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="AnimationClipDef">type <a href="/target/animationclip.gt.go?s=127:491#L1">AnimationClipDef</a></h2>
			<pre>type AnimationClipDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	The time in seconds of the beginning of the clip.</span>
    Start float64
    <span class="comment">//	The time in seconds of the end of the clip.</span>
    End float64
    <span class="comment">//	The animation instances contributing to this animation clip.</span>
    Animations []*AnimationInst
    <span class="comment">//	Any formulas used in this animation clip.</span>
    Formulas []*FormulaInst
}</pre>
			<p>
Defines a section of a set of animation curves and/or formulas
to be used together as an animation clip.
</p>


			

			

			

			

			
				
				<h3 id="AnimationClipDef.Init">func (*AnimationClipDef) <a href="/target/animationclip.gt.go?s=511:545#L9">Init</a></h3>
				<pre>func (me *AnimationClipDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="AnimationClipDef.NewInst">func (*AnimationClipDef) <a href="/target/animationclip.gt.go?s=1223:1286#L36">NewInst</a></h3>
				<pre>func (me *AnimationClipDef) NewInst() (inst *AnimationClipInst)</pre>
				<p>
Creates and returns a new AnimationClipInst instance referencing this AnimationClipDef definition.
</p>

				
				
			
		
			
			
			<h2 id="AnimationClipInst">type <a href="/target/animationclip.gt.go?s=595:875#L13">AnimationClipInst</a></h2>
			<pre>type AnimationClipInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *AnimationClipDef
}</pre>
			<p>
Instantiates an animation clip resource.
</p>


			

			

			

			

			
				
				<h3 id="AnimationClipInst.EnsureDef">func (*AnimationClipInst) <a href="/target/animationclip.gt.go?s=1565:1623#L46">EnsureDef</a></h3>
				<pre>func (me *AnimationClipInst) EnsureDef() *AnimationClipDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct AnimationClipDef
according to the current me.DefRef value (by searching AllAnimationClipDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="AnimationClipInst.Init">func (*AnimationClipInst) <a href="/target/animationclip.gt.go?s=895:930#L22">Init</a></h3>
				<pre>func (me *AnimationClipInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="AnimationDef">type <a href="/target/animation.gt.go?s=1536:1898#L32">AnimationDef</a></h2>
			<pre>type AnimationDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sources</span>
    HasSources
    <span class="comment">//	Allows the formation of a hierarchy of related animations.</span>
    AnimationDefs []*AnimationDef
    <span class="comment">//	Describes output channels for the animation.</span>
    Channels []*AnimationChannel
    <span class="comment">//	Describes the interpolation sampling functions for the animation.</span>
    Samplers []*AnimationSampler
}</pre>
			<p>
Categorizes the declaration of animation information.
</p>


			

			

			

			

			
				
				<h3 id="AnimationDef.Init">func (*AnimationDef) <a href="/target/animation.gt.go?s=1918:1948#L46">Init</a></h3>
				<pre>func (me *AnimationDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="AnimationDef.NewInst">func (*AnimationDef) <a href="/target/animation.gt.go?s=2609:2664#L74">NewInst</a></h3>
				<pre>func (me *AnimationDef) NewInst() (inst *AnimationInst)</pre>
				<p>
Creates and returns a new AnimationInst instance referencing this AnimationDef definition.
</p>

				
				
			
		
			
			
			<h2 id="AnimationInst">type <a href="/target/animation.gt.go?s=2017:2289#L51">AnimationInst</a></h2>
			<pre>type AnimationInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *AnimationDef
}</pre>
			<p>
Instantiates an Animation resource.
</p>


			

			

			

			

			
				
				<h3 id="AnimationInst.EnsureDef">func (*AnimationInst) <a href="/target/animation.gt.go?s=2931:2981#L84">EnsureDef</a></h3>
				<pre>func (me *AnimationInst) EnsureDef() *AnimationDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct AnimationDef
according to the current me.DefRef value (by searching AllAnimationDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="AnimationInst.Init">func (*AnimationInst) <a href="/target/animation.gt.go?s=2309:2340#L60">Init</a></h3>
				<pre>func (me *AnimationInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="AnimationSampler">type <a href="/target/animation.gt.go?s=985:1477#L17">AnimationSampler</a></h2>
			<pre>type AnimationSampler struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Inputs. These describe sampling points.</span>
    <span class="comment">//	At least one of the Inputs must have its Semantic set to &#34;INTERPOLATION&#34;.</span>
    HasInputs
    <span class="comment">//	Indicates what the sampled value should be before the first key.</span>
    <span class="comment">//	Valid values are the ANIM_SAMPLER_BEHAVIOR_* enumerated constants.</span>
    PreBehavior int
    <span class="comment">//	Indicates what the sampled value should be after the last key.</span>
    <span class="comment">//	Valid values are the ANIM_SAMPLER_BEHAVIOR_* enumerated constants.</span>
    PostBehavior int
}</pre>
			<p>
Declares an interpolation sampling function for an animation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Asset">type <a href="/target/common.go?s=2756:4946#L80">Asset</a></h2>
			<pre>type Asset struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">/*
        //	Contains the date and time that the parent element was created.
        //	This is only set-and-retained for imported Collada assets that provide this field,
        //	and is not otherwise used.
        Created string
        //	Contains the date and time that the parent element was last modified.
        //	This is only set-and-retained for imported Collada assets that provide this field,
        //	and is not otherwise used.
        Modified string
        //	Contains a list of words used as search criteria.
        //	This is only set-and-retained for imported Collada assets that provide this field,
        //	and is not otherwise used.
        Keywords string
        //	Contains revision information.
        //	This is only set-and-retained for imported Collada assets that provide this field,
        //	and is not otherwise used.
        Revision string
        //	Contains a description of the topical subject.
        //	This is only set-and-retained for imported Collada assets that provide this field,
        //	and is not otherwise used.
        Subject string
        //	Contains title information.
        //	This is only set-and-retained for imported Collada assets that provide this field,
        //	and is not otherwise used.
        Title string
    */</span>
    <span class="comment">//	Contains descriptive information about the coordinate system of the geometric data. All</span>
    <span class="comment">//	coordinates are right-handed by definition. Valid values are &#34;X&#34;, &#34;Y&#34; (the default), or &#34;Z&#34;.</span>
    UpAxis string
    <span class="comment">//	The unit of distance that applies to all spatial measurements within the scope of this resource.</span>
    Unit struct {
        <span class="comment">//	How many real-world meters in one distance unit as a floating-point number.</span>
        <span class="comment">//	1.0 for meter, 0.01 for centimeter, 1000 for kilometer etc.</span>
        Meter float64
        <span class="comment">//	Name of the distance unit, such as &#34;centimeter&#34;, &#34;kilometer&#34;, &#34;meter&#34;, &#34;inch&#34;.</span>
        <span class="comment">//	Default is &#34;meter&#34;.</span>
        Name string
    }
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field,</span>
    <span class="comment">//	and is not otherwise used.</span>
    Contributors []*AssetContributor
    <span class="comment">//	Provides information about the location of the visual scene in physical space.</span>
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field,</span>
    <span class="comment">//	and is not otherwise used.</span>
    Coverage *AssetGeographicLocation
}</pre>
			<p>
Resource-specific asset-management information and meta-data.
</p>


			

			

			

			
				
				<h3 id="NewAsset">func <a href="/target/common.go?s=4963:4990#L131">NewAsset</a></h3>
				<pre>func NewAsset() (me *Asset)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="AssetContributor">type <a href="/target/common.go?s=5116:5478#L138">AssetContributor</a></h2>
			<pre>type AssetContributor struct {
}</pre>
			<p>
Defines authoring information for asset management.
</p>


			

			

			

			

			
		
			
			
			<h2 id="AssetGeographicLocation">type <a href="/target/common.go?s=5705:5845#L155">AssetGeographicLocation</a></h2>
			<pre>type AssetGeographicLocation struct {
    Longitude        float64
    Latitude         float64
    Altitude         float64
    AltitudeAbsolute bool
}</pre>
			<p>
Provides information about the location of the visual scene in physical space.
ALL fields are only set-and-retained for imported Collada assets that provide those fields,
and are not otherwise written, read or used.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseDef">type <a href="/target/base.go?s=1621:1744#L43">BaseDef</a></h2>
			<pre>type BaseDef struct {
    <span class="comment">//	Syncability</span>
    BaseSync
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Asset</span>
    HasAsset
    <span class="comment">//	Extras</span>
    HasExtras
}</pre>
			<p>
Provides a common base for resource definitions.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseInst">type <a href="/target/base.go?s=1801:1988#L57">BaseInst</a></h2>
			<pre>type BaseInst struct {
    <span class="comment">//	Syncability</span>
    BaseSync
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The Id of the resource definition referenced by this instance.</span>
    DefRef RefId
}</pre>
			<p>
Provides a common base for resource instantiations.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseLib">type <a href="/target/base.go?s=2040:2121#L71">BaseLib</a></h2>
			<pre>type BaseLib struct {
    <span class="comment">//	Syncability</span>
    BaseSync
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
}</pre>
			<p>
Provides a common base for resource libraries.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseSync">type <a href="/target/base.go?s=69:461#L1">BaseSync</a></h2>
			<pre>type BaseSync struct {
    <span class="comment">//	This callback, set by the core package (or your custom package), gets called by the</span>
    <span class="comment">//	SyncChanges() method. This is the ultimate point in the sync chain where the core package</span>
    <span class="comment">//	(or your custom package) picks up the changed contents of this resource.</span>
    <span class="comment">//	If the parent is a Lib then this gets called after all its Defs have synced.</span>
    OnSync func()
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Allows for notifying outside packages of changes.
</p>


			

			

			

			

			
				
				<h3 id="BaseSync.SetDirty">func (*BaseSync) <a href="/target/base.go?s=708:738#L7">SetDirty</a></h3>
				<pre>func (me *BaseSync) SetDirty()</pre>
				<p>
You NEED to call this method if you modified this Def or Inst by setting its fields directly
(instead of using the provided SetFoo() or SetFieldX() methods) for your changes
to be picked up by the core package (or your custom package).
</p>

				
				
			
				
				<h3 id="BaseSync.SetFieldB">func (*BaseSync) <a href="/target/base.go?s=833:885#L12">SetFieldB</a></h3>
				<pre>func (me *BaseSync) SetFieldB(field *bool, val bool)</pre>
				<p>
If field does not equal val, sets field to val and calls SetDirty().
</p>

				
				
			
				
				<h3 id="BaseSync.SetFieldF">func (*BaseSync) <a href="/target/base.go?s=1017:1075#L20">SetFieldF</a></h3>
				<pre>func (me *BaseSync) SetFieldF(field *float64, val float64)</pre>
				<p>
If field does not equal val, sets field to val and calls SetDirty().
</p>

				
				
			
				
				<h3 id="BaseSync.SyncChanges">func (*BaseSync) <a href="/target/base.go?s=1479:1512#L35">SyncChanges</a></h3>
				<pre>func (me *BaseSync) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this
Def, Inst or Lib resource that need to be picked up. Call this after you have made a number
of changes to this this resource. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="Bool2">type <a href="/target/types.go?s=97:115#L1">Bool2</a></h2>
			<pre>type Bool2 [2]bool</pre>
			<p>
Contains two bool values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Bool3">type <a href="/target/types.go?s=148:166#L1">Bool3</a></h2>
			<pre>type Bool3 [3]bool</pre>
			<p>
Contains three bool values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Bool4">type <a href="/target/types.go?s=198:216#L4">Bool4</a></h2>
			<pre>type Bool4 [4]bool</pre>
			<p>
Contains four bool values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraDef">type <a href="/target/camera.gt.go?s=1278:1508#L39">CameraDef</a></h2>
			<pre>type CameraDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Describes the field of view and viewing frustum using canonical parameters.</span>
    Optics CameraOptics
    <span class="comment">//	Represents the image sensor of a camera.</span>
    Imager *CameraImager
}</pre>
			<p>
Declares a view of the visual scene hierarchy or scene graph.
</p>


			

			

			

			

			
				
				<h3 id="CameraDef.Init">func (*CameraDef) <a href="/target/camera.gt.go?s=1528:1555#L49">Init</a></h3>
				<pre>func (me *CameraDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="CameraDef.NewInst">func (*CameraDef) <a href="/target/camera.gt.go?s=2161:2210#L76">NewInst</a></h3>
				<pre>func (me *CameraDef) NewInst() (inst *CameraInst)</pre>
				<p>
Creates and returns a new CameraInst instance referencing this CameraDef definition.
</p>

				
				
			
		
			
			
			<h2 id="CameraImager">type <a href="/target/camera.gt.go?s=87:167#L1">CameraImager</a></h2>
			<pre>type CameraImager struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Techniques</span>
    HasTechniques
}</pre>
			<p>
Represents the image sensor of a camera (for example, film or CCD).
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraInst">type <a href="/target/camera.gt.go?s=1596:1862#L53">CameraInst</a></h2>
			<pre>type CameraInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *CameraDef
}</pre>
			<p>
Instantiates a camera resource.
</p>


			

			

			

			

			
				
				<h3 id="CameraInst.EnsureDef">func (*CameraInst) <a href="/target/camera.gt.go?s=2468:2512#L86">EnsureDef</a></h3>
				<pre>func (me *CameraInst) EnsureDef() *CameraDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct CameraDef
according to the current me.DefRef value (by searching AllCameraDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="CameraInst.Init">func (*CameraInst) <a href="/target/camera.gt.go?s=1882:1910#L62">Init</a></h3>
				<pre>func (me *CameraInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="CameraOptics">type <a href="/target/camera.gt.go?s=256:800#L2">CameraOptics</a></h2>
			<pre>type CameraOptics struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	Aspect ratio of the field of view.</span>
        AspectRatio *SidFloat
        <span class="comment">//	Distance to the far clipping plane.</span>
        Zfar SidFloat
        <span class="comment">//	Distance to the near clipping plane.</span>
        Znear SidFloat
        <span class="comment">//	Orthographic projection type. To use Perspective instead, also set this to nil.</span>
        Orthographic *CameraOrthographic
        <span class="comment">//	Perspective projection type. To use Orthographic instead, also set this to nil.</span>
        Perspective *CameraPerspective
    }
}</pre>
			<p>
Represents the apparatus on a camera that projects the image onto the image sensor.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraOrthographic">type <a href="/target/camera.gt.go?s=860:1008#L23">CameraOrthographic</a></h2>
			<pre>type CameraOrthographic struct {
    <span class="comment">//	Horizontal magnification of the view.</span>
    MagX *SidFloat
    <span class="comment">//	Vertical magnification of the view.</span>
    MagY *SidFloat
}</pre>
			<p>
Describes the field of view of an orthographic camera.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraPerspective">type <a href="/target/camera.gt.go?s=1066:1211#L31">CameraPerspective</a></h2>
			<pre>type CameraPerspective struct {
    <span class="comment">//	Horizontal field of view in degrees.</span>
    FovX *SidFloat
    <span class="comment">//	Vertical field of view in degrees.</span>
    FovY *SidFloat
}</pre>
			<p>
Describes the field of view of a perspective camera.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ChildNode">type <a href="/target/node.gt.go?s=68:249#L1">ChildNode</a></h2>
			<pre>type ChildNode struct {
    <span class="comment">//	If set, Inst must be nil. An inline node definition.</span>
    Def *NodeDef
    <span class="comment">//	If set, Def must be nil. Instantiates a previously defined node.</span>
    Inst *NodeInst
}</pre>
			<p>
Used to recursively define hierarchies of nodes.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ControllerDef">type <a href="/target/controller.gt.go?s=1641:2030#L50">ControllerDef</a></h2>
			<pre>type ControllerDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	If set, Skin must be nil; declares this a mesh-morphing controller that deforms meshes and blends them.</span>
    Morph *ControllerMorph
    <span class="comment">//	If set, Morph must be nil; declares this a vertex-skinning controller that transforms vertices</span>
    <span class="comment">//	based on weighted influences to produce a smoothly changing mesh.</span>
    Skin *ControllerSkin
}</pre>
			<p>
Defines generic control information for dynamic content.
</p>


			

			

			

			

			
				
				<h3 id="ControllerDef.Init">func (*ControllerDef) <a href="/target/controller.gt.go?s=2050:2081#L61">Init</a></h3>
				<pre>func (me *ControllerDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="ControllerDef.NewInst">func (*ControllerDef) <a href="/target/controller.gt.go?s=2991:3048#L93">NewInst</a></h3>
				<pre>func (me *ControllerDef) NewInst() (inst *ControllerInst)</pre>
				<p>
Creates and returns a new ControllerInst instance referencing this ControllerDef definition.
</p>

				
				
			
		
			
			
			<h2 id="ControllerInputs">type <a href="/target/controller.gt.go?s=121:197#L1">ControllerInputs</a></h2>
			<pre>type ControllerInputs struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Inputs</span>
    HasInputs
}</pre>
			<p>
Used to declare skinning joints or morph targets.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ControllerInst">type <a href="/target/controller.gt.go?s=2126:2664#L65">ControllerInst</a></h2>
			<pre>type ControllerInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *ControllerDef
    <span class="comment">//	Binds a specific material to this controller instantiation.</span>
    BindMaterial *MaterialBinding
    <span class="comment">//	Indicates where a Skin controller is to start to search for the joint nodes it needs.</span>
    <span class="comment">//	This element is meaningless for Morph controllers.</span>
    SkinSkeletons []string
}</pre>
			<p>
Instantiates a controller resource.
</p>


			

			

			

			

			
				
				<h3 id="ControllerInst.EnsureDef">func (*ControllerInst) <a href="/target/controller.gt.go?s=3318:3370#L103">EnsureDef</a></h3>
				<pre>func (me *ControllerInst) EnsureDef() *ControllerDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct ControllerDef
according to the current me.DefRef value (by searching AllControllerDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="ControllerInst.Init">func (*ControllerInst) <a href="/target/controller.gt.go?s=2684:2716#L79">Init</a></h3>
				<pre>func (me *ControllerInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="ControllerMorph">type <a href="/target/controller.gt.go?s=270:578#L6">ControllerMorph</a></h2>
			<pre>type ControllerMorph struct {
    <span class="comment">//	Sources</span>
    HasSources
    <span class="comment">//	Which blending method to use: true for relative blending, false for normalized blending.</span>
    Relative bool
    <span class="comment">//	Refers to the Geometry that describes the base mesh.</span>
    Source RefId
    <span class="comment">//	Input meshes (morph targets) to be blended.</span>
    Targets ControllerInputs
}</pre>
			<p>
Describes the data required to blend between sets of static meshes.
</p>


			

			

			

			
				
				<h3 id="NewControllerMorph">func <a href="/target/controller.gt.go?s=595:642#L18">NewControllerMorph</a></h3>
				<pre>func NewControllerMorph() (me *ControllerMorph)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="ControllerSkin">type <a href="/target/controller.gt.go?s=796:1426#L25">ControllerSkin</a></h2>
			<pre>type ControllerSkin struct {
    <span class="comment">//	Sources</span>
    HasSources
    <span class="comment">//	Provides extra information about the position and orientation of the base mesh before binding.</span>
    BindShapeMatrix unum.Mat4
    <span class="comment">//	Describes a per-vertex combination of joints and weights used in this skin.</span>
    <span class="comment">//	An index of –1 into the array of joints refers to the bind shape.</span>
    <span class="comment">//	Weights should be normalized before use.</span>
    VertexWeights IndexedInputs
    <span class="comment">//	Aggregates the per-joint information needed for this skin.</span>
    Joints ControllerInputs
    <span class="comment">//	Refers to the base mesh (a static mesh or a morphed mesh).</span>
    <span class="comment">//	This also provides the bind-shape of the skinned mesh.</span>
    Source RefId
}</pre>
			<p>
Contains vertex and primitive information sufficient to describe blend-weight skinning.
</p>


			

			

			

			
				
				<h3 id="NewControllerSkin">func <a href="/target/controller.gt.go?s=1443:1488#L42">NewControllerSkin</a></h3>
				<pre>func NewControllerSkin() (me *ControllerSkin)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="Document">type <a href="/target/doc.go?s=4838:4978#L69">Document</a></h2>
			<pre>type Document struct {
    <span class="comment">//	Asset</span>
    HasAsset
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Describes a complete, fully self-contained scene graph.</span>
    Scene *Scene
}</pre>
			<p>
Encapsulates a complete, fully self-contained scene graph.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Extra">type <a href="/target/common.go?s=5933:6129#L163">Extra</a></h2>
			<pre>type Extra struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Asset</span>
    HasAsset
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	A hint as to the type of information that this particular Extra represents.</span>
    Type string
}</pre>
			<p>
Provides arbitrary additional information about or related to its parent resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2">type <a href="/target/types.go?s=250:272#L7">Float2</a></h2>
			<pre>type Float2 [2]float64</pre>
			<p>
Contains two float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2x2">type <a href="/target/types.go?s=307:331#L10">Float2x2</a></h2>
			<pre>type Float2x2 [4]float64</pre>
			<p>
Contains four float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2x3">type <a href="/target/types.go?s=365:389#L13">Float2x3</a></h2>
			<pre>type Float2x3 [6]float64</pre>
			<p>
Contains six float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2x4">type <a href="/target/types.go?s=425:449#L16">Float2x4</a></h2>
			<pre>type Float2x4 [8]float64</pre>
			<p>
Contains eight float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float3">type <a href="/target/types.go?s=485:507#L19">Float3</a></h2>
			<pre>type Float3 [3]float64</pre>
			<p>
Contains three float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float3x2">type <a href="/target/types.go?s=541:565#L22">Float3x2</a></h2>
			<pre>type Float3x2 [6]float64</pre>
			<p>
Contains six float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float3x3">type <a href="/target/types.go?s=600:624#L25">Float3x3</a></h2>
			<pre>type Float3x3 [9]float64</pre>
			<p>
Contains nine float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float3x4">type <a href="/target/types.go?s=661:686#L28">Float3x4</a></h2>
			<pre>type Float3x4 [12]float64</pre>
			<p>
Contains twelve float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float4">type <a href="/target/types.go?s=721:743#L31">Float4</a></h2>
			<pre>type Float4 [4]float64</pre>
			<p>
Contains four float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float4x2">type <a href="/target/types.go?s=779:803#L34">Float4x2</a></h2>
			<pre>type Float4x2 [8]float64</pre>
			<p>
Contains eight float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float4x3">type <a href="/target/types.go?s=840:865#L37">Float4x3</a></h2>
			<pre>type Float4x3 [12]float64</pre>
			<p>
Contains twelve float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float4x4">type <a href="/target/types.go?s=903:928#L40">Float4x4</a></h2>
			<pre>type Float4x4 [16]float64</pre>
			<p>
Contains sixteen float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float7">type <a href="/target/types.go?s=964:986#L43">Float7</a></h2>
			<pre>type Float7 [7]float64</pre>
			<p>
Contains seven float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Formula">type <a href="/target/formula.gt.go?s=131:249#L1">Formula</a></h2>
			<pre>type Formula struct {
    <span class="comment">//	If set, Inst must be nil.</span>
    Def *FormulaDef
    <span class="comment">//	If set, Def must be nil.</span>
    Inst *FormulaInst
}</pre>
			<p>
Provides either a formula definition or a formula instance.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FormulaDef">type <a href="/target/formula.gt.go?s=370:722#L7">FormulaDef</a></h2>
			<pre>type FormulaDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	A parameter that specifies the result variable of the formula.</span>
    Target ParamOrFloat
    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	Any valid MathML (content) XML defining this formula.</span>
        MathML []*xmlx.Node
    }
}</pre>
			<p>
There are many ways to describe a formula.
Like COLLADA, the assets package uses MathML as its common-technique.
</p>


			

			

			

			

			
				
				<h3 id="FormulaDef.Init">func (*FormulaDef) <a href="/target/formula.gt.go?s=742:770#L26">Init</a></h3>
				<pre>func (me *FormulaDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="FormulaDef.NewInst">func (*FormulaDef) <a href="/target/formula.gt.go?s=1472:1523#L57">NewInst</a></h3>
				<pre>func (me *FormulaDef) NewInst() (inst *FormulaInst)</pre>
				<p>
Creates and returns a new FormulaInst instance referencing this FormulaDef definition.
</p>

				
				
			
		
			
			
			<h2 id="FormulaInst">type <a href="/target/formula.gt.go?s=840:1137#L31">FormulaInst</a></h2>
			<pre>type FormulaInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *FormulaDef
}</pre>
			<p>
Instantiates a formula resource.
</p>


			

			

			

			

			
				
				<h3 id="FormulaInst.EnsureDef">func (*FormulaInst) <a href="/target/formula.gt.go?s=1784:1830#L67">EnsureDef</a></h3>
				<pre>func (me *FormulaInst) EnsureDef() *FormulaDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct FormulaDef
according to the current me.DefRef value (by searching AllFormulaDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="FormulaInst.Init">func (*FormulaInst) <a href="/target/formula.gt.go?s=1157:1186#L42">Init</a></h3>
				<pre>func (me *FormulaInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxAnnotation">type <a href="/target/fxeffect.gt.go?s=1555:1642#L25">FxAnnotation</a></h2>
			<pre>type FxAnnotation struct {
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Annotation value.</span>
    Value interface{}
}</pre>
			<p>
Annotations communicate metadata from the Effect Runtime to the application only
and are not otherwise interpreted within the *assets* package.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxBinding">type <a href="/target/fxmaterial.gt.go?s=119:271#L1">FxBinding</a></h2>
			<pre>type FxBinding struct {
    <span class="comment">//	Which effect parameter to bind.</span>
    Semantic string
    <span class="comment">//	Refers to the value to bind to the specified semantic.</span>
    Target RefSid
}</pre>
			<p>
Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxColorOrTexture">type <a href="/target/fxeffect.gt.go?s=1732:2269#L33">FxColorOrTexture</a></h2>
			<pre>type FxColorOrTexture struct {
    <span class="comment">//	Specifies from which channel to take transparency information.</span>
    <span class="comment">//	Must be one of the FX_COLOR_TEXTURE_OPAQUE_* enumerated constants.</span>
    Opaque int
    <span class="comment">//	If set, describes he literal color of this value.</span>
    Color *ugfx.Rgba32
    <span class="comment">//	If set, refers to a previously-defined parameter in the current scope that provides</span>
    <span class="comment">//	four float values describing the literal color of this value.</span>
    ParamRef RefParam
    <span class="comment">//	If set, refers to a previously-defined FxSampler with a Type of FX_SAMPLER_TYPE_2D.</span>
    Texture *FxTexture
}</pre>
			<p>
Describes color attributes of fixed-function shaders inside FxProfileCommon effects.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate">type <a href="/target/fximage.gt.go?s=2791:3048#L53">FxCreate</a></h2>
			<pre>type FxCreate struct {
    <span class="comment">//	Specifies the length of the 2D array, 3D array or cube-map array.</span>
    ArrayLength uint64
    <span class="comment">//	Specifies an image&#39;s pixel or compression format.</span>
    <span class="comment">//	If not present, the format is assumed to be R8G8B8A8 linear.</span>
    Format *FxCreateFormat
}</pre>
			<p>
Fields shared by FxCreate2D, FxCreate3D and FxCreateCube
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2D">type <a href="/target/fximage.gt.go?s=3110:3717#L62">FxCreate2D</a></h2>
			<pre>type FxCreate2D struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate
    <span class="comment">//	Either Exact or Ratio, but not both, must be present.</span>
    Size struct {
        <span class="comment">//	Specifies that the surface should be sized to these exact dimensions.</span>
        Exact *FxCreate2DSizeExact
        <span class="comment">//	Specifies that the image size should be relative to the size of the viewport.</span>
        Ratio *FxCreate2DSizeRatio
    }
    <span class="comment">//	MIP information. Ignored if Unnormalized is true.</span>
    Mips *FxCreateMips
    <span class="comment">//	Unnormalized addressing of texels. (0-W, 0-H).</span>
    Unnormalized bool
    <span class="comment">//	Specifies which 2D image to initialize and which MIP level to initialize.</span>
    InitFrom []*FxCreateInitFrom
}</pre>
			<p>
Assists in the manual creation of a 2D FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2DSizeExact">type <a href="/target/fximage.gt.go?s=3792:3897#L81">FxCreate2DSizeExact</a></h2>
			<pre>type FxCreate2DSizeExact struct {
    <span class="comment">//	width in pixels</span>
    Width uint64
    <span class="comment">//	height in pixels</span>
    Height uint64
}</pre>
			<p>
Specifies that the surface should be sized to these exact dimensions.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2DSizeRatio">type <a href="/target/fximage.gt.go?s=4112:4292#L90">FxCreate2DSizeRatio</a></h2>
			<pre>type FxCreate2DSizeRatio struct {
    <span class="comment">//	Relative width where 1.0 represents viewport width.</span>
    Width float64
    <span class="comment">//	Relative height where 1.0 represents viewport height.</span>
    Height float64
}</pre>
			<p>
Specifies that the image size should be relative to the size of the viewport. For example, 1,1 is the
same size as the viewport; 0.5,0.5 is 1/4 the size of the viewport and half as long in either direction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate3D">type <a href="/target/fximage.gt.go?s=4354:4832#L98">FxCreate3D</a></h2>
			<pre>type FxCreate3D struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate
    <span class="comment">//	Specifies that the surface should be sized to these exact dimensions.</span>
    Size struct {
        <span class="comment">//	Width in pixels for this 3D texture.</span>
        Width uint64
        <span class="comment">//	Height in pixels for this 3D texture.</span>
        Height uint64
        <span class="comment">//	Depth in pixels for this 3D texture.</span>
        Depth uint64
    }
    <span class="comment">//	MIP information.</span>
    Mips FxCreateMips
    <span class="comment">//	Specifies which 3D image to initialize and which MIP level to initialize.</span>
    InitFrom []*FxCreate3DInitFrom
}</pre>
			<p>
Assists in the manual creation of a 3D FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate3DInitFrom">type <a href="/target/fximage.gt.go?s=4932:5121#L117">FxCreate3DInitFrom</a></h2>
			<pre>type FxCreate3DInitFrom struct {
    <span class="comment">//	Raw or RefUrl, ArrayIndex and MipIndex</span>
    FxCreateInitFrom
    <span class="comment">//	Specifies the slice (depth level) within the MIP that is to be initialized.</span>
    Depth uint64
}</pre>
			<p>
Initializes an entire 3D texture or portions of a 3D texture from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateCube">type <a href="/target/fximage.gt.go?s=5189:5652#L125">FxCreateCube</a></h2>
			<pre>type FxCreateCube struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate
    <span class="comment">//	Specifies that the cube surfaces should be sized to these exact dimensions.</span>
    Size struct {
        <span class="comment">//	Width and height are identical across all faces in a cube-map.</span>
        Width uint64
    }
    <span class="comment">//	MIP information.</span>
    Mips FxCreateMips
    <span class="comment">//	Specifies which cube image to initialize, which MIP level to initialize,</span>
    <span class="comment">//	and which cube face within the MIP that is to be initialized.</span>
    InitFrom []*FxCreateCubeInitFrom
}</pre>
			<p>
Assists in the manual creation of a cube-map FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateCubeInitFrom">type <a href="/target/fximage.gt.go?s=5748:5989#L141">FxCreateCubeInitFrom</a></h2>
			<pre>type FxCreateCubeInitFrom struct {
    <span class="comment">//	Raw or RefUrl, ArrayIndex and MipIndex</span>
    FxCreateInitFrom
    <span class="comment">//	Specifies the cube-map face within the MIP that is to be initialized.</span>
    <span class="comment">//	Must be one of the FX_CUBE_FACE_* enumerated constants.</span>
    Face int
}</pre>
			<p>
Initializes an entire cube-map or portions of a cube-map from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateFormat">type <a href="/target/fximage.gt.go?s=6069:6527#L150">FxCreateFormat</a></h2>
			<pre>type FxCreateFormat struct {
    <span class="comment">//	Contains a string representing the profile- and platform-specific texel format</span>
    <span class="comment">//	that the author would like this surface to use. If this element is not specified,</span>
    <span class="comment">//	or if it is specified but the application cannot process the specified format,</span>
    <span class="comment">//	then the application uses the Hint.</span>
    Exact string
    <span class="comment">//	If this is not set, then use a common format R8G8B8A8 with linear color gradient, not sRGB.</span>
    Hint *FxCreateFormatHint
}</pre>
			<p>
Describes the formatting or memory layout expected of an FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateFormatHint">type <a href="/target/fximage.gt.go?s=6623:7371#L161">FxCreateFormatHint</a></h2>
			<pre>type FxCreateFormatHint struct {
    <span class="comment">//	Describes the per-texel layout of the format.</span>
    <span class="comment">//	Must be one of the FX_CREATE_FORMAT_HINT_CHANNELS_* enumerated constants.</span>
    Channels int
    <span class="comment">//	Describes the range of texel channel values. Each channel represents a range of values.</span>
    <span class="comment">//	Some example ranges are signed or unsigned integers, or are within a clamped range</span>
    <span class="comment">//	such as 0.0f to 1.0f, or are a high dynamic range via floating point.</span>
    <span class="comment">//	Must be one of the FX_CREATE_FORMAT_HINT_RANGE_* enumerated constants.</span>
    Range int
    <span class="comment">//	Identifies the precision of the texel channel value.</span>
    <span class="comment">//	Must be one of the FX_CREATE_FORMAT_HINT_PRECISION_* enumerated constants.</span>
    Precision int
    <span class="comment">//	Optional custom / application-specific color-space information.</span>
    Space string
}</pre>
			<p>
Describes features and characteristics to select an appropriate format for image creation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateInitFrom">type <a href="/target/fximage.gt.go?s=7462:7688#L178">FxCreateInitFrom</a></h2>
			<pre>type FxCreateInitFrom struct {
    <span class="comment">//	Raw and RefUrl</span>
    FxInitFrom
    <span class="comment">//	Specifies which array element in the image to initialize (fill).</span>
    ArrayIndex uint64
    <span class="comment">//	Specifies which MIP level in the image to initialize.</span>
    MipIndex uint64
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateMips">type <a href="/target/fximage.gt.go?s=7709:8004#L188">FxCreateMips</a></h2>
			<pre>type FxCreateMips struct {
    <span class="comment">//	Desired number of MIP levels. Special values: 1 is &#34;no MIP levels&#34;, 0 is &#34;all MIP levels&#34;.</span>
    Levels uint64
    <span class="comment">//	If false, initializes higher MIP levels if data does not exist in a file.</span>
    <span class="comment">//	If true, no MIP levels are ever automatically initialized.</span>
    NoAutoGen bool
}</pre>
			<p>
MIP information
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxEffectDef">type <a href="/target/fxeffect.gt.go?s=13831:14041#L366">FxEffectDef</a></h2>
			<pre>type FxEffectDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	NewParams</span>
    HasFxParamDefs
    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation
    <span class="comment">//	Rendering pipeline(s).</span>
    Profiles []*FxProfile
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry or screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="FxEffectDef.Init">func (*FxEffectDef) <a href="/target/fxeffect.gt.go?s=14061:14090#L378">Init</a></h3>
				<pre>func (me *FxEffectDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="FxEffectDef.NewInst">func (*FxEffectDef) <a href="/target/fxeffect.gt.go?s=15338:15391#L422">NewInst</a></h3>
				<pre>func (me *FxEffectDef) NewInst() (inst *FxEffectInst)</pre>
				<p>
Creates and returns a new FxEffectInst instance referencing this FxEffectDef definition.
</p>

				
				
			
		
			
			
			<h2 id="FxEffectInst">type <a href="/target/fxeffect.gt.go?s=14162:14577#L383">FxEffectInst</a></h2>
			<pre>type FxEffectInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *FxEffectDef
    <span class="comment">//	Platform-specific hints of which techniques to use in this effect.</span>
    TechniqueHints []*FxEffectInstTechniqueHint
}</pre>
			<p>
Instantiates an effect resource.
</p>


			

			

			

			

			
				
				<h3 id="FxEffectInst.EnsureDef">func (*FxEffectInst) <a href="/target/fxeffect.gt.go?s=15655:15703#L432">EnsureDef</a></h3>
				<pre>func (me *FxEffectInst) EnsureDef() *FxEffectDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct FxEffectDef
according to the current me.DefRef value (by searching AllFxEffectDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="FxEffectInst.Init">func (*FxEffectInst) <a href="/target/fxeffect.gt.go?s=14597:14627#L396">Init</a></h3>
				<pre>func (me *FxEffectInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxEffectInstTechniqueHint">type <a href="/target/fxeffect.gt.go?s=14734:15079#L401">FxEffectInstTechniqueHint</a></h2>
			<pre>type FxEffectInstTechniqueHint struct {
    <span class="comment">//	Defines a string that specifies for which platform this hint is intended. Optional.</span>
    Platform string
    <span class="comment">//	A reference to the name of the platform. Required.</span>
    Ref string
    <span class="comment">//	Specifies for which API profile this hint is intended.</span>
    <span class="comment">//	Optional. If set, must be either &#34;COMMON&#34; or &#34;GLSL&#34;.</span>
    Profile string
}</pre>
			<p>
Adds a hint for a platform of which technique to use in this effect.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxImageDef">type <a href="/target/fximage.gt.go?s=9314:10484#L229">FxImageDef</a></h2>
			<pre>type FxImageDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Indicates whether this image represents a render target.</span>
    Renderable struct {
        <span class="comment">//	If true, defines the image as a render target, meaning the image can be rendered to.</span>
        Is bool
        <span class="comment">//	Indicates whether, when instantiated, the render target is to be shared among all</span>
        <span class="comment">//	instances instead of being cloned.</span>
        Shared bool
    }
    <span class="comment">//	If set, initializes a custom 2D image by specifying its size, viewport ratio, MIP levels,</span>
    <span class="comment">//	normalization, pixel format, and data sources. It also supports arrays of 2D images.</span>
    Create2D *FxCreate2D
    <span class="comment">//	If set, initializes a custom 3D image (a volumetric image) by specifying its size, MIP level,</span>
    <span class="comment">//	pixel format, and data sources. It also supports arrays of 3D images.</span>
    Create3D *FxCreate3D
    <span class="comment">//	If set, initializes the six faces of a cube by specifying its size, MIP level, pixel format,</span>
    <span class="comment">//	and data sources. It also supports arrays of images on each of the cube faces.</span>
    <span class="comment">//	It also supports arrays of cube images.</span>
    CreateCube *FxCreateCube
    <span class="comment">//	If set, initializes the image from a URL (for example, a file) or binary image data.</span>
    InitFrom *FxImageInitFrom
}</pre>
			<p>
Declares the storage for the graphical representation of an object.
</p>


			

			

			

			

			
				
				<h3 id="FxImageDef.Init">func (*FxImageDef) <a href="/target/fximage.gt.go?s=10504:10532#L257">Init</a></h3>
				<pre>func (me *FxImageDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="FxImageDef.NewInst">func (*FxImageDef) <a href="/target/fximage.gt.go?s=11448:11499#L292">NewInst</a></h3>
				<pre>func (me *FxImageDef) NewInst() (inst *FxImageInst)</pre>
				<p>
Creates and returns a new FxImageInst instance referencing this FxImageDef definition.
</p>

				
				
			
		
			
			
			<h2 id="FxImageInitFrom">type <a href="/target/fximage.gt.go?s=8095:8314#L197">FxImageInitFrom</a></h2>
			<pre>type FxImageInitFrom struct {
    <span class="comment">//	Raw and RefUrl</span>
    FxInitFrom
    <span class="comment">//	If false, initializes higher MIP levels if data does not exist in a file.</span>
    <span class="comment">//	If true, no MIP levels are ever automatically initialized.</span>
    NoAutoMip bool
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			
				
				<h3 id="NewFxImageInitFrom">func <a href="/target/fximage.gt.go?s=8331:8391#L206">NewFxImageInitFrom</a></h3>
				<pre>func NewFxImageInitFrom(refUrl string) (me *FxImageInitFrom)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxImageInst">type <a href="/target/fximage.gt.go?s=10573:10841#L261">FxImageInst</a></h2>
			<pre>type FxImageInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *FxImageDef
}</pre>
			<p>
Instantiates an image resource.
</p>


			

			

			

			

			
				
				<h3 id="FxImageInst.EnsureDef">func (*FxImageInst) <a href="/target/fximage.gt.go?s=11760:11806#L302">EnsureDef</a></h3>
				<pre>func (me *FxImageInst) EnsureDef() *FxImageDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct FxImageDef
according to the current me.DefRef value (by searching AllFxImageDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="FxImageInst.Init">func (*FxImageInst) <a href="/target/fximage.gt.go?s=10861:10890#L270">Init</a></h3>
				<pre>func (me *FxImageInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxInitFrom">type <a href="/target/fximage.gt.go?s=8539:9241#L213">FxInitFrom</a></h2>
			<pre>type FxInitFrom struct {
    <span class="comment">//	Embedded binary image data; used if RefUrl is empty and Raw.Data is not.</span>
    Raw struct {
        <span class="comment">//	Contains the embedded binary image data as a sequence of bytes. Typically contains all</span>
        <span class="comment">//	the necessary information including header info such as width and height.</span>
        Data []byte
        <span class="comment">//	Specifies which codec decodes the image&#39;s descriptions and data.</span>
        <span class="comment">//	This is usually its typical file extension, such as &#34;BMP&#34;, &#34;JPG&#34;, &#34;DDS&#34;, &#34;TGA&#34;.</span>
        Format string
    }
    <span class="comment">//	Contains the URL of a file from which to take initialization data. Assumes the characteristics of the</span>
    <span class="comment">//	file: if it is a complex format such as DDS, this might include cube maps, volumes, MIPs, and so on.</span>
    RefUrl string
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxMaterialDef">type <a href="/target/fxmaterial.gt.go?s=660:838#L12">FxMaterialDef</a></h2>
			<pre>type FxMaterialDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	The parameterized effect instantiation that fully describes and defines this material.</span>
    Effect FxEffectInst
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry or screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="FxMaterialDef.Init">func (*FxMaterialDef) <a href="/target/fxmaterial.gt.go?s=858:889#L20">Init</a></h3>
				<pre>func (me *FxMaterialDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="FxMaterialDef.NewInst">func (*FxMaterialDef) <a href="/target/fxmaterial.gt.go?s=1859:1916#L53">NewInst</a></h3>
				<pre>func (me *FxMaterialDef) NewInst() (inst *FxMaterialInst)</pre>
				<p>
Creates and returns a new FxMaterialInst instance referencing this FxMaterialDef definition.
</p>

				
				
			
		
			
			
			<h2 id="FxMaterialInst">type <a href="/target/fxmaterial.gt.go?s=932:1532#L24">FxMaterialInst</a></h2>
			<pre>type FxMaterialInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *FxMaterialDef
    <span class="comment">//	Which symbol defined from within the geometry this material binds to.</span>
    Symbol string
    <span class="comment">//	Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.</span>
    Bindings []*FxBinding
    <span class="comment">//	Binds vertex inputs to effect parameters upon instantiation.</span>
    VertexInputBindings []*FxVertexInputBinding
}</pre>
			<p>
Instantiates a material resource.
</p>


			

			

			

			

			
				
				<h3 id="FxMaterialInst.EnsureDef">func (*FxMaterialInst) <a href="/target/fxmaterial.gt.go?s=2186:2238#L63">EnsureDef</a></h3>
				<pre>func (me *FxMaterialInst) EnsureDef() *FxMaterialDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct FxMaterialDef
according to the current me.DefRef value (by searching AllFxMaterialDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="FxMaterialInst.Init">func (*FxMaterialInst) <a href="/target/fxmaterial.gt.go?s=1552:1584#L39">Init</a></h3>
				<pre>func (me *FxMaterialInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxParamDef">type <a href="/target/fxeffect.gt.go?s=2368:2656#L47">FxParamDef</a></h2>
			<pre>type FxParamDef struct {
    <span class="comment">//	Sid and Value</span>
    ParamDef
    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation
    <span class="comment">//	Specifies constant, external, or uniform parameters.</span>
    Modifier string
    <span class="comment">//	Provides metadata that describes the purpose of a parameter declaration.</span>
    Semantic string
}</pre>
			<p>
Declares a new parameter for its parent FX-related resource, and assigns it an initial value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxParamDefs">type <a href="/target/fxeffect.gt.go?s=2737:2776#L59">FxParamDefs</a></h2>
			<pre>type FxParamDefs map[string]*FxParamDef</pre>
			<p>
A hash-table containing parameter declarations of this FX-related resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPass">type <a href="/target/fxeffect.gt.go?s=2890:3300#L63">FxPass</a></h2>
			<pre>type FxPass struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation
    <span class="comment">//	Contains all rendering states to set up for this pass.</span>
    States map[string]*FxPassState
    <span class="comment">//	Links multiple shaders together to produce a pipeline for geometry processing.</span>
    Program *FxPassProgram
    <span class="comment">//	Contains evaluation elements for this rendering pass.</span>
    Evaluate *FxPassEvaluation
}</pre>
			<p>
Provides a static declaration of all the render states, shaders, and settings
for one rendering pipeline.
</p>


			

			

			

			
				
				<h3 id="NewFxPass">func <a href="/target/fxeffect.gt.go?s=3317:3346#L79">NewFxPass</a></h3>
				<pre>func NewFxPass() (me *FxPass)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxPassEvaluation">type <a href="/target/fxeffect.gt.go?s=3463:4511#L85">FxPassEvaluation</a></h2>
			<pre>type FxPassEvaluation struct {
    <span class="comment">//	Instructs the FX Runtime what kind of geometry to submit.</span>
    Draw string
    <span class="comment">//	Color-information render target</span>
    Color struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearColor
        <span class="comment">//	Specifies which FxImageDef will receive the color information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
    <span class="comment">//	Depth-information render target</span>
    Depth struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearDepth
        <span class="comment">//	Specifies which FxImageDef will receive the depth information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
    <span class="comment">//	Stencil-information render target</span>
    Stencil struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearStencil
        <span class="comment">//	Specifies which FxImageDef will receive the stencil information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
}</pre>
			<p>
Contains evaluation elements for a rendering pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearColor">type <a href="/target/fxeffect.gt.go?s=4616:4788#L112">FxPassEvaluationClearColor</a></h2>
			<pre>type FxPassEvaluationClearColor struct {
    <span class="comment">//	Default clear-color value</span>
    ugfx.Rgba32
    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a color-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearDepth">type <a href="/target/fxeffect.gt.go?s=4893:5063#L120">FxPassEvaluationClearDepth</a></h2>
			<pre>type FxPassEvaluationClearDepth struct {
    <span class="comment">//	Default clear-depth value</span>
    F float64
    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a depth-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearStencil">type <a href="/target/fxeffect.gt.go?s=5170:5341#L128">FxPassEvaluationClearStencil</a></h2>
			<pre>type FxPassEvaluationClearStencil struct {
    <span class="comment">//	Default clear-stencil value</span>
    B byte
    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a stencil-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationTarget">type <a href="/target/fxeffect.gt.go?s=5429:6134#L136">FxPassEvaluationTarget</a></h2>
			<pre>type FxPassEvaluationTarget struct {
    <span class="comment">//	Indexes one of the Multiple Render Targets.</span>
    Index uint64
    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a layer of a 3D texture.</span>
    Slice uint64
    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a single MIP-map level.</span>
    Mip uint64
    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a unique cube face.</span>
    <span class="comment">//	Must be one of the FX_CUBE_FACE_* enumerated constants.</span>
    CubeFace int
    <span class="comment">//	If set, Image is ignored; this render target references a sampler parameter to determine which image to use.</span>
    Sampler RefParam
    <span class="comment">//	If set (and Sampler is empty), this render target directly instantiates a renderable image.</span>
    Image *FxImageInst
}</pre>
			<p>
Specifies which FxImageDef will receive the information from the output of a pass.
</p>


			

			

			

			
				
				<h3 id="NewFxPassEvaluationTarget">func <a href="/target/fxeffect.gt.go?s=6151:6212#L153">NewFxPassEvaluationTarget</a></h3>
				<pre>func NewFxPassEvaluationTarget() (me *FxPassEvaluationTarget)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxPassProgram">type <a href="/target/fxeffect.gt.go?s=6348:6715#L159">FxPassProgram</a></h2>
			<pre>type FxPassProgram struct {
    <span class="comment">//	Information for binding the shader variables to effect parameters.</span>
    BindAttributes []*FxPassProgramBindAttribute
    <span class="comment">//	Binds a uniform shader variable to a parameter or a value.</span>
    BindUniforms []*FxPassProgramBindUniform
    <span class="comment">//	Setup and compilation information for shaders such as vertex and pixel shaders.</span>
    Shaders []*FxPassProgramShader
}</pre>
			<p>
Links multiple shaders together to produce a pipeline for geometry processing.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramBindAttribute">type <a href="/target/fxeffect.gt.go?s=6776:7080#L169">FxPassProgramBindAttribute</a></h2>
			<pre>type FxPassProgramBindAttribute struct {
    <span class="comment">//	The identifier for a vertex attribute variable in the shader</span>
    <span class="comment">//	(a formal function parameter or in-scope global).</span>
    Symbol string
    <span class="comment">//	Contains an alternative name to the attribute variable</span>
    <span class="comment">//	for semantic binding to geometry vertex inputs.</span>
    Semantic string
}</pre>
			<p>
Binds semantics to vertex attribute inputs of a shader.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramBindUniform">type <a href="/target/fxeffect.gt.go?s=7185:7575#L179">FxPassProgramBindUniform</a></h2>
			<pre>type FxPassProgramBindUniform struct {
    <span class="comment">//	The identifier for a uniform input parameter to the shader</span>
    <span class="comment">//	(a formal function parameter or in-scope global) that will be bound to an external resource.</span>
    Symbol string
    <span class="comment">//	If set, refers to a previously defined parameter providing the uniform value to be bound.</span>
    ParamRef RefParam
    <span class="comment">//	If set, the uniform value to be bound.</span>
    Value interface{}
}</pre>
			<p>
Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramShader">type <a href="/target/fxeffect.gt.go?s=7662:7995#L190">FxPassProgramShader</a></h2>
			<pre>type FxPassProgramShader struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	In which pipeline stage this programmable shader is designed to execute.</span>
    <span class="comment">//	Must be one of the FX_PASS_PROGRAM_SHADER_STAGE_* enumerated constants.</span>
    Stage int
    <span class="comment">//	Concatenates the source code for the shader from one or more sources.</span>
    Sources []FxPassProgramShaderSources
}</pre>
			<p>
Declares and prepares a shader for execution in the rendering pipeline of a pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramShaderSources">type <a href="/target/fxeffect.gt.go?s=8045:8210#L201">FxPassProgramShaderSources</a></h2>
			<pre>type FxPassProgramShaderSources struct {
    <span class="comment">//	If true, S is an import reference; otherwise, S is code.</span>
    IsImportRef bool
    <span class="comment">//	The code or import reference.</span>
    S string
}</pre>
			<p>
Contains either code or an import reference.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassState">type <a href="/target/fxeffect.gt.go?s=8256:8559#L209">FxPassState</a></h2>
			<pre>type FxPassState struct {
    <span class="comment">//	If set, Value is ignored; refers to a previously defined parameter providing the value for this rendering state.</span>
    Param RefParam
    <span class="comment">//	If set (and Param is empty), the value for this rendering state.</span>
    Value string
    <span class="comment">//	State-specific optional index attribute.</span>
    Index float64
}</pre>
			<p>
Represents a rendering state for a pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxProfile">type <a href="/target/fxeffect.gt.go?s=8624:8982#L219">FxProfile</a></h2>
			<pre>type FxProfile struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Asset</span>
    HasAsset
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	NewParams</span>
    HasFxParamDefs
    <span class="comment">//	If set, Glsl must be nil, and this FxProfile represents a common, fixed-function shader pipeline.</span>
    Common *FxProfileCommon
    <span class="comment">//	If set, Common must be nil, and this FxProfile represents an OpenGL Shading Language pipeline.</span>
    Glsl *FxProfileGlsl
}</pre>
			<p>
An FX profile represents a shader-based rendering pipeline.
</p>


			

			

			

			
				
				<h3 id="NewProfile">func <a href="/target/fxeffect.gt.go?s=8984:9017#L234">NewProfile</a></h3>
				<pre>func NewProfile() (me *FxProfile)</pre>
				
				
			

			
		
			
			
			<h2 id="FxProfileCommon">type <a href="/target/fxeffect.gt.go?s=9181:9290#L241">FxProfileCommon</a></h2>
			<pre>type FxProfileCommon struct {
    <span class="comment">//	Declares the only technique for this effect.</span>
    Technique FxTechniqueCommon
}</pre>
			<p>
This FX profile provides platform-independent declarations for the common, fixed-function shader.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxProfileGlsl">type <a href="/target/fxeffect.gt.go?s=9384:9730#L247">FxProfileGlsl</a></h2>
			<pre>type FxProfileGlsl struct {
    <span class="comment">//	The type of platform. This is a vendor-defined character string that</span>
    <span class="comment">//	indicates the platform or capability target for the technique. Defaults to &#34;PC&#34;.</span>
    Platform string
    <span class="comment">//	GLSL shader sources</span>
    CodesIncludes []FxProfileGlslCodeInclude
    <span class="comment">//	Declares the techniques for this effect.</span>
    Techniques []*FxTechniqueGlsl
}</pre>
			<p>
This FX profile provides platform-specific declarations for the OpenGL Shading Language.
</p>


			

			

			

			
				
				<h3 id="NewFxProfileGlsl">func <a href="/target/fxeffect.gt.go?s=9747:9790#L258">NewFxProfileGlsl</a></h3>
				<pre>func NewFxProfileGlsl() (me *FxProfileGlsl)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxProfileGlslCodeInclude">type <a href="/target/fxeffect.gt.go?s=9864:10054#L264">FxProfileGlslCodeInclude</a></h2>
			<pre>type FxProfileGlslCodeInclude struct {
    <span class="comment">//	Source code or include reference</span>
    SidString
    <span class="comment">//	Indicates whether SidString is an import reference (true) or source code (false).</span>
    IsInclude bool
}</pre>
			<p>
GLSL shader sources
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxSampler">type <a href="/target/fxsampler.go?s=2773:3081#L60">FxSampler</a></h2>
			<pre>type FxSampler struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Filtering, Wrapping</span>
    FxSamplerStates
    <span class="comment">//	If set, instantiates a default image from which the sampler is to consume.</span>
    Image *FxImageInst
    <span class="comment">//	Indicates the type of this texture sampler.</span>
    <span class="comment">//	Must be one of the FX_SAMPLER_TYPE_* enumerated constants.</span>
    Type int
}</pre>
			<p>
Declares a texture sampler.
</p>


			

			

			

			
				
				<h3 id="NewFxSampler">func <a href="/target/fxsampler.go?s=3098:3133#L73">NewFxSampler</a></h3>
				<pre>func NewFxSampler() (me *FxSampler)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxSamplerFiltering">type <a href="/target/fxsampler.go?s=3468:4189#L87">FxSamplerFiltering</a></h2>
			<pre>type FxSamplerFiltering struct {
    <span class="comment">//	Magnification filter. Must be one of the FX_SAMPLER_FILTER_* enumerated constants.</span>
    FilterMag int
    <span class="comment">//	Minification filter. Must be one of the FX_SAMPLER_FILTER_* enumerated constants.</span>
    FilterMin int
    <span class="comment">//	Mip-mapping filter. Must be one of the FX_SAMPLER_FILTER_* enumerated constants.</span>
    FilterMip int
    <span class="comment">//	The number of samples that can be used durring anisotropic filtering.</span>
    MaxAnisotropy uint32
    <span class="comment">//	The maximum number of progressive levels that the sampler will evaluate.</span>
    MipMaxLevel uint8
    <span class="comment">//	The minimum progressive levels to begin to evaluate.</span>
    MipMinLevel uint8
    <span class="comment">//	Biases the gamma (level of detail parameter) used by the sampler to evaluate the MIPmap chain.</span>
    MipBias float64
}</pre>
			<p>
Controls texture minification, magnification and MIP-mapping.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxSamplerImage">type <a href="/target/fxsampler.go?s=3328:3401#L81">FxSamplerImage</a></h2>
			<pre>type FxSamplerImage struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    FxImageInst
}</pre>
			<p>
Instantiates an image targeted for samplers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxSamplerStates">type <a href="/target/fxsampler.go?s=4260:4484#L105">FxSamplerStates</a></h2>
			<pre>type FxSamplerStates struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Controls texture minification, magnification and MIP-mapping.</span>
    Filtering *FxSamplerFiltering
    <span class="comment">//	Controls texture repeating and clamping.</span>
    Wrapping *FxSamplerWrapping
}</pre>
			<p>
Allows users to modify an effect&#39;s sampler state from a material.
</p>


			

			

			

			
				
				<h3 id="NewFxSamplerStates">func <a href="/target/fxsampler.go?s=4501:4548#L115">NewFxSamplerStates</a></h3>
				<pre>func NewFxSamplerStates() (me *FxSamplerStates)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxSamplerWrapping">type <a href="/target/fxsampler.go?s=4703:5307#L121">FxSamplerWrapping</a></h2>
			<pre>type FxSamplerWrapping struct {
    <span class="comment">//	When reading past the edge of the texture address space</span>
    <span class="comment">//	based on the wrap modes involving clamps, this color takes over.</span>
    BorderColor ugfx.Rgba32
    <span class="comment">//	Controls texture repeating and clamping of the S coordinate.</span>
    <span class="comment">//	Must be one of the FX_SAMPLER_WRAP_* enumerated constants.</span>
    WrapS int
    <span class="comment">//	Controls texture repeating and clamping of the T coordinate.</span>
    <span class="comment">//	Must be one of the FX_SAMPLER_WRAP_* enumerated constants.</span>
    WrapT int
    <span class="comment">//	Controls texture repeating and clamping of the P coordinate.</span>
    <span class="comment">//	Must be one of the FX_SAMPLER_WRAP_* enumerated constants.</span>
    WrapP int
}</pre>
			<p>
Controls texture repeating and clamping.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechnique">type <a href="/target/fxeffect.gt.go?s=10195:10294#L273">FxTechnique</a></h2>
			<pre>type FxTechnique struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Asset</span>
    HasAsset
    <span class="comment">//	Extras</span>
    HasExtras
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes
necessary for rendering this effect using one method.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommon">type <a href="/target/fxeffect.gt.go?s=10444:10925#L286">FxTechniqueCommon</a></h2>
			<pre>type FxTechniqueCommon struct {
    <span class="comment">//	Id, Sid, Asset, Extras</span>
    FxTechnique
    <span class="comment">//	Produces a shaded surface with a Blinn BRDF approximation.</span>
    Blinn *FxTechniqueCommonBlinn
    <span class="comment">//	Produces a constantly shaded surface that is independent of lighting.</span>
    Constant *FxTechniqueCommonConstant
    <span class="comment">//	Produces a constantly shaded surface that is independent of lighting.</span>
    Lambert *FxTechniqueCommonLambert
    <span class="comment">//	Produces a shaded surface with a Phong BRDF approximation.</span>
    Phong *FxTechniqueCommonPhong
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes
necessary for rendering this effect within an FxProfileCommon.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommonBlinn">type <a href="/target/fxeffect.gt.go?s=10989:11373#L300">FxTechniqueCommonBlinn</a></h2>
			<pre>type FxTechniqueCommonBlinn struct {
    <span class="comment">//	Ambient, Diffuse, Emission, Reflective, Reflectivity, Transparent, Transparency, IndexOfRefraction</span>
    FxTechniqueCommonLambert
    <span class="comment">//	Declares the color of light specularly reflected from the surface of this object.</span>
    Specular *FxColorOrTexture
    <span class="comment">//	Declares the specularity or roughness of the specular reflection lobe.</span>
    Shininess *ParamOrSidFloat
}</pre>
			<p>
Produces a shaded surface with a Blinn BRDF approximation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommonConstant">type <a href="/target/fxeffect.gt.go?s=11448:12199#L310">FxTechniqueCommonConstant</a></h2>
			<pre>type FxTechniqueCommonConstant struct {
    <span class="comment">//	Declares the amount of light emitted from the surface of this object</span>
    Emission *FxColorOrTexture
    <span class="comment">//	Declares the color of a perfect mirror reflection.</span>
    Reflective *FxColorOrTexture
    <span class="comment">//	Declares the amount of perfect mirror reflection to be added to the reflected light</span>
    <span class="comment">//	as a value between 0.0 and 1.0.</span>
    Reflectivity *ParamOrSidFloat
    <span class="comment">//	Declares the color of perfectly refracted light.</span>
    Transparent *FxColorOrTexture
    <span class="comment">//	Declares the amount of perfectly refracted light added to the reflected color</span>
    <span class="comment">//	as a scalar value between 0.0 and 1.0.</span>
    Transparency *ParamOrSidFloat
    <span class="comment">//	Declares the index of refraction for perfectly refracted light as a single scalar index.</span>
    IndexOfRefraction *ParamOrSidFloat
}</pre>
			<p>
Produces a constantly shaded surface that is independent of lighting.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommonLambert">type <a href="/target/fxeffect.gt.go?s=12274:12650#L328">FxTechniqueCommonLambert</a></h2>
			<pre>type FxTechniqueCommonLambert struct {
    <span class="comment">//	Emission, Reflective, Reflectivity, Transparent, Transparency, IndexOfRefraction</span>
    FxTechniqueCommonConstant
    <span class="comment">//	Declares the amount of ambient light reflected from the surface of this object.</span>
    Ambient *FxColorOrTexture
    <span class="comment">//	Declares the amount of light diffusely reflected from the surface of this object.</span>
    Diffuse *FxColorOrTexture
}</pre>
			<p>
Produces a constantly shaded surface that is independent of lighting.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommonPhong">type <a href="/target/fxeffect.gt.go?s=12714:12900#L338">FxTechniqueCommonPhong</a></h2>
			<pre>type FxTechniqueCommonPhong struct {
    <span class="comment">//	Specular, Shininess, Ambient, Diffuse, Emission, Reflective, Reflectivity, Transparent, Transparency, IndexOfRefraction</span>
    FxTechniqueCommonBlinn
}</pre>
			<p>
Produces a shaded surface with a Phong BRDF approximation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueGlsl">type <a href="/target/fxeffect.gt.go?s=13048:13303#L345">FxTechniqueGlsl</a></h2>
			<pre>type FxTechniqueGlsl struct {
    <span class="comment">//	Id, Sid, Asset, Extras</span>
    FxTechnique
    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation
    <span class="comment">//	Static declarations of all the render states, shaders, and settings for the rendering pipeline.</span>
    Passes []*FxPass
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes
necessary for rendering this effect within an FxProfileGlsl.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTexture">type <a href="/target/fxeffect.gt.go?s=13407:13722#L355">FxTexture</a></h2>
			<pre>type FxTexture struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	References a previously defined FxSampler of type FX_SAMPLER_TYPE_2D.</span>
    Sampler2D RefParam
    <span class="comment">//	A semantic token, which will be referenced within FxMaterialBinding</span>
    <span class="comment">//	to bind an array of texture-coordinates from a geometry instance to the sampler.</span>
    TexCoord string
}</pre>
			<p>
Used in FxColorOrTexture instances that refer to a texture image instead of a literal color value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxVertexInputBinding">type <a href="/target/fxmaterial.gt.go?s=349:551#L2">FxVertexInputBinding</a></h2>
			<pre>type FxVertexInputBinding struct {
    <span class="comment">//	Which effect parameter to bind.</span>
    Semantic string
    <span class="comment">//	Which input semantic to bind.</span>
    InputSemantic string
    <span class="comment">//	Which input set to bind. Optional.</span>
    InputSet *uint64
}</pre>
			<p>
Binds geometry vertex inputs to effect vertex inputs upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrep">type <a href="/target/geometrybrep.go?s=126:1099#L1">GeometryBrep</a></h2>
			<pre>type GeometryBrep struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Sources</span>
    HasSources
    <span class="comment">//	Describes all vertices of the B-rep.</span>
    <span class="comment">//	Vertices are the base topological entity for all B-rep structures.</span>
    Vertices GeometryVertices
    <span class="comment">//	Contains all curves used in this B-rep. Required if Edges are present.</span>
    Curves *GeometryBrepCurves
    <span class="comment">//	Contains all 2D curves used in this B-rep.</span>
    <span class="comment">//	This includes surfaces that describe the kind of the face. Required if Faces are present.</span>
    SurfaceCurves *GeometryBrepSurfaceCurves
    <span class="comment">//	Contains all surfaces used in this B-rep.</span>
    Surfaces *GeometryBrepSurfaces
    <span class="comment">//	Describes all edges of the B-rep.</span>
    Edges *GeometryBrepEdges
    <span class="comment">//	Describes all wires of the B-rep.</span>
    Wires *GeometryBrepWires
    <span class="comment">//	Describes all faces of the B-rep.</span>
    Faces *GeometryBrepFaces
    <span class="comment">//	Describes all pcurves of the B-rep.</span>
    Pcurves *GeometryBrepPcurves
    <span class="comment">//	Describes all shells of the B-rep.</span>
    Shells *GeometryBrepShells
    <span class="comment">//	Describes all solids of the B-rep.</span>
    Solids *GeometryBrepSolids
}</pre>
			<p>
Describes a boundary representation (B-rep) structure.
</p>


			

			

			

			
				
				<h3 id="NewGeometryBrep">func <a href="/target/geometrybrep.go?s=1116:1157#L28">NewGeometryBrep</a></h3>
				<pre>func NewGeometryBrep() (me *GeometryBrep)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryBrepBox">type <a href="/target/geometrybrep.go?s=1291:1461#L35">GeometryBrepBox</a></h2>
			<pre>type GeometryBrepBox struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Represents the extents of the box. The dimensions of the box are double the half-extents.</span>
    HalfExtents unum.Vec3
}</pre>
			<p>
Declares an axis-aligned box that is centered around its local origin.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCapsule">type <a href="/target/geometrybrep.go?s=1509:1763#L43">GeometryBrepCapsule</a></h2>
			<pre>type GeometryBrepCapsule struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The length of the line segment connecting the centers of the capping hemispheres (ellipsoids).</span>
    Height float64
    <span class="comment">//	The x, y, and z radii of the capsule (it may be elliptical).</span>
    Radii unum.Vec3
}</pre>
			<p>
A capsule is a cylinder with rounded caps.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCircle">type <a href="/target/geometrybrep.go?s=1800:1902#L53">GeometryBrepCircle</a></h2>
			<pre>type GeometryBrepCircle struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The radius of the circle.</span>
    Radius float64
}</pre>
			<p>
Describes a circle in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCone">type <a href="/target/geometrybrep.go?s=1985:2130#L61">GeometryBrepCone</a></h2>
			<pre>type GeometryBrepCone struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The conical surface semi-angle.</span>
    Angle float64
    <span class="comment">//	Radius of the cone.</span>
    Radius float64
}</pre>
			<p>
Describes a conical surface. A cone is defined by the half-angle at its apex.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCurve">type <a href="/target/geometrybrep.go?s=2163:2864#L71">GeometryBrepCurve</a></h2>
			<pre>type GeometryBrepCurve struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Optional positioning of this surface to its correct location.</span>
    Location GeometryPositioning
    <span class="comment">//	The curve element. At least and at most one of these fields must be set (non-nil).</span>
    Element struct {
        <span class="comment">//	If set, curve element is a line.</span>
        Line *GeometryBrepLine
        <span class="comment">//	If set, curve element is a circle.</span>
        Circle *GeometryBrepCircle
        <span class="comment">//	If set, curve element is an ellipse.</span>
        Ellipse *GeometryBrepEllipse
        <span class="comment">//	If set, curve element is a parabola.</span>
        Parabola *GeometryBrepParabola
        <span class="comment">//	If set, curve element is a hyperbola.</span>
        Hyperbola *GeometryBrepHyperbola
        <span class="comment">//	If set, curve element is a NURBS curve.</span>
        Nurbs *GeometryBrepNurbs
    }
}</pre>
			<p>
Describes a specific curve.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCurves">type <a href="/target/geometrybrep.go?s=2934:3099#L96">GeometryBrepCurves</a></h2>
			<pre>type GeometryBrepCurves struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	A container for all 3D curves used by the edges of the parent B-rep structure.</span>
    All []*GeometryBrepCurve
}</pre>
			<p>
Contains all curves that are used in the parent B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCylinder">type <a href="/target/geometrybrep.go?s=3234:3408#L105">GeometryBrepCylinder</a></h2>
			<pre>type GeometryBrepCylinder struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The first value is the major radius, the second is the minor radius (cylinder may be elliptical).</span>
    Radii Float2
}</pre>
			<p>
Describes an unlimited cylindrical surface.
An unlimited cylinder has a radius but is assumed to extend to an infinite length.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepEdges">type <a href="/target/geometrybrep.go?s=3455:3879#L113">GeometryBrepEdges</a></h2>
			<pre>type GeometryBrepEdges struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Four inputs are needed to define an edge:</span>
    <span class="comment">//	One with Semantic &#34;CURVE&#34; to reference the corresponding geometric element for the edge.</span>
    <span class="comment">//	Two with Semantic &#34;VERTEX&#34; to reference the two vertices that limit each edge.</span>
    <span class="comment">//	One with Semantic &#34;PARAM&#34; to set the parametric values (start and end parameters) of the curve.</span>
    IndexedInputs
}</pre>
			<p>
Describes the edges of a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepEllipse">type <a href="/target/geometrybrep.go?s=3918:4062#L128">GeometryBrepEllipse</a></h2>
			<pre>type GeometryBrepEllipse struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The first value is the major radius, the second is the minor radius.</span>
    Radii Float2
}</pre>
			<p>
Describes an ellipse in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepFaces">type <a href="/target/geometrybrep.go?s=4109:4515#L136">GeometryBrepFaces</a></h2>
			<pre>type GeometryBrepFaces struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	There must be at least three inputs:</span>
    <span class="comment">//	One with Semantic &#34;SURFACE&#34; to reference the corresponding geometric element for the face.</span>
    <span class="comment">//	One with Semantic &#34;WIRE&#34; to reference the wires for each face.</span>
    <span class="comment">//	One with Semantic &#34;ORIENTATION&#34; defining the orientation of the referenced wire within the face.</span>
    IndexedInputs
}</pre>
			<p>
Describes the faces of a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepHyperbola">type <a href="/target/geometrybrep.go?s=4555:4701#L151">GeometryBrepHyperbola</a></h2>
			<pre>type GeometryBrepHyperbola struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The first value is the major radius, the second is the minor radius.</span>
    Radii Float2
}</pre>
			<p>
Describes a hyperbola in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepLine">type <a href="/target/geometrybrep.go?s=4743:4912#L159">GeometryBrepLine</a></h2>
			<pre>type GeometryBrepLine struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The origin of the line.</span>
    Origin unum.Vec3
    <span class="comment">//	The direction of the line as a unit vector.</span>
    Direction unum.Vec3
}</pre>
			<p>
Describes a single line in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepNurbs">type <a href="/target/geometrybrep.go?s=4954:5243#L169">GeometryBrepNurbs</a></h2>
			<pre>type GeometryBrepNurbs struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Sources</span>
    HasSources
    <span class="comment">//	Specifies the degree of the NURBS curve.</span>
    Degree uint64
    <span class="comment">//	Specifies whether this NURBS curve is closed.</span>
    Closed bool
    <span class="comment">//	Control vertices for curve interpolation.</span>
    ControlVertices GeometryControlVertices
}</pre>
			<p>
Describes a NURBS curve in 3D space.
</p>


			

			

			

			
				
				<h3 id="NewGeometryBrepNurbs">func <a href="/target/geometrybrep.go?s=5260:5311#L183">NewGeometryBrepNurbs</a></h3>
				<pre>func NewGeometryBrepNurbs() (me *GeometryBrepNurbs)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryBrepNurbsSurface">type <a href="/target/geometrybrep.go?s=5418:5819#L190">GeometryBrepNurbsSurface</a></h2>
			<pre>type GeometryBrepNurbsSurface struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Sources</span>
    HasSources
    <span class="comment">//	The u and v directions for the NURBS curve.</span>
    U, V struct {
        <span class="comment">//	Specifies the degree of the NURBS curve for this direction.</span>
        Degree uint64
        <span class="comment">//	Specifies whether a NURBS curve is closed for this direction.</span>
        Closed bool
    }
    <span class="comment">//	Control vertices for curve interpolation.</span>
    ControlVertices GeometryControlVertices
}</pre>
			<p>
Describes a NURBS surface in 3D space.
</p>


			

			

			

			
				
				<h3 id="NewGeometryBrepNurbsSurface">func <a href="/target/geometrybrep.go?s=5836:5901#L207">NewGeometryBrepNurbsSurface</a></h3>
				<pre>func NewGeometryBrepNurbsSurface() (me *GeometryBrepNurbsSurface)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryBrepOrientation">type <a href="/target/geometrybrep.go?s=6022:6155#L214">GeometryBrepOrientation</a></h2>
			<pre>type GeometryBrepOrientation struct {
    <span class="comment">//	The axis of rotation.</span>
    Axis unum.Vec3
    <span class="comment">//	The rotational angle in degrees.</span>
    Angle float64
}</pre>
			<p>
Describes the orientation of an object frame.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepParabola">type <a href="/target/geometrybrep.go?s=6194:6333#L222">GeometryBrepParabola</a></h2>
			<pre>type GeometryBrepParabola struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The distance between the parabola&#39;s focus and its apex.</span>
    FocalLength float64
}</pre>
			<p>
Describes a parabola in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepPcurves">type <a href="/target/geometrybrep.go?s=6405:6723#L230">GeometryBrepPcurves</a></h2>
			<pre>type GeometryBrepPcurves struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	There must be at least three inputs:</span>
    <span class="comment">//	One with Semantic &#34;CURVE2D&#34; referencing a pcurve.</span>
    <span class="comment">//	One with Semantic &#34;FACE&#34; and one with Semantic &#34;EDGE&#34;</span>
    <span class="comment">//	to specify the connection between the edge and the face.</span>
    IndexedInputs
}</pre>
			<p>
Specifies how an edge is represented in a face&#39;s parametric space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepPlane">type <a href="/target/geometrybrep.go?s=6755:6900#L245">GeometryBrepPlane</a></h2>
			<pre>type GeometryBrepPlane struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The four coefficients for the plane&#39;s equation: Ax + By + Cz + D = 0</span>
    Equation Float4
}</pre>
			<p>
Defines an infinite plane.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepShells">type <a href="/target/geometrybrep.go?s=7028:7340#L254">GeometryBrepShells</a></h2>
			<pre>type GeometryBrepShells struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	There must be at least two inputs:</span>
    <span class="comment">//	One with Semantic &#34;FACE&#34; to reference the faces for each shell.</span>
    <span class="comment">//	One with Semantic &#34;ORIENTATION&#34; defining the orientation of the referenced face within the shell.</span>
    IndexedInputs
}</pre>
			<p>
Describes the shells of a B-rep structure.
A shell is the union of one or more faces. A closed shell can limit a solid.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSolids">type <a href="/target/geometrybrep.go?s=7388:7703#L268">GeometryBrepSolids</a></h2>
			<pre>type GeometryBrepSolids struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	There must be at least two inputs:</span>
    <span class="comment">//	One with Semantic &#34;SHELL&#34; to reference the shells for each solid.</span>
    <span class="comment">//	One with Semantic &#34;ORIENTATION&#34; defining the orientation of the referenced shell within the solid.</span>
    IndexedInputs
}</pre>
			<p>
Describes the solids of a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSphere">type <a href="/target/geometrybrep.go?s=7785:7888#L282">GeometryBrepSphere</a></h2>
			<pre>type GeometryBrepSphere struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The radius of this sphere.</span>
    Radius float64
}</pre>
			<p>
Describes a perfectly round sphere that is centered around its local origin.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurface">type <a href="/target/geometrybrep.go?s=7923:8720#L290">GeometryBrepSurface</a></h2>
			<pre>type GeometryBrepSurface struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Optional positioning of this surface to its correct location.</span>
    Location GeometryPositioning
    <span class="comment">//	The surface element. At least and at most one of these fields must be set (non-nil).</span>
    Element struct {
        <span class="comment">//	Surface is described by a cone.</span>
        Cone *GeometryBrepCone
        <span class="comment">//	Surface is described by a plane.</span>
        Plane *GeometryBrepPlane
        <span class="comment">//	Surface is described by a cylinder.</span>
        Cylinder *GeometryBrepCylinder
        <span class="comment">//	Surface is described by a NURBS surface.</span>
        NurbsSurface *GeometryBrepNurbsSurface
        <span class="comment">//	Surface is described by a sphere.</span>
        Sphere *GeometryBrepSphere
        <span class="comment">//	Surface is described by a torus.</span>
        Torus *GeometryBrepTorus
        <span class="comment">//	Surface is described by an extruded or revolved curve.</span>
        SweptSurface *GeometryBrepSweptSurface
    }
}</pre>
			<p>
Describes a specific surface.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurfaceCurves">type <a href="/target/geometrybrep.go?s=8802:8972#L317">GeometryBrepSurfaceCurves</a></h2>
			<pre>type GeometryBrepSurfaceCurves struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Pcurves are curves in the parametric space of the surface on which they lie.</span>
    All []*GeometryBrepCurve
}</pre>
			<p>
Contains all parametric curves (pcurves) that are used in a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurfaces">type <a href="/target/geometrybrep.go?s=9035:9203#L325">GeometryBrepSurfaces</a></h2>
			<pre>type GeometryBrepSurfaces struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	A container for all surfaces used by the faces of the parent B-rep structure.</span>
    All []*GeometryBrepSurface
}</pre>
			<p>
Contains all surfaces that are used in a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSweptSurface">type <a href="/target/geometrybrep.go?s=9263:9819#L333">GeometryBrepSweptSurface</a></h2>
			<pre>type GeometryBrepSweptSurface struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Describes the base curve being extruded or revolved.</span>
    Curve *GeometryBrepCurve
    <span class="comment">//	If Direction is set (non-nil), Revolution is ignored and this surface extrudes Curve.</span>
    Extrusion struct {
        <span class="comment">//	The direction of this curve extrusion.</span>
        Direction *unum.Vec3
    }
    <span class="comment">//	Only used if Extrusion.Direction is nil; then this surface revolves Curve.</span>
    Revolution struct {
        <span class="comment">//	The origin of the axis for revolution.</span>
        Origin *unum.Vec3
        <span class="comment">//	The axis&#39; direction for revolution.</span>
        Direction *unum.Vec3
    }
}</pre>
			<p>
Describes a surface by extruding or revolving a curve.
</p>


			

			

			

			

			
				
				<h3 id="GeometryBrepSweptSurface.IsExtrusion">func (*GeometryBrepSweptSurface) <a href="/target/geometrybrep.go?s=9888:9942#L353">IsExtrusion</a></h3>
				<pre>func (me *GeometryBrepSweptSurface) IsExtrusion() bool</pre>
				<p>
Returns true if this surface is described by extruding a curve.
</p>

				
				
			
				
				<h3 id="GeometryBrepSweptSurface.IsRevolution">func (*GeometryBrepSweptSurface) <a href="/target/geometrybrep.go?s=10053:10108#L358">IsRevolution</a></h3>
				<pre>func (me *GeometryBrepSweptSurface) IsRevolution() bool</pre>
				<p>
Returns true if this surface is described by revolving a curve.
</p>

				
				
			
		
			
			
			<h2 id="GeometryBrepTorus">type <a href="/target/geometrybrep.go?s=10174:10316#L363">GeometryBrepTorus</a></h2>
			<pre>type GeometryBrepTorus struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	The first value is the major radius, the second is the minor radius.</span>
    Radii Float2
}</pre>
			<p>
Describes a torus in 3D space.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepWires">type <a href="/target/geometrybrep.go?s=10363:10668#L371">GeometryBrepWires</a></h2>
			<pre>type GeometryBrepWires struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	There must be at least inputs:</span>
    <span class="comment">//	One with Semantic &#34;EDGE&#34; to reference the edges for each wire.</span>
    <span class="comment">//	One with Semantic &#34;ORIENTATION&#34; defining the orientation of the referenced edge within the wire.</span>
    IndexedInputs
}</pre>
			<p>
Describes the wires of a B-rep structure.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryControlVertices">type <a href="/target/geometry.gt.go?s=768:851#L11">GeometryControlVertices</a></h2>
			<pre>type GeometryControlVertices struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Inputs</span>
    HasInputs
}</pre>
			<p>
Describes the control vertices of a spline.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryDef">type <a href="/target/geometry.gt.go?s=3437:3864#L101">GeometryDef</a></h2>
			<pre>type GeometryDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	If set, Mesh and Spline must be nil, and the GeometryDef is described by this B-rep structure.</span>
    Brep *GeometryBrep
    <span class="comment">//	If set, Brep and Spline must be nil, and the GeometryDef is described by this mesh structure.</span>
    Mesh *GeometryMesh
    <span class="comment">//	If set, Mesh and Brep must be nil, and the GeometryDef is described by this multi-segment spline.</span>
    Spline *GeometrySpline
}</pre>
			<p>
Describes the visual shape and appearance of an object in a scene.
</p>


			

			

			

			

			
				
				<h3 id="GeometryDef.Init">func (*GeometryDef) <a href="/target/geometry.gt.go?s=3884:3913#L113">Init</a></h3>
				<pre>func (me *GeometryDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="GeometryDef.NewInst">func (*GeometryDef) <a href="/target/geometry.gt.go?s=4738:4791#L143">NewInst</a></h3>
				<pre>func (me *GeometryDef) NewInst() (inst *GeometryInst)</pre>
				<p>
Creates and returns a new GeometryInst instance referencing this GeometryDef definition.
</p>

				
				
			
		
			
			
			<h2 id="GeometryInst">type <a href="/target/geometry.gt.go?s=3956:4425#L117">GeometryInst</a></h2>
			<pre>type GeometryInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *GeometryDef
    <span class="comment">//	Binds material symbols to material instances. This allows a single geometry</span>
    <span class="comment">//	to be instantiated into a scene multiple times each with a different appearance.</span>
    MaterialBinding *MaterialBinding
}</pre>
			<p>
Instantiates a geometry resource.
</p>


			

			

			

			

			
				
				<h3 id="GeometryInst.EnsureDef">func (*GeometryInst) <a href="/target/geometry.gt.go?s=5055:5103#L153">EnsureDef</a></h3>
				<pre>func (me *GeometryInst) EnsureDef() *GeometryDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct GeometryDef
according to the current me.DefRef value (by searching AllGeometryDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="GeometryInst.Init">func (*GeometryInst) <a href="/target/geometry.gt.go?s=4445:4475#L129">Init</a></h3>
				<pre>func (me *GeometryInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="GeometryMesh">type <a href="/target/geometry.gt.go?s=929:1423#L19">GeometryMesh</a></h2>
			<pre>type GeometryMesh struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Sources</span>
    HasSources
    <span class="comment">//	Refers to a GeometryDef described by a GeometryMesh.</span>
    <span class="comment">//	If specified, compute the convex hull of the specified mesh.</span>
    ConvexHullOf RefId
    <span class="comment">//	Describes the mesh-vertex attributes and establishes their topological identity.</span>
    <span class="comment">//	Required if ConvexHullOf is empty.</span>
    Vertices *GeometryVertices
    <span class="comment">//	Geometric primitives, which assemble values from the inputs into vertex attribute data.</span>
    Primitives []*GeometryPrimitives
}</pre>
			<p>
Describes basic geometric meshes using vertex and primitive information.
</p>


			

			

			

			
				
				<h3 id="NewGeometryMesh">func <a href="/target/geometry.gt.go?s=1440:1481#L35">NewGeometryMesh</a></h3>
				<pre>func NewGeometryMesh() (me *GeometryMesh)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryPolygonHole">type <a href="/target/geometry.gt.go?s=2297:2514#L59">GeometryPolygonHole</a></h2>
			<pre>type GeometryPolygonHole struct {
    <span class="comment">//	Specifies the vertex attributes (indices) for an individual polygon.</span>
    Indices []uint64
    <span class="comment">//	Specifies the indices of a hole in the polygon specified by Indices.</span>
    Holes [][]uint64
}</pre>
			<p>
Describes a polygon that contains one or more holes.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryPositioning">type <a href="/target/geometrybrep.go?s=10734:10947#L385">GeometryPositioning</a></h2>
			<pre>type GeometryPositioning struct {
    <span class="comment">//	If set, describes the origin of the object frame.</span>
    Origin *unum.Vec3
    <span class="comment">//	If set, these describe the orientation of the object frame.</span>
    Orientations []*GeometryBrepOrientation
}</pre>
			<p>
Used to position a surface or curve to its correct location.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryPrimitives">type <a href="/target/geometry.gt.go?s=1628:2239#L42">GeometryPrimitives</a></h2>
			<pre>type GeometryPrimitives struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	When at least one input is present, one input must specify its Semantic as &#34;VERTEX&#34;.</span>
    IndexedInputs
    <span class="comment">//	Must be one of the GEOMETRY_PRIMITIVE_TYPE_* enumerated constants.</span>
    Type int
    <span class="comment">//	Declares a symbol for a material. This symbol is bound to a material at the time of instantiation.</span>
    <span class="comment">//	Optional. If not specified then the lighting and shading results are application defined.</span>
    Material string
    <span class="comment">//	If Type is GEOMETRY_PRIMITIVE_TYPE_POLYGONS, describes the polygons that contain one or more holes.</span>
    PolyHoles []*GeometryPolygonHole
}</pre>
			<p>
Geometric primitives, which assemble values from inputs into vertex attribute data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometrySpline">type <a href="/target/geometry.gt.go?s=2596:2917#L67">GeometrySpline</a></h2>
			<pre>type GeometrySpline struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Sources</span>
    HasSources
    <span class="comment">//	Whether there is a segment connecting the first and last control vertices.</span>
    <span class="comment">//	The default is false, indicating that the spline is open.</span>
    Closed bool
    <span class="comment">//	Describes the control vertices of the spline.</span>
    ControlVertices GeometryControlVertices
}</pre>
			<p>
Describes a multisegment spline with control vertex and segment information.
</p>


			

			

			

			
				
				<h3 id="NewGeometrySpline">func <a href="/target/geometry.gt.go?s=2934:2979#L80">NewGeometrySpline</a></h3>
				<pre>func NewGeometrySpline() (me *GeometrySpline)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="GeometryVertices">type <a href="/target/geometry.gt.go?s=3257:3365#L89">GeometryVertices</a></h2>
			<pre>type GeometryVertices struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Inputs</span>
    HasInputs
}</pre>
			<p>
Declares the attributes and identity of mesh-vertices.
The mesh-vertices represent the position (identity) of the vertices comprising the mesh
and other vertex attributes that are invariant to tessellation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasAsset">type <a href="/target/common.go?s=840:944#L14">HasAsset</a></h2>
			<pre>type HasAsset struct {
    <span class="comment">//	Resource-specific asset-management information and meta-data.</span>
    Asset *Asset
}</pre>
			<p>
Used in all resources that require asset-management information.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasExtras">type <a href="/target/common.go?s=1022:1112#L20">HasExtras</a></h2>
			<pre>type HasExtras struct {
    <span class="comment">//	Custom-technique/foreign-profile meta-data.</span>
    Extras []*Extra
}</pre>
			<p>
Used in all resources that support custom techniques / foreign profiles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasFxParamDefs">type <a href="/target/common.go?s=1177:1303#L26">HasFxParamDefs</a></h2>
			<pre>type HasFxParamDefs struct {
    <span class="comment">//	A hash-table containing all parameter declarations of this resource.</span>
    NewParams FxParamDefs
}</pre>
			<p>
Used in all FX resources that declare their own parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasId">type <a href="/target/common.go?s=1372:1448#L32">HasId</a></h2>
			<pre>type HasId struct {
    <span class="comment">//	The unique identifier of this resource.</span>
    Id string
}</pre>
			<p>
Used in all resources that declare their own unique identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasInputs">type <a href="/target/common.go?s=1531:1663#L38">HasInputs</a></h2>
			<pre>type HasInputs struct {
    <span class="comment">//	Declares the input semantics of a data Source and connects a consumer to that Source.</span>
    Inputs []*Input
}</pre>
			<p>
Used in all data consumers that require input connections into a data Source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasName">type <a href="/target/common.go?s=1740:1835#L44">HasName</a></h2>
			<pre>type HasName struct {
    <span class="comment">//	The optional pretty-print name/title of this resource.</span>
    Name string
}</pre>
			<p>
Used in all resources that support arbitrary pretty-print names/titles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasParamDefs">type <a href="/target/common.go?s=1897:2019#L50">HasParamDefs</a></h2>
			<pre>type HasParamDefs struct {
    <span class="comment">//	A hash-table containing all parameter declarations of this resource.</span>
    NewParams ParamDefs
}</pre>
			<p>
Used in all resources that declare their own parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasParamInsts">type <a href="/target/common.go?s=2086:2213#L56">HasParamInsts</a></h2>
			<pre>type HasParamInsts struct {
    <span class="comment">//	A hash-table containing all parameter values assigned by this resource.</span>
    SetParams ParamInsts
}</pre>
			<p>
Used in all resources that assign values to other parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasSid">type <a href="/target/common.go?s=2282:2360#L62">HasSid</a></h2>
			<pre>type HasSid struct {
    <span class="comment">//	The Scoped identifier of this resource.</span>
    Sid string
}</pre>
			<p>
Used in all resources that declare their own scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasSources">type <a href="/target/common.go?s=2413:2503#L68">HasSources</a></h2>
			<pre>type HasSources struct {
    <span class="comment">//	Provides the bulk of this resource&#39;s data.</span>
    Sources Sources
}</pre>
			<p>
Used in all resources that provide data arrays.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasTechniques">type <a href="/target/common.go?s=2581:2689#L74">HasTechniques</a></h2>
			<pre>type HasTechniques struct {
    <span class="comment">//	Custom-technique/foreign-profile content or data.</span>
    Techniques []*Technique
}</pre>
			<p>
Used in all resources that support custom techniques / foreign profiles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="IndexedInputs">type <a href="/target/common.go?s=6191:6552#L177">IndexedInputs</a></h2>
			<pre>type IndexedInputs struct {
    <span class="comment">//	Number of primitives</span>
    Count uint64
    <span class="comment">//	Inputs specify how to read data from Sources.</span>
    Inputs []*InputShared
    <span class="comment">//	Indices that describe the attributes for a number of primitives.</span>
    <span class="comment">//	The indices reference into the Sources that are referenced by the Inputs.</span>
    Indices []uint64
    <span class="comment">//	Number of sub-primitives, if used.</span>
    Vcount []int64
}</pre>
			<p>
Used in various geometry primitives and b-rep resources.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Input">type <a href="/target/common.go?s=6648:6795#L190">Input</a></h2>
			<pre>type Input struct {
    <span class="comment">//	The user-defined meaning of the input connection.</span>
    Semantic string
    <span class="comment">//	Refers to the Source for this Input.</span>
    Source RefId
}</pre>
			<p>
Declares unshared input semantics of a data source and connects a consumer to that source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="InputShared">type <a href="/target/common.go?s=6889:7126#L198">InputShared</a></h2>
			<pre>type InputShared struct {
    <span class="comment">//	Semantic and Source</span>
    Input
    <span class="comment">//	The offset into the list of indices.</span>
    Offset uint64
    <span class="comment">//	Which inputs to group as a single set.</span>
    <span class="comment">//	This is helpful when multiple inputs share the same semantics.</span>
    Set *uint64
}</pre>
			<p>
Declares shared input semantics of a data source and connects a consumer to that source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int2">type <a href="/target/types.go?s=1018:1036#L46">Int2</a></h2>
			<pre>type Int2 [2]int64</pre>
			<p>
Contains two int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int2x2">type <a href="/target/types.go?s=1069:1089#L49">Int2x2</a></h2>
			<pre>type Int2x2 [4]int64</pre>
			<p>
Contains four int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int3">type <a href="/target/types.go?s=1123:1141#L52">Int3</a></h2>
			<pre>type Int3 [3]int64</pre>
			<p>
Contains three int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int3x3">type <a href="/target/types.go?s=1174:1194#L55">Int3x3</a></h2>
			<pre>type Int3x3 [9]int64</pre>
			<p>
Contains nine int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int4">type <a href="/target/types.go?s=1227:1245#L58">Int4</a></h2>
			<pre>type Int4 [4]int64</pre>
			<p>
Contains four int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int4x4">type <a href="/target/types.go?s=1281:1302#L61">Int4x4</a></h2>
			<pre>type Int4x4 [16]int64</pre>
			<p>
Contains sixteen int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxArticulatedSystemDef">type <a href="/target/kxarticulatedsystem.gt.go?s=5976:6289#L181">KxArticulatedSystemDef</a></h2>
			<pre>type KxArticulatedSystemDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	If set, Motion must be nil, and this articulated system describes a kinematics system.</span>
    Kinematics *KxKinematicsSystem
    <span class="comment">//	If set, Kinematics must be nil, and this articulated system describes a motion system.</span>
    Motion *KxMotionSystem
}</pre>
			<p>
Categorizes the declaration of generic control information for kinematics systems.
</p>


			

			

			

			

			
				
				<h3 id="KxArticulatedSystemDef.Init">func (*KxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=6309:6349#L191">Init</a></h3>
				<pre>func (me *KxArticulatedSystemDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="KxArticulatedSystemDef.NewInst">func (*KxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=7281:7356#L226">NewInst</a></h3>
				<pre>func (me *KxArticulatedSystemDef) NewInst() (inst *KxArticulatedSystemInst)</pre>
				<p>
Creates and returns a new KxArticulatedSystemInst instance referencing this KxArticulatedSystemDef definition.
</p>

				
				
			
		
			
			
			<h2 id="KxArticulatedSystemInst">type <a href="/target/kxarticulatedsystem.gt.go?s=6413:6834#L195">KxArticulatedSystemInst</a></h2>
			<pre>type KxArticulatedSystemInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *KxArticulatedSystemDef
    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding
}</pre>
			<p>
Instantiates a kinematics articulated system resource.
</p>


			

			

			

			

			
				
				<h3 id="KxArticulatedSystemInst.EnsureDef">func (*KxArticulatedSystemInst) <a href="/target/kxarticulatedsystem.gt.go?s=7653:7723#L236">EnsureDef</a></h3>
				<pre>func (me *KxArticulatedSystemInst) EnsureDef() *KxArticulatedSystemDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct KxArticulatedSystemDef
according to the current me.DefRef value (by searching AllKxArticulatedSystemDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="KxArticulatedSystemInst.Init">func (*KxArticulatedSystemInst) <a href="/target/kxarticulatedsystem.gt.go?s=6854:6895#L210">Init</a></h3>
				<pre>func (me *KxArticulatedSystemInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxAttachment">type <a href="/target/kxmodel.gt.go?s=368:793#L3">KxAttachment</a></h2>
			<pre>type KxAttachment struct {
    <span class="comment">//	Must be one of the KX_ATTACHMENT_TYPE_* enumerated constants.</span>
    Type int
    <span class="comment">//	Refers to the KxJoint that connects the parent with the child link. Required.</span>
    Joint RefSid
    <span class="comment">//	Zero or more TRANSFORM_TYPE_ROTATE and/or TRANSFORM_TYPE_TRANSLATE transformations.</span>
    Transforms []*Transform
    <span class="comment">//	If Type is KX_ATTACHMENT_TYPE_FULL, specifies the child link in this parent-child dependency.</span>
    Link *KxLink
}</pre>
			<p>
Connects links or define ends of closed loops.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxAxisIndex">type <a href="/target/kxarticulatedsystem.gt.go?s=616:792#L7">KxAxisIndex</a></h2>
			<pre>type KxAxisIndex struct {
    <span class="comment">//	If set, specifies the special use of this index.</span>
    Semantic string
    <span class="comment">//	If not set, the parent axis will not appear in the jointmap.</span>
    I ParamOrInt
}</pre>
			<p>
Specifies the parent axis&#39; index in the jointmap.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxAxisLimits">type <a href="/target/kxarticulatedsystem.gt.go?s=837:1007#L15">KxAxisLimits</a></h2>
			<pre>type KxAxisLimits struct {
    <span class="comment">//	The &#34;minimum&#34; portion of this limits descriptor.</span>
    Min ParamOrFloat
    <span class="comment">//	The &#34;maximum&#34; portion of this limits descriptor.</span>
    Max ParamOrFloat
}</pre>
			<p>
Specifies the parent axis&#39; soft limits.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxBinding">type <a href="/target/kxarticulatedsystem.gt.go?s=1070:1286#L23">KxBinding</a></h2>
			<pre>type KxBinding struct {
    <span class="comment">//	The identifier of the parameter to bind to the new symbol name. Required.</span>
    Symbol string
    <span class="comment">//	If set, Value is ignored.</span>
    Param RefParam
    <span class="comment">//	Only used if Param is empty.</span>
    Value interface{}
}</pre>
			<p>
Binds inputs to kinematics parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxEffector">type <a href="/target/kxarticulatedsystem.gt.go?s=1350:2141#L33">KxEffector</a></h2>
			<pre>type KxEffector struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding
    <span class="comment">//	Specifies maximum speed.</span>
    <span class="comment">//	The first value is translational (m/sec), the second is rotational (°/sec).</span>
    Speed *ParamOrFloat2
    <span class="comment">//	Specifies maximum acceleration.</span>
    <span class="comment">//	The first value is translational (m/sec²), the second is rotational (°/sec²).</span>
    Acceleration *ParamOrFloat2
    <span class="comment">//	Specifies the maximum deceleration.</span>
    <span class="comment">//	The first value is translational (m/sec²), the second is rotational (°/sec²).</span>
    Deceleration *ParamOrFloat2
    <span class="comment">//	Specifies the maximum jerk (also called jolt or surge).</span>
    <span class="comment">//	The first value is translational (m/sec³), the second is rotational (°/sec³).</span>
    Jerk *ParamOrFloat2
}</pre>
			<p>
Specifies additional dynamics information for an effector.
</p>


			

			

			

			
				
				<h3 id="NewKxEffector">func <a href="/target/kxarticulatedsystem.gt.go?s=2158:2195#L59">NewKxEffector</a></h3>
				<pre>func NewKxEffector() (me *KxEffector)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="KxFrame">type <a href="/target/kxarticulatedsystem.gt.go?s=2355:2642#L67">KxFrame</a></h2>
			<pre>type KxFrame struct {
    <span class="comment">//	Must be one of the KX_FRAME_TYPE_* enumerated constants.</span>
    Type int
    <span class="comment">//	References a KxLink defined in the kinematics model. Optional.</span>
    Link RefSid
    <span class="comment">//	Zero or more TRANSFORM_TYPE_TRANSLATE and/or TRANSFORM_TYPE_ROTATE transformations.</span>
    Transforms []*Transform
}</pre>
			<p>
Contains information for a frame used for kinematics calculation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJoint">type <a href="/target/kxjoint.gt.go?s=437:735#L3">KxJoint</a></h2>
			<pre>type KxJoint struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Must be one of the KX_JOINT_TYPE_* enumerated constants.</span>
    Type int
    <span class="comment">//	Specifies the axis of the degree of freedom.</span>
    Axis struct {
        <span class="comment">//	Name</span>
        HasName
        <span class="comment">//	Sid, V</span>
        SidVec3
    }
    <span class="comment">//	If set, these specified limits are physical limits.</span>
    Limits *KxJointLimits
}</pre>
			<p>
Primitive (simple) joints are joints with one degree of freedom (one given axis) and
are used to construct more complex joint types (compound joints) that consist of
multiple primitives, each representing an axis.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJointAxisBinding">type <a href="/target/kxscene.gt.go?s=881:1151#L12">KxJointAxisBinding</a></h2>
			<pre>type KxJointAxisBinding struct {
    <span class="comment">//	A reference to a transformation of a node.</span>
    Target RefSid
    <span class="comment">//	If set, Value is ignored. Specifies an axis of a kinematics model.</span>
    Axis ParamOrRefSid
    <span class="comment">//	Only used if Axis is empty. Specifies a value of the axis.</span>
    Value ParamOrFloat
}</pre>
			<p>
Binds a joint axis of a kinematics model to a single transformation of a node. By binding a joint axis
to a transformation of a node, it is possible to synchronize a kinematics scene with a visual scene.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJointDef">type <a href="/target/kxjoint.gt.go?s=1187:1508#L29">KxJointDef</a></h2>
			<pre>type KxJointDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Primitive (simple) joints are joints with one degree of freedom (one given axis) and are</span>
    <span class="comment">//	used to construct more complex joint types (compound joints) that</span>
    <span class="comment">//	consist of multiple primitives, each representing an axis.</span>
    All []*KxJoint
}</pre>
			<p>
Defines a single complex/compound joint with one or more degrees of freedom.
</p>


			

			

			

			

			
				
				<h3 id="KxJointDef.Init">func (*KxJointDef) <a href="/target/kxjoint.gt.go?s=1528:1556#L41">Init</a></h3>
				<pre>func (me *KxJointDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="KxJointDef.NewInst">func (*KxJointDef) <a href="/target/kxjoint.gt.go?s=2181:2232#L68">NewInst</a></h3>
				<pre>func (me *KxJointDef) NewInst() (inst *KxJointInst)</pre>
				<p>
Creates and returns a new KxJointInst instance referencing this KxJointDef definition.
</p>

				
				
			
		
			
			
			<h2 id="KxJointInst">type <a href="/target/kxjoint.gt.go?s=1607:1875#L45">KxJointInst</a></h2>
			<pre>type KxJointInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *KxJointDef
}</pre>
			<p>
Instantiates a kinematics joint resource.
</p>


			

			

			

			

			
				
				<h3 id="KxJointInst.EnsureDef">func (*KxJointInst) <a href="/target/kxjoint.gt.go?s=2493:2539#L78">EnsureDef</a></h3>
				<pre>func (me *KxJointInst) EnsureDef() *KxJointDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct KxJointDef
according to the current me.DefRef value (by searching AllKxJointDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="KxJointInst.Init">func (*KxJointInst) <a href="/target/kxjoint.gt.go?s=1895:1924#L54">Init</a></h3>
				<pre>func (me *KxJointInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxJointLimits">type <a href="/target/kxjoint.gt.go?s=926:1105#L21">KxJointLimits</a></h2>
			<pre>type KxJointLimits struct {
    <span class="comment">//	If set, the &#34;minimum&#34; portion of this joint limitation.</span>
    Min *SidFloat
    <span class="comment">//	If set, the &#34;maximum&#34; portion of this joint limitation.</span>
    Max *SidFloat
}</pre>
			<p>
Declares a primitive/simple joint as fully limited (if Min and Max are both set),
partially limited (if either Min or Max is nil, but not both) or unlimited (if Min and Max are nil).
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxKinematicsAxis">type <a href="/target/kxarticulatedsystem.gt.go?s=2734:3430#L77">KxKinematicsAxis</a></h2>
			<pre>type KxKinematicsAxis struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	The joint axis of an instantiated kinematics model.</span>
    Axis RefSid
    <span class="comment">//	Defaults to true.</span>
    Active ParamOrBool
    <span class="comment">//	Specifies this axis&#39; indices in the jointmap. If empty, this axis will not appear in the jointmap.</span>
    Indices []*KxAxisIndex
    <span class="comment">//	Specifies the soft limits. If not set, the axis is limited only by its physical limits.</span>
    Limits *KxAxisLimits
    <span class="comment">//	Defaults to false.</span>
    Locked ParamOrBool
    <span class="comment">//	Formulas can be useful to define the behavior of a passive link according to one or more</span>
    <span class="comment">//	active axes, or to define dependencies of the soft limits and another joint, for example.</span>
    Formulas []Formula
}</pre>
			<p>
Contains axis information to describe the kinematics behavior of an articulated model.
</p>


			

			

			

			
				
				<h3 id="NewKxKinematicsAxis">func <a href="/target/kxarticulatedsystem.gt.go?s=3447:3496#L100">NewKxKinematicsAxis</a></h3>
				<pre>func NewKxKinematicsAxis() (me *KxKinematicsAxis)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="KxKinematicsSystem">type <a href="/target/kxarticulatedsystem.gt.go?s=3680:4501#L107">KxKinematicsSystem</a></h2>
			<pre>type KxKinematicsSystem struct {
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	The kinematics models to be enhanced with kinematics information.</span>
    Models []*KxModelInst
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Kinematics-related information for all axes.</span>
        AxisInfos []*KxKinematicsAxis
        <span class="comment">//	Kinematics calculation chain frames</span>
        Frame struct {
            <span class="comment">//	Defines the base frame for kinematics calculation.</span>
            Origin KxFrame
            <span class="comment">//	Defines the frame at the end of the kinematics chain.</span>
            Tip KxFrame
            <span class="comment">//	If set, defines the offset frame from the Tip frame,</span>
            <span class="comment">//	which usually represents the work point of the end effector (for example, a welding gun).</span>
            Tcp *KxFrame
            <span class="comment">//	If set, defines the offset frame from the Origin frame;</span>
            <span class="comment">//	this offset usually represents the transformation to a work piece.</span>
            Object *KxFrame
        }
    }
}</pre>
			<p>
Contains additional information to describe the kinematical behavior of an articulated model.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxLink">type <a href="/target/kxmodel.gt.go?s=900:1142#L15">KxLink</a></h2>
			<pre>type KxLink struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Zero or more TRANSFORM_TYPE_ROTATE and/or TRANSFORM_TYPE_TRANSLATE transformations.</span>
    Transforms []*Transform
    <span class="comment">//	The attachments that make up this link.</span>
    Attachments []*KxAttachment
}</pre>
			<p>
Represents a rigid kinematical object without mass whose motion is constrained by one or more joints.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxModelBinding">type <a href="/target/kxscene.gt.go?s=196:669#L1">KxModelBinding</a></h2>
			<pre>type KxModelBinding struct {
    <span class="comment">//	A reference to a node.</span>
    Node RefId
    <span class="comment">//	Refers to the kinematics model being bound.</span>
    <span class="comment">//	Only either SidRef or ParamRef, but not both, must be specified.</span>
    Model struct {
        <span class="comment">//	If set, ParamRef must be empty.</span>
        <span class="comment">//	The Sid path to the kinematics model to bind to the node.</span>
        SidRef RefSid
        <span class="comment">//	If set, SidRef must be empty.</span>
        <span class="comment">//	The parameter of the kinematics model that is defined in the instantiated kinematics scene.</span>
        ParamRef RefParam
    }
}</pre>
			<p>
Binds a kinematics model to a node. The description of a kinematics model is
completely independent of any visual information, but for calculation the position is important.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxModelDef">type <a href="/target/kxmodel.gt.go?s=1403:1683#L29">KxModelDef</a></h2>
			<pre>type KxModelDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	NewParams</span>
        HasParamDefs
        <span class="comment">//	The kinematics chain.</span>
        Links []*KxLink
        <span class="comment">//	Specifies dependencies among the joints.</span>
        Formulas []Formula
    }
}</pre>
			<p>
Categorizes the declaration of kinematical information, containing declarations of
joints, links, and attachment points. A kinematics model is focused on strict
kinematics description &#34;in zero position&#34;, without any additional physical descriptions.
</p>


			

			

			

			

			
				
				<h3 id="KxModelDef.Init">func (*KxModelDef) <a href="/target/kxmodel.gt.go?s=1703:1731#L46">Init</a></h3>
				<pre>func (me *KxModelDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="KxModelDef.NewInst">func (*KxModelDef) <a href="/target/kxmodel.gt.go?s=2573:2624#L82">NewInst</a></h3>
				<pre>func (me *KxModelDef) NewInst() (inst *KxModelInst)</pre>
				<p>
Creates and returns a new KxModelInst instance referencing this KxModelDef definition.
</p>

				
				
			
		
			
			
			<h2 id="KxModelInst">type <a href="/target/kxmodel.gt.go?s=1813:2210#L51">KxModelInst</a></h2>
			<pre>type KxModelInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *KxModelDef
    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding
}</pre>
			<p>
Instantiates a kinematics model resource.
</p>


			

			

			

			

			
				
				<h3 id="KxModelInst.EnsureDef">func (*KxModelInst) <a href="/target/kxmodel.gt.go?s=2885:2931#L92">EnsureDef</a></h3>
				<pre>func (me *KxModelInst) EnsureDef() *KxModelDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct KxModelDef
according to the current me.DefRef value (by searching AllKxModelDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="KxModelInst.Init">func (*KxModelInst) <a href="/target/kxmodel.gt.go?s=2230:2259#L66">Init</a></h3>
				<pre>func (me *KxModelInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxMotionAxis">type <a href="/target/kxarticulatedsystem.gt.go?s=4589:5284#L133">KxMotionAxis</a></h2>
			<pre>type KxMotionAxis struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	References the KxKinematicsAxis of an instantiated kinematics system.</span>
    Axis RefSid
    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding
    <span class="comment">//	The maximum permitted speed of the axis in meters per second (m/sec).</span>
    Speed *ParamOrFloat
    <span class="comment">//	The maximum permitted acceleration of the axis in m/sec².</span>
    Acceleration *ParamOrFloat
    <span class="comment">//	The maximum permitted deceleration of an axis.</span>
    <span class="comment">//	If not set, acceleration and deceleration have the same value in m/sec².</span>
    Deceleration *ParamOrFloat
    <span class="comment">//	The maximum permitted jerk of an axis in m/sec³.</span>
    Jerk *ParamOrFloat
}</pre>
			<p>
Contains axis information to describe the motion behavior of an articulated model.
</p>


			

			

			

			
				
				<h3 id="NewKxMotionAxis">func <a href="/target/kxarticulatedsystem.gt.go?s=5301:5342#L158">NewKxMotionAxis</a></h3>
				<pre>func NewKxMotionAxis() (me *KxMotionAxis)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="KxMotionSystem">type <a href="/target/kxarticulatedsystem.gt.go?s=5530:5888#L166">KxMotionSystem</a></h2>
			<pre>type KxMotionSystem struct {
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	The articulated system to be enhanced with dynamics information.</span>
    ArticulatedSystem *KxArticulatedSystemInst
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Dynamics-related information for all axes.</span>
        AxisInfos []*KxMotionAxis
        <span class="comment">//	Additional dynamics information</span>
        EffectorInfo *KxEffector
    }
}</pre>
			<p>
Contains additional information to describe the dynamics behaviour of an articulated model.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxSceneDef">type <a href="/target/kxscene.gt.go?s=1247:1532#L22">KxSceneDef</a></h2>
			<pre>type KxSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Zero or more kinematics models participating in this kinematics scene.</span>
    Models []*KxModelInst
    <span class="comment">//	Zero or more articulated systems participating in this kinematics scene.</span>
    ArticulatedSystems []*KxArticulatedSystemInst
}</pre>
			<p>
Embodies the entire set of kinematics information that can be articulated from a resource.
</p>


			

			

			

			

			
				
				<h3 id="KxSceneDef.Init">func (*KxSceneDef) <a href="/target/kxscene.gt.go?s=1552:1580#L32">Init</a></h3>
				<pre>func (me *KxSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="KxSceneDef.NewInst">func (*KxSceneDef) <a href="/target/kxscene.gt.go?s=2541:2592#L69">NewInst</a></h3>
				<pre>func (me *KxSceneDef) NewInst() (inst *KxSceneInst)</pre>
				<p>
Creates and returns a new KxSceneInst instance referencing this KxSceneDef definition.
</p>

				
				
			
		
			
			
			<h2 id="KxSceneInst">type <a href="/target/kxscene.gt.go?s=1631:2178#L36">KxSceneInst</a></h2>
			<pre>type KxSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *KxSceneDef
    <span class="comment">//	Zero or more bindings of kinematics models to nodes.</span>
    ModelBindings []*KxModelBinding
    <span class="comment">//	Zero or more bindings of kinematics models&#39; joint axes to single node transformations.</span>
    JointAxisBindings []*KxJointAxisBinding
}</pre>
			<p>
Instantiates a kinematics scene resource.
</p>


			

			

			

			

			
				
				<h3 id="KxSceneInst.EnsureDef">func (*KxSceneInst) <a href="/target/kxscene.gt.go?s=2853:2899#L79">EnsureDef</a></h3>
				<pre>func (me *KxSceneInst) EnsureDef() *KxSceneDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct KxSceneDef
according to the current me.DefRef value (by searching AllKxSceneDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="KxSceneInst.Init">func (*KxSceneInst) <a href="/target/kxscene.gt.go?s=2198:2227#L53">Init</a></h3>
				<pre>func (me *KxSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="Layers">type <a href="/target/common.go?s=7196:7223#L209">Layers</a></h2>
			<pre>type Layers map[string]bool</pre>
			<p>
Allows simple association of resources with custom named layers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LibAnimationClipDefs">type <a href="/target/animationclip.gt.go?s=3433:3699#L103">LibAnimationClipDefs</a></h2>
			<pre>type LibAnimationClipDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*AnimationClipDef
}</pre>
			<p>
A library that contains AnimationClipDefs associated by their Id.
To create a new LibAnimationClipDefs library, ONLY use the LibsAnimationClipDef.New() or LibsAnimationClipDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibAnimationClipDefs.Add">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=4079:4157#L118">Add</a></h3>
				<pre>func (me *LibAnimationClipDefs) Add(d *AnimationClipDef) (n *AnimationClipDef)</pre>
				<p>
Adds the specified AnimationClipDef definition to this LibAnimationClipDefs, and returns it.
If this LibAnimationClipDefs already contains a AnimationClipDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.AddNew">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=4491:4558#L128">AddNew</a></h3>
				<pre>func (me *LibAnimationClipDefs) AddNew(id string) *AnimationClipDef</pre>
				<p>
Creates a new AnimationClipDef definition with the specified Id, adds it to this LibAnimationClipDefs, and returns it.
If this LibAnimationClipDefs already contains a AnimationClipDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.Len">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=4631:4672#L131">Len</a></h3>
				<pre>func (me *LibAnimationClipDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.New">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=4831:4901#L135">New</a></h3>
				<pre>func (me *LibAnimationClipDefs) New(id string) (def *AnimationClipDef)</pre>
				<p>
Creates a new AnimationClipDef definition with the specified Id and returns it,
but does not add it to this LibAnimationClipDefs.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.Remove">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=5031:5080#L138">Remove</a></h3>
				<pre>func (me *LibAnimationClipDefs) Remove(id string)</pre>
				<p>
Removes the AnimationClipDef with the specified Id from this LibAnimationClipDefs.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.SyncChanges">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=5438:5483#L143">SyncChanges</a></h3>
				<pre>func (me *LibAnimationClipDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibAnimationClipDefs
that need to be picked up. Call this after you have made a number of changes to this LibAnimationClipDefs
library or its AnimationClipDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibAnimationDefs">type <a href="/target/animation.gt.go?s=4663:4921#L141">LibAnimationDefs</a></h2>
			<pre>type LibAnimationDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*AnimationDef
}</pre>
			<p>
A library that contains AnimationDefs associated by their Id.
To create a new LibAnimationDefs library, ONLY use the LibsAnimationDef.New() or LibsAnimationDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibAnimationDefs.Add">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=5269:5335#L156">Add</a></h3>
				<pre>func (me *LibAnimationDefs) Add(d *AnimationDef) (n *AnimationDef)</pre>
				<p>
Adds the specified AnimationDef definition to this LibAnimationDefs, and returns it.
If this LibAnimationDefs already contains a AnimationDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.AddNew">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=5653:5712#L166">AddNew</a></h3>
				<pre>func (me *LibAnimationDefs) AddNew(id string) *AnimationDef</pre>
				<p>
Creates a new AnimationDef definition with the specified Id, adds it to this LibAnimationDefs, and returns it.
If this LibAnimationDefs already contains a AnimationDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.Len">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=5785:5822#L169">Len</a></h3>
				<pre>func (me *LibAnimationDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.New">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=5973:6035#L173">New</a></h3>
				<pre>func (me *LibAnimationDefs) New(id string) (def *AnimationDef)</pre>
				<p>
Creates a new AnimationDef definition with the specified Id and returns it,
but does not add it to this LibAnimationDefs.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.Remove">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=6153:6198#L176">Remove</a></h3>
				<pre>func (me *LibAnimationDefs) Remove(id string)</pre>
				<p>
Removes the AnimationDef with the specified Id from this LibAnimationDefs.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.SyncChanges">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=6544:6585#L181">SyncChanges</a></h3>
				<pre>func (me *LibAnimationDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibAnimationDefs
that need to be picked up. Call this after you have made a number of changes to this LibAnimationDefs
library or its AnimationDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibCameraDefs">type <a href="/target/camera.gt.go?s=4098:4350#L143">LibCameraDefs</a></h2>
			<pre>type LibCameraDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*CameraDef
}</pre>
			<p>
A library that contains CameraDefs associated by their Id.
To create a new LibCameraDefs library, ONLY use the LibsCameraDef.New() or LibsCameraDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibCameraDefs.Add">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4674:4731#L158">Add</a></h3>
				<pre>func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</pre>
				<p>
Adds the specified CameraDef definition to this LibCameraDefs, and returns it.
If this LibCameraDefs already contains a CameraDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.AddNew">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5037:5090#L168">AddNew</a></h3>
				<pre>func (me *LibCameraDefs) AddNew(id string) *CameraDef</pre>
				<p>
Creates a new CameraDef definition with the specified Id, adds it to this LibCameraDefs, and returns it.
If this LibCameraDefs already contains a CameraDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Len">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5163:5197#L171">Len</a></h3>
				<pre>func (me *LibCameraDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibCameraDefs.New">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5342:5398#L175">New</a></h3>
				<pre>func (me *LibCameraDefs) New(id string) (def *CameraDef)</pre>
				<p>
Creates a new CameraDef definition with the specified Id and returns it,
but does not add it to this LibCameraDefs.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Remove">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5507:5549#L178">Remove</a></h3>
				<pre>func (me *LibCameraDefs) Remove(id string)</pre>
				<p>
Removes the CameraDef with the specified Id from this LibCameraDefs.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.SyncChanges">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5886:5924#L183">SyncChanges</a></h3>
				<pre>func (me *LibCameraDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibCameraDefs
that need to be picked up. Call this after you have made a number of changes to this LibCameraDefs
library or its CameraDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibControllerDefs">type <a href="/target/controller.gt.go?s=5084:5344#L160">LibControllerDefs</a></h2>
			<pre>type LibControllerDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*ControllerDef
}</pre>
			<p>
A library that contains ControllerDefs associated by their Id.
To create a new LibControllerDefs library, ONLY use the LibsControllerDef.New() or LibsControllerDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibControllerDefs.Add">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=5700:5769#L175">Add</a></h3>
				<pre>func (me *LibControllerDefs) Add(d *ControllerDef) (n *ControllerDef)</pre>
				<p>
Adds the specified ControllerDef definition to this LibControllerDefs, and returns it.
If this LibControllerDefs already contains a ControllerDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.AddNew">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6091:6152#L185">AddNew</a></h3>
				<pre>func (me *LibControllerDefs) AddNew(id string) *ControllerDef</pre>
				<p>
Creates a new ControllerDef definition with the specified Id, adds it to this LibControllerDefs, and returns it.
If this LibControllerDefs already contains a ControllerDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.Len">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6225:6263#L188">Len</a></h3>
				<pre>func (me *LibControllerDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibControllerDefs.New">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6416:6480#L192">New</a></h3>
				<pre>func (me *LibControllerDefs) New(id string) (def *ControllerDef)</pre>
				<p>
Creates a new ControllerDef definition with the specified Id and returns it,
but does not add it to this LibControllerDefs.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.Remove">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6601:6647#L195">Remove</a></h3>
				<pre>func (me *LibControllerDefs) Remove(id string)</pre>
				<p>
Removes the ControllerDef with the specified Id from this LibControllerDefs.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.SyncChanges">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6996:7038#L200">SyncChanges</a></h3>
				<pre>func (me *LibControllerDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibControllerDefs
that need to be picked up. Call this after you have made a number of changes to this LibControllerDefs
library or its ControllerDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibFormulaDefs">type <a href="/target/formula.gt.go?s=3448:3702#L124">LibFormulaDefs</a></h2>
			<pre>type LibFormulaDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*FormulaDef
}</pre>
			<p>
A library that contains FormulaDefs associated by their Id.
To create a new LibFormulaDefs library, ONLY use the LibsFormulaDef.New() or LibsFormulaDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFormulaDefs.Add">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4034:4094#L139">Add</a></h3>
				<pre>func (me *LibFormulaDefs) Add(d *FormulaDef) (n *FormulaDef)</pre>
				<p>
Adds the specified FormulaDef definition to this LibFormulaDefs, and returns it.
If this LibFormulaDefs already contains a FormulaDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.AddNew">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4404:4459#L149">AddNew</a></h3>
				<pre>func (me *LibFormulaDefs) AddNew(id string) *FormulaDef</pre>
				<p>
Creates a new FormulaDef definition with the specified Id, adds it to this LibFormulaDefs, and returns it.
If this LibFormulaDefs already contains a FormulaDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.Len">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4532:4567#L152">Len</a></h3>
				<pre>func (me *LibFormulaDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.New">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4714:4772#L156">New</a></h3>
				<pre>func (me *LibFormulaDefs) New(id string) (def *FormulaDef)</pre>
				<p>
Creates a new FormulaDef definition with the specified Id and returns it,
but does not add it to this LibFormulaDefs.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.Remove">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4884:4927#L159">Remove</a></h3>
				<pre>func (me *LibFormulaDefs) Remove(id string)</pre>
				<p>
Removes the FormulaDef with the specified Id from this LibFormulaDefs.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.SyncChanges">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=5267:5306#L164">SyncChanges</a></h3>
				<pre>func (me *LibFormulaDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibFormulaDefs
that need to be picked up. Call this after you have made a number of changes to this LibFormulaDefs
library or its FormulaDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxEffectDefs">type <a href="/target/fxeffect.gt.go?s=17353:17609#L489">LibFxEffectDefs</a></h2>
			<pre>type LibFxEffectDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxEffectDef
}</pre>
			<p>
A library that contains FxEffectDefs associated by their Id.
To create a new LibFxEffectDefs library, ONLY use the LibsFxEffectDef.New() or LibsFxEffectDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxEffectDefs.Add">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=17949:18012#L504">Add</a></h3>
				<pre>func (me *LibFxEffectDefs) Add(d *FxEffectDef) (n *FxEffectDef)</pre>
				<p>
Adds the specified FxEffectDef definition to this LibFxEffectDefs, and returns it.
If this LibFxEffectDefs already contains a FxEffectDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.AddNew">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=18326:18383#L514">AddNew</a></h3>
				<pre>func (me *LibFxEffectDefs) AddNew(id string) *FxEffectDef</pre>
				<p>
Creates a new FxEffectDef definition with the specified Id, adds it to this LibFxEffectDefs, and returns it.
If this LibFxEffectDefs already contains a FxEffectDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.Len">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=18456:18492#L517">Len</a></h3>
				<pre>func (me *LibFxEffectDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.New">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=18641:18701#L521">New</a></h3>
				<pre>func (me *LibFxEffectDefs) New(id string) (def *FxEffectDef)</pre>
				<p>
Creates a new FxEffectDef definition with the specified Id and returns it,
but does not add it to this LibFxEffectDefs.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.Remove">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=18816:18860#L524">Remove</a></h3>
				<pre>func (me *LibFxEffectDefs) Remove(id string)</pre>
				<p>
Removes the FxEffectDef with the specified Id from this LibFxEffectDefs.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.SyncChanges">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=19203:19243#L529">SyncChanges</a></h3>
				<pre>func (me *LibFxEffectDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibFxEffectDefs
that need to be picked up. Call this after you have made a number of changes to this LibFxEffectDefs
library or its FxEffectDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxImageDefs">type <a href="/target/fximage.gt.go?s=13424:13678#L359">LibFxImageDefs</a></h2>
			<pre>type LibFxImageDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxImageDef
}</pre>
			<p>
A library that contains FxImageDefs associated by their Id.
To create a new LibFxImageDefs library, ONLY use the LibsFxImageDef.New() or LibsFxImageDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxImageDefs.Add">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14010:14070#L374">Add</a></h3>
				<pre>func (me *LibFxImageDefs) Add(d *FxImageDef) (n *FxImageDef)</pre>
				<p>
Adds the specified FxImageDef definition to this LibFxImageDefs, and returns it.
If this LibFxImageDefs already contains a FxImageDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.AddFromRefUrls">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=11022:11091#L275">AddFromRefUrls</a></h3>
				<pre>func (me *LibFxImageDefs) AddFromRefUrls(idRefUrls map[string]string)</pre>
				<p>
Adds multiple FxImageDefs to this library,
with each one&#39;s Id and InitFrom.RefUrl set from the specified idRefUrls map.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.AddNew">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14380:14435#L384">AddNew</a></h3>
				<pre>func (me *LibFxImageDefs) AddNew(id string) *FxImageDef</pre>
				<p>
Creates a new FxImageDef definition with the specified Id, adds it to this LibFxImageDefs, and returns it.
If this LibFxImageDefs already contains a FxImageDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.Len">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14508:14543#L387">Len</a></h3>
				<pre>func (me *LibFxImageDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.New">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14690:14748#L391">New</a></h3>
				<pre>func (me *LibFxImageDefs) New(id string) (def *FxImageDef)</pre>
				<p>
Creates a new FxImageDef definition with the specified Id and returns it,
but does not add it to this LibFxImageDefs.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.Remove">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14860:14903#L394">Remove</a></h3>
				<pre>func (me *LibFxImageDefs) Remove(id string)</pre>
				<p>
Removes the FxImageDef with the specified Id from this LibFxImageDefs.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.SyncChanges">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=15243:15282#L399">SyncChanges</a></h3>
				<pre>func (me *LibFxImageDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibFxImageDefs
that need to be picked up. Call this after you have made a number of changes to this LibFxImageDefs
library or its FxImageDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxMaterialDefs">type <a href="/target/fxmaterial.gt.go?s=3952:4212#L120">LibFxMaterialDefs</a></h2>
			<pre>type LibFxMaterialDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxMaterialDef
}</pre>
			<p>
A library that contains FxMaterialDefs associated by their Id.
To create a new LibFxMaterialDefs library, ONLY use the LibsFxMaterialDef.New() or LibsFxMaterialDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxMaterialDefs.Add">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=4568:4637#L135">Add</a></h3>
				<pre>func (me *LibFxMaterialDefs) Add(d *FxMaterialDef) (n *FxMaterialDef)</pre>
				<p>
Adds the specified FxMaterialDef definition to this LibFxMaterialDefs, and returns it.
If this LibFxMaterialDefs already contains a FxMaterialDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.AddNew">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=4959:5020#L145">AddNew</a></h3>
				<pre>func (me *LibFxMaterialDefs) AddNew(id string) *FxMaterialDef</pre>
				<p>
Creates a new FxMaterialDef definition with the specified Id, adds it to this LibFxMaterialDefs, and returns it.
If this LibFxMaterialDefs already contains a FxMaterialDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.Len">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=5093:5131#L148">Len</a></h3>
				<pre>func (me *LibFxMaterialDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.New">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=5284:5348#L152">New</a></h3>
				<pre>func (me *LibFxMaterialDefs) New(id string) (def *FxMaterialDef)</pre>
				<p>
Creates a new FxMaterialDef definition with the specified Id and returns it,
but does not add it to this LibFxMaterialDefs.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.Remove">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=5469:5515#L155">Remove</a></h3>
				<pre>func (me *LibFxMaterialDefs) Remove(id string)</pre>
				<p>
Removes the FxMaterialDef with the specified Id from this LibFxMaterialDefs.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.SyncChanges">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=5864:5906#L160">SyncChanges</a></h3>
				<pre>func (me *LibFxMaterialDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibFxMaterialDefs
that need to be picked up. Call this after you have made a number of changes to this LibFxMaterialDefs
library or its FxMaterialDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibGeometryDefs">type <a href="/target/geometry.gt.go?s=6753:7009#L210">LibGeometryDefs</a></h2>
			<pre>type LibGeometryDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*GeometryDef
}</pre>
			<p>
A library that contains GeometryDefs associated by their Id.
To create a new LibGeometryDefs library, ONLY use the LibsGeometryDef.New() or LibsGeometryDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibGeometryDefs.Add">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=7349:7412#L225">Add</a></h3>
				<pre>func (me *LibGeometryDefs) Add(d *GeometryDef) (n *GeometryDef)</pre>
				<p>
Adds the specified GeometryDef definition to this LibGeometryDefs, and returns it.
If this LibGeometryDefs already contains a GeometryDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.AddNew">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=7726:7783#L235">AddNew</a></h3>
				<pre>func (me *LibGeometryDefs) AddNew(id string) *GeometryDef</pre>
				<p>
Creates a new GeometryDef definition with the specified Id, adds it to this LibGeometryDefs, and returns it.
If this LibGeometryDefs already contains a GeometryDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.Len">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=7856:7892#L238">Len</a></h3>
				<pre>func (me *LibGeometryDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.New">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=8041:8101#L242">New</a></h3>
				<pre>func (me *LibGeometryDefs) New(id string) (def *GeometryDef)</pre>
				<p>
Creates a new GeometryDef definition with the specified Id and returns it,
but does not add it to this LibGeometryDefs.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.Remove">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=8216:8260#L245">Remove</a></h3>
				<pre>func (me *LibGeometryDefs) Remove(id string)</pre>
				<p>
Removes the GeometryDef with the specified Id from this LibGeometryDefs.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.SyncChanges">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=8603:8643#L250">SyncChanges</a></h3>
				<pre>func (me *LibGeometryDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibGeometryDefs
that need to be picked up. Call this after you have made a number of changes to this LibGeometryDefs
library or its GeometryDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxArticulatedSystemDefs">type <a href="/target/kxarticulatedsystem.gt.go?s=9725:10003#L293">LibKxArticulatedSystemDefs</a></h2>
			<pre>type LibKxArticulatedSystemDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxArticulatedSystemDef
}</pre>
			<p>
A library that contains KxArticulatedSystemDefs associated by their Id.
To create a new LibKxArticulatedSystemDefs library, ONLY use the LibsKxArticulatedSystemDef.New() or LibsKxArticulatedSystemDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxArticulatedSystemDefs.Add">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=10431:10527#L308">Add</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Add(d *KxArticulatedSystemDef) (n *KxArticulatedSystemDef)</pre>
				<p>
Adds the specified KxArticulatedSystemDef definition to this LibKxArticulatedSystemDefs, and returns it.
If this LibKxArticulatedSystemDefs already contains a KxArticulatedSystemDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.AddNew">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=10885:10964#L318">AddNew</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) AddNew(id string) *KxArticulatedSystemDef</pre>
				<p>
Creates a new KxArticulatedSystemDef definition with the specified Id, adds it to this LibKxArticulatedSystemDefs, and returns it.
If this LibKxArticulatedSystemDefs already contains a KxArticulatedSystemDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.Len">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=11037:11084#L321">Len</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.New">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=11255:11337#L325">New</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) New(id string) (def *KxArticulatedSystemDef)</pre>
				<p>
Creates a new KxArticulatedSystemDef definition with the specified Id and returns it,
but does not add it to this LibKxArticulatedSystemDefs.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.Remove">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=11485:11540#L328">Remove</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Remove(id string)</pre>
				<p>
Removes the KxArticulatedSystemDef with the specified Id from this LibKxArticulatedSystemDefs.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.SyncChanges">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=11916:11967#L333">SyncChanges</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibKxArticulatedSystemDefs
that need to be picked up. Call this after you have made a number of changes to this LibKxArticulatedSystemDefs
library or its KxArticulatedSystemDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxJointDefs">type <a href="/target/kxjoint.gt.go?s=4157:4411#L135">LibKxJointDefs</a></h2>
			<pre>type LibKxJointDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxJointDef
}</pre>
			<p>
A library that contains KxJointDefs associated by their Id.
To create a new LibKxJointDefs library, ONLY use the LibsKxJointDef.New() or LibsKxJointDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxJointDefs.Add">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=4743:4803#L150">Add</a></h3>
				<pre>func (me *LibKxJointDefs) Add(d *KxJointDef) (n *KxJointDef)</pre>
				<p>
Adds the specified KxJointDef definition to this LibKxJointDefs, and returns it.
If this LibKxJointDefs already contains a KxJointDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.AddNew">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=5113:5168#L160">AddNew</a></h3>
				<pre>func (me *LibKxJointDefs) AddNew(id string) *KxJointDef</pre>
				<p>
Creates a new KxJointDef definition with the specified Id, adds it to this LibKxJointDefs, and returns it.
If this LibKxJointDefs already contains a KxJointDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.Len">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=5241:5276#L163">Len</a></h3>
				<pre>func (me *LibKxJointDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.New">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=5423:5481#L167">New</a></h3>
				<pre>func (me *LibKxJointDefs) New(id string) (def *KxJointDef)</pre>
				<p>
Creates a new KxJointDef definition with the specified Id and returns it,
but does not add it to this LibKxJointDefs.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.Remove">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=5593:5636#L170">Remove</a></h3>
				<pre>func (me *LibKxJointDefs) Remove(id string)</pre>
				<p>
Removes the KxJointDef with the specified Id from this LibKxJointDefs.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.SyncChanges">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=5976:6015#L175">SyncChanges</a></h3>
				<pre>func (me *LibKxJointDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibKxJointDefs
that need to be picked up. Call this after you have made a number of changes to this LibKxJointDefs
library or its KxJointDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxModelDefs">type <a href="/target/kxmodel.gt.go?s=4549:4803#L149">LibKxModelDefs</a></h2>
			<pre>type LibKxModelDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxModelDef
}</pre>
			<p>
A library that contains KxModelDefs associated by their Id.
To create a new LibKxModelDefs library, ONLY use the LibsKxModelDef.New() or LibsKxModelDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxModelDefs.Add">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5135:5195#L164">Add</a></h3>
				<pre>func (me *LibKxModelDefs) Add(d *KxModelDef) (n *KxModelDef)</pre>
				<p>
Adds the specified KxModelDef definition to this LibKxModelDefs, and returns it.
If this LibKxModelDefs already contains a KxModelDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.AddNew">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5505:5560#L174">AddNew</a></h3>
				<pre>func (me *LibKxModelDefs) AddNew(id string) *KxModelDef</pre>
				<p>
Creates a new KxModelDef definition with the specified Id, adds it to this LibKxModelDefs, and returns it.
If this LibKxModelDefs already contains a KxModelDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.Len">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5633:5668#L177">Len</a></h3>
				<pre>func (me *LibKxModelDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.New">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5815:5873#L181">New</a></h3>
				<pre>func (me *LibKxModelDefs) New(id string) (def *KxModelDef)</pre>
				<p>
Creates a new KxModelDef definition with the specified Id and returns it,
but does not add it to this LibKxModelDefs.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.Remove">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5985:6028#L184">Remove</a></h3>
				<pre>func (me *LibKxModelDefs) Remove(id string)</pre>
				<p>
Removes the KxModelDef with the specified Id from this LibKxModelDefs.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.SyncChanges">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=6368:6407#L189">SyncChanges</a></h3>
				<pre>func (me *LibKxModelDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibKxModelDefs
that need to be picked up. Call this after you have made a number of changes to this LibKxModelDefs
library or its KxModelDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxSceneDefs">type <a href="/target/kxscene.gt.go?s=4517:4771#L136">LibKxSceneDefs</a></h2>
			<pre>type LibKxSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxSceneDef
}</pre>
			<p>
A library that contains KxSceneDefs associated by their Id.
To create a new LibKxSceneDefs library, ONLY use the LibsKxSceneDef.New() or LibsKxSceneDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxSceneDefs.Add">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=5103:5163#L151">Add</a></h3>
				<pre>func (me *LibKxSceneDefs) Add(d *KxSceneDef) (n *KxSceneDef)</pre>
				<p>
Adds the specified KxSceneDef definition to this LibKxSceneDefs, and returns it.
If this LibKxSceneDefs already contains a KxSceneDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.AddNew">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=5473:5528#L161">AddNew</a></h3>
				<pre>func (me *LibKxSceneDefs) AddNew(id string) *KxSceneDef</pre>
				<p>
Creates a new KxSceneDef definition with the specified Id, adds it to this LibKxSceneDefs, and returns it.
If this LibKxSceneDefs already contains a KxSceneDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.Len">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=5601:5636#L164">Len</a></h3>
				<pre>func (me *LibKxSceneDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.New">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=5783:5841#L168">New</a></h3>
				<pre>func (me *LibKxSceneDefs) New(id string) (def *KxSceneDef)</pre>
				<p>
Creates a new KxSceneDef definition with the specified Id and returns it,
but does not add it to this LibKxSceneDefs.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.Remove">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=5953:5996#L171">Remove</a></h3>
				<pre>func (me *LibKxSceneDefs) Remove(id string)</pre>
				<p>
Removes the KxSceneDef with the specified Id from this LibKxSceneDefs.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.SyncChanges">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=6336:6375#L176">SyncChanges</a></h3>
				<pre>func (me *LibKxSceneDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibKxSceneDefs
that need to be picked up. Call this after you have made a number of changes to this LibKxSceneDefs
library or its KxSceneDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibLightDefs">type <a href="/target/light.gt.go?s=5715:5965#L189">LibLightDefs</a></h2>
			<pre>type LibLightDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*LightDef
}</pre>
			<p>
A library that contains LightDefs associated by their Id.
To create a new LibLightDefs library, ONLY use the LibsLightDef.New() or LibsLightDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibLightDefs.Add">func (*LibLightDefs) <a href="/target/light.gt.go?s=6281:6335#L204">Add</a></h3>
				<pre>func (me *LibLightDefs) Add(d *LightDef) (n *LightDef)</pre>
				<p>
Adds the specified LightDef definition to this LibLightDefs, and returns it.
If this LibLightDefs already contains a LightDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibLightDefs.AddNew">func (*LibLightDefs) <a href="/target/light.gt.go?s=6637:6688#L214">AddNew</a></h3>
				<pre>func (me *LibLightDefs) AddNew(id string) *LightDef</pre>
				<p>
Creates a new LightDef definition with the specified Id, adds it to this LibLightDefs, and returns it.
If this LibLightDefs already contains a LightDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibLightDefs.Len">func (*LibLightDefs) <a href="/target/light.gt.go?s=6761:6794#L217">Len</a></h3>
				<pre>func (me *LibLightDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibLightDefs.New">func (*LibLightDefs) <a href="/target/light.gt.go?s=6937:6991#L221">New</a></h3>
				<pre>func (me *LibLightDefs) New(id string) (def *LightDef)</pre>
				<p>
Creates a new LightDef definition with the specified Id and returns it,
but does not add it to this LibLightDefs.
</p>

				
				
			
				
				<h3 id="LibLightDefs.Remove">func (*LibLightDefs) <a href="/target/light.gt.go?s=7097:7138#L224">Remove</a></h3>
				<pre>func (me *LibLightDefs) Remove(id string)</pre>
				<p>
Removes the LightDef with the specified Id from this LibLightDefs.
</p>

				
				
			
				
				<h3 id="LibLightDefs.SyncChanges">func (*LibLightDefs) <a href="/target/light.gt.go?s=7472:7509#L229">SyncChanges</a></h3>
				<pre>func (me *LibLightDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibLightDefs
that need to be picked up. Call this after you have made a number of changes to this LibLightDefs
library or its LightDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibNodeDefs">type <a href="/target/node.gt.go?s=3701:3949#L127">LibNodeDefs</a></h2>
			<pre>type LibNodeDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*NodeDef
}</pre>
			<p>
A library that contains NodeDefs associated by their Id.
To create a new LibNodeDefs library, ONLY use the LibsNodeDef.New() or LibsNodeDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibNodeDefs.Add">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4257:4308#L142">Add</a></h3>
				<pre>func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</pre>
				<p>
Adds the specified NodeDef definition to this LibNodeDefs, and returns it.
If this LibNodeDefs already contains a NodeDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.AddNew">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4606:4655#L152">AddNew</a></h3>
				<pre>func (me *LibNodeDefs) AddNew(id string) *NodeDef</pre>
				<p>
Creates a new NodeDef definition with the specified Id, adds it to this LibNodeDefs, and returns it.
If this LibNodeDefs already contains a NodeDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Len">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4728:4760#L155">Len</a></h3>
				<pre>func (me *LibNodeDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibNodeDefs.New">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4901:4953#L159">New</a></h3>
				<pre>func (me *LibNodeDefs) New(id string) (def *NodeDef)</pre>
				<p>
Creates a new NodeDef definition with the specified Id and returns it,
but does not add it to this LibNodeDefs.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Remove">func (*LibNodeDefs) <a href="/target/node.gt.go?s=5056:5096#L162">Remove</a></h3>
				<pre>func (me *LibNodeDefs) Remove(id string)</pre>
				<p>
Removes the NodeDef with the specified Id from this LibNodeDefs.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.SyncChanges">func (*LibNodeDefs) <a href="/target/node.gt.go?s=5427:5463#L167">SyncChanges</a></h3>
				<pre>func (me *LibNodeDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibNodeDefs
that need to be picked up. Call this after you have made a number of changes to this LibNodeDefs
library or its NodeDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxForceFieldDefs">type <a href="/target/pxforcefield.gt.go?s=3194:3458#L98">LibPxForceFieldDefs</a></h2>
			<pre>type LibPxForceFieldDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxForceFieldDef
}</pre>
			<p>
A library that contains PxForceFieldDefs associated by their Id.
To create a new LibPxForceFieldDefs library, ONLY use the LibsPxForceFieldDef.New() or LibsPxForceFieldDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxForceFieldDefs.Add">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=3830:3905#L113">Add</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Add(d *PxForceFieldDef) (n *PxForceFieldDef)</pre>
				<p>
Adds the specified PxForceFieldDef definition to this LibPxForceFieldDefs, and returns it.
If this LibPxForceFieldDefs already contains a PxForceFieldDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.AddNew">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=4235:4300#L123">AddNew</a></h3>
				<pre>func (me *LibPxForceFieldDefs) AddNew(id string) *PxForceFieldDef</pre>
				<p>
Creates a new PxForceFieldDef definition with the specified Id, adds it to this LibPxForceFieldDefs, and returns it.
If this LibPxForceFieldDefs already contains a PxForceFieldDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.Len">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=4373:4413#L126">Len</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.New">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=4570:4638#L130">New</a></h3>
				<pre>func (me *LibPxForceFieldDefs) New(id string) (def *PxForceFieldDef)</pre>
				<p>
Creates a new PxForceFieldDef definition with the specified Id and returns it,
but does not add it to this LibPxForceFieldDefs.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.Remove">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=4765:4813#L133">Remove</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Remove(id string)</pre>
				<p>
Removes the PxForceFieldDef with the specified Id from this LibPxForceFieldDefs.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.SyncChanges">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=5168:5212#L138">SyncChanges</a></h3>
				<pre>func (me *LibPxForceFieldDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibPxForceFieldDefs
that need to be picked up. Call this after you have made a number of changes to this LibPxForceFieldDefs
library or its PxForceFieldDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxMaterialDefs">type <a href="/target/pxmaterial.gt.go?s=3353:3613#L106">LibPxMaterialDefs</a></h2>
			<pre>type LibPxMaterialDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxMaterialDef
}</pre>
			<p>
A library that contains PxMaterialDefs associated by their Id.
To create a new LibPxMaterialDefs library, ONLY use the LibsPxMaterialDef.New() or LibsPxMaterialDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxMaterialDefs.Add">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=3969:4038#L121">Add</a></h3>
				<pre>func (me *LibPxMaterialDefs) Add(d *PxMaterialDef) (n *PxMaterialDef)</pre>
				<p>
Adds the specified PxMaterialDef definition to this LibPxMaterialDefs, and returns it.
If this LibPxMaterialDefs already contains a PxMaterialDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.AddNew">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=4360:4421#L131">AddNew</a></h3>
				<pre>func (me *LibPxMaterialDefs) AddNew(id string) *PxMaterialDef</pre>
				<p>
Creates a new PxMaterialDef definition with the specified Id, adds it to this LibPxMaterialDefs, and returns it.
If this LibPxMaterialDefs already contains a PxMaterialDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.Len">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=4494:4532#L134">Len</a></h3>
				<pre>func (me *LibPxMaterialDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.New">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=4685:4749#L138">New</a></h3>
				<pre>func (me *LibPxMaterialDefs) New(id string) (def *PxMaterialDef)</pre>
				<p>
Creates a new PxMaterialDef definition with the specified Id and returns it,
but does not add it to this LibPxMaterialDefs.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.Remove">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=4870:4916#L141">Remove</a></h3>
				<pre>func (me *LibPxMaterialDefs) Remove(id string)</pre>
				<p>
Removes the PxMaterialDef with the specified Id from this LibPxMaterialDefs.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.SyncChanges">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=5265:5307#L146">SyncChanges</a></h3>
				<pre>func (me *LibPxMaterialDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibPxMaterialDefs
that need to be picked up. Call this after you have made a number of changes to this LibPxMaterialDefs
library or its PxMaterialDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxModelDefs">type <a href="/target/pxmodel.gt.go?s=4273:4527#L116">LibPxModelDefs</a></h2>
			<pre>type LibPxModelDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxModelDef
}</pre>
			<p>
A library that contains PxModelDefs associated by their Id.
To create a new LibPxModelDefs library, ONLY use the LibsPxModelDef.New() or LibsPxModelDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxModelDefs.Add">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=4859:4919#L131">Add</a></h3>
				<pre>func (me *LibPxModelDefs) Add(d *PxModelDef) (n *PxModelDef)</pre>
				<p>
Adds the specified PxModelDef definition to this LibPxModelDefs, and returns it.
If this LibPxModelDefs already contains a PxModelDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.AddNew">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=5229:5284#L141">AddNew</a></h3>
				<pre>func (me *LibPxModelDefs) AddNew(id string) *PxModelDef</pre>
				<p>
Creates a new PxModelDef definition with the specified Id, adds it to this LibPxModelDefs, and returns it.
If this LibPxModelDefs already contains a PxModelDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.Len">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=5357:5392#L144">Len</a></h3>
				<pre>func (me *LibPxModelDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.New">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=5539:5597#L148">New</a></h3>
				<pre>func (me *LibPxModelDefs) New(id string) (def *PxModelDef)</pre>
				<p>
Creates a new PxModelDef definition with the specified Id and returns it,
but does not add it to this LibPxModelDefs.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.Remove">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=5709:5752#L151">Remove</a></h3>
				<pre>func (me *LibPxModelDefs) Remove(id string)</pre>
				<p>
Removes the PxModelDef with the specified Id from this LibPxModelDefs.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.SyncChanges">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=6092:6131#L156">SyncChanges</a></h3>
				<pre>func (me *LibPxModelDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibPxModelDefs
that need to be picked up. Call this after you have made a number of changes to this LibPxModelDefs
library or its PxModelDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxSceneDefs">type <a href="/target/pxscene.gt.go?s=3530:3784#L110">LibPxSceneDefs</a></h2>
			<pre>type LibPxSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxSceneDef
}</pre>
			<p>
A library that contains PxSceneDefs associated by their Id.
To create a new LibPxSceneDefs library, ONLY use the LibsPxSceneDef.New() or LibsPxSceneDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxSceneDefs.Add">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4116:4176#L125">Add</a></h3>
				<pre>func (me *LibPxSceneDefs) Add(d *PxSceneDef) (n *PxSceneDef)</pre>
				<p>
Adds the specified PxSceneDef definition to this LibPxSceneDefs, and returns it.
If this LibPxSceneDefs already contains a PxSceneDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.AddNew">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4486:4541#L135">AddNew</a></h3>
				<pre>func (me *LibPxSceneDefs) AddNew(id string) *PxSceneDef</pre>
				<p>
Creates a new PxSceneDef definition with the specified Id, adds it to this LibPxSceneDefs, and returns it.
If this LibPxSceneDefs already contains a PxSceneDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.Len">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4614:4649#L138">Len</a></h3>
				<pre>func (me *LibPxSceneDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.New">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4796:4854#L142">New</a></h3>
				<pre>func (me *LibPxSceneDefs) New(id string) (def *PxSceneDef)</pre>
				<p>
Creates a new PxSceneDef definition with the specified Id and returns it,
but does not add it to this LibPxSceneDefs.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.Remove">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4966:5009#L145">Remove</a></h3>
				<pre>func (me *LibPxSceneDefs) Remove(id string)</pre>
				<p>
Removes the PxSceneDef with the specified Id from this LibPxSceneDefs.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.SyncChanges">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=5349:5388#L150">SyncChanges</a></h3>
				<pre>func (me *LibPxSceneDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibPxSceneDefs
that need to be picked up. Call this after you have made a number of changes to this LibPxSceneDefs
library or its PxSceneDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibVisualSceneDefs">type <a href="/target/visualscene.gt.go?s=4803:5065#L150">LibVisualSceneDefs</a></h2>
			<pre>type LibVisualSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying hash-table. NOTE -- this is for easier read-access and range-iteration:</span>
    <span class="comment">//	DO NOT write to M, instead use the Add(), AddNew(), Remove() methods ONLY or bugs WILL ensue.</span>
    M map[string]*VisualSceneDef
}</pre>
			<p>
A library that contains VisualSceneDefs associated by their Id.
To create a new LibVisualSceneDefs library, ONLY use the LibsVisualSceneDef.New() or LibsVisualSceneDef.AddNew() methods.
</p>


			

			

			

			

			
				
				<h3 id="LibVisualSceneDefs.Add">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=5429:5501#L165">Add</a></h3>
				<pre>func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</pre>
				<p>
Adds the specified VisualSceneDef definition to this LibVisualSceneDefs, and returns it.
If this LibVisualSceneDefs already contains a VisualSceneDef definition with the same Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.AddNew">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=5827:5890#L175">AddNew</a></h3>
				<pre>func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</pre>
				<p>
Creates a new VisualSceneDef definition with the specified Id, adds it to this LibVisualSceneDefs, and returns it.
If this LibVisualSceneDefs already contains a VisualSceneDef definition with the specified Id, does nothing and returns nil.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Len">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=5963:6002#L178">Len</a></h3>
				<pre>func (me *LibVisualSceneDefs) Len() int</pre>
				<p>
Convenience short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.New">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=6157:6223#L182">New</a></h3>
				<pre>func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</pre>
				<p>
Creates a new VisualSceneDef definition with the specified Id and returns it,
but does not add it to this LibVisualSceneDefs.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Remove">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=6347:6394#L185">Remove</a></h3>
				<pre>func (me *LibVisualSceneDefs) Remove(id string)</pre>
				<p>
Removes the VisualSceneDef with the specified Id from this LibVisualSceneDefs.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.SyncChanges">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=6746:6789#L190">SyncChanges</a></h3>
				<pre>func (me *LibVisualSceneDefs) SyncChanges()</pre>
				<p>
Signals to the core package (or your custom package) that changes have been made to this LibVisualSceneDefs
that need to be picked up. Call this after you have made a number of changes to this LibVisualSceneDefs
library or its VisualSceneDef definitions. Also called by the global SyncChanges() function.
</p>

				
				
			
		
			
			
			<h2 id="LibsAnimationClipDef">type <a href="/target/animationclip.gt.go?s=2641:2699#L83">LibsAnimationClipDef</a></h2>
			<pre>type LibsAnimationClipDef map[string]*LibAnimationClipDefs</pre>
			<p>
The underlying type of the global AllAnimationClipDefLibs variable:
a hash-table that contains LibAnimationClipDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsAnimationClipDef.AddNew">func (LibsAnimationClipDef) <a href="/target/animationclip.gt.go?s=2957:3033#L87">AddNew</a></h3>
				<pre>func (me LibsAnimationClipDef) AddNew(id string) (lib *LibAnimationClipDefs)</pre>
				<p>
Creates a new LibAnimationClipDefs library with the specified Id, adds it to this LibsAnimationClipDef, and returns it.
If this LibsAnimationClipDef already contains a LibAnimationClipDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsAnimationDef">type <a href="/target/animation.gt.go?s=3931:3981#L121">LibsAnimationDef</a></h2>
			<pre>type LibsAnimationDef map[string]*LibAnimationDefs</pre>
			<p>
The underlying type of the global AllAnimationDefLibs variable:
a hash-table that contains LibAnimationDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsAnimationDef.AddNew">func (LibsAnimationDef) <a href="/target/animation.gt.go?s=4223:4291#L125">AddNew</a></h3>
				<pre>func (me LibsAnimationDef) AddNew(id string) (lib *LibAnimationDefs)</pre>
				<p>
Creates a new LibAnimationDefs library with the specified Id, adds it to this LibsAnimationDef, and returns it.
If this LibsAnimationDef already contains a LibAnimationDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsCameraDef">type <a href="/target/camera.gt.go?s=3411:3455#L123">LibsCameraDef</a></h2>
			<pre>type LibsCameraDef map[string]*LibCameraDefs</pre>
			<p>
The underlying type of the global AllCameraDefLibs variable:
a hash-table that contains LibCameraDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsCameraDef.AddNew">func (LibsCameraDef) <a href="/target/camera.gt.go?s=3685:3747#L127">AddNew</a></h3>
				<pre>func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</pre>
				<p>
Creates a new LibCameraDefs library with the specified Id, adds it to this LibsCameraDef, and returns it.
If this LibsCameraDef already contains a LibCameraDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsControllerDef">type <a href="/target/controller.gt.go?s=4337:4389#L140">LibsControllerDef</a></h2>
			<pre>type LibsControllerDef map[string]*LibControllerDefs</pre>
			<p>
The underlying type of the global AllControllerDefLibs variable:
a hash-table that contains LibControllerDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsControllerDef.AddNew">func (LibsControllerDef) <a href="/target/controller.gt.go?s=4635:4705#L144">AddNew</a></h3>
				<pre>func (me LibsControllerDef) AddNew(id string) (lib *LibControllerDefs)</pre>
				<p>
Creates a new LibControllerDefs library with the specified Id, adds it to this LibsControllerDef, and returns it.
If this LibsControllerDef already contains a LibControllerDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsFormulaDef">type <a href="/target/formula.gt.go?s=2746:2792#L104">LibsFormulaDef</a></h2>
			<pre>type LibsFormulaDef map[string]*LibFormulaDefs</pre>
			<p>
The underlying type of the global AllFormulaDefLibs variable:
a hash-table that contains LibFormulaDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsFormulaDef.AddNew">func (LibsFormulaDef) <a href="/target/formula.gt.go?s=3026:3090#L108">AddNew</a></h3>
				<pre>func (me LibsFormulaDef) AddNew(id string) (lib *LibFormulaDefs)</pre>
				<p>
Creates a new LibFormulaDefs library with the specified Id, adds it to this LibsFormulaDef, and returns it.
If this LibsFormulaDef already contains a LibFormulaDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxEffectDef">type <a href="/target/fxeffect.gt.go?s=16636:16684#L469">LibsFxEffectDef</a></h2>
			<pre>type LibsFxEffectDef map[string]*LibFxEffectDefs</pre>
			<p>
The underlying type of the global AllFxEffectDefLibs variable:
a hash-table that contains LibFxEffectDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxEffectDef.AddNew">func (LibsFxEffectDef) <a href="/target/fxeffect.gt.go?s=16922:16988#L473">AddNew</a></h3>
				<pre>func (me LibsFxEffectDef) AddNew(id string) (lib *LibFxEffectDefs)</pre>
				<p>
Creates a new LibFxEffectDefs library with the specified Id, adds it to this LibsFxEffectDef, and returns it.
If this LibsFxEffectDef already contains a LibFxEffectDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxImageDef">type <a href="/target/fximage.gt.go?s=12722:12768#L339">LibsFxImageDef</a></h2>
			<pre>type LibsFxImageDef map[string]*LibFxImageDefs</pre>
			<p>
The underlying type of the global AllFxImageDefLibs variable:
a hash-table that contains LibFxImageDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxImageDef.AddNew">func (LibsFxImageDef) <a href="/target/fximage.gt.go?s=13002:13066#L343">AddNew</a></h3>
				<pre>func (me LibsFxImageDef) AddNew(id string) (lib *LibFxImageDefs)</pre>
				<p>
Creates a new LibFxImageDefs library with the specified Id, adds it to this LibsFxImageDef, and returns it.
If this LibsFxImageDef already contains a LibFxImageDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxMaterialDef">type <a href="/target/fxmaterial.gt.go?s=3205:3257#L100">LibsFxMaterialDef</a></h2>
			<pre>type LibsFxMaterialDef map[string]*LibFxMaterialDefs</pre>
			<p>
The underlying type of the global AllFxMaterialDefLibs variable:
a hash-table that contains LibFxMaterialDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxMaterialDef.AddNew">func (LibsFxMaterialDef) <a href="/target/fxmaterial.gt.go?s=3503:3573#L104">AddNew</a></h3>
				<pre>func (me LibsFxMaterialDef) AddNew(id string) (lib *LibFxMaterialDefs)</pre>
				<p>
Creates a new LibFxMaterialDefs library with the specified Id, adds it to this LibsFxMaterialDef, and returns it.
If this LibsFxMaterialDef already contains a LibFxMaterialDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsGeometryDef">type <a href="/target/geometry.gt.go?s=6036:6084#L190">LibsGeometryDef</a></h2>
			<pre>type LibsGeometryDef map[string]*LibGeometryDefs</pre>
			<p>
The underlying type of the global AllGeometryDefLibs variable:
a hash-table that contains LibGeometryDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsGeometryDef.AddNew">func (LibsGeometryDef) <a href="/target/geometry.gt.go?s=6322:6388#L194">AddNew</a></h3>
				<pre>func (me LibsGeometryDef) AddNew(id string) (lib *LibGeometryDefs)</pre>
				<p>
Creates a new LibGeometryDefs library with the specified Id, adds it to this LibsGeometryDef, and returns it.
If this LibsGeometryDef already contains a LibGeometryDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxArticulatedSystemDef">type <a href="/target/kxarticulatedsystem.gt.go?s=8843:8913#L273">LibsKxArticulatedSystemDef</a></h2>
			<pre>type LibsKxArticulatedSystemDef map[string]*LibKxArticulatedSystemDefs</pre>
			<p>
The underlying type of the global AllKxArticulatedSystemDefLibs variable:
a hash-table that contains LibKxArticulatedSystemDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxArticulatedSystemDef.AddNew">func (LibsKxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=9195:9283#L277">AddNew</a></h3>
				<pre>func (me LibsKxArticulatedSystemDef) AddNew(id string) (lib *LibKxArticulatedSystemDefs)</pre>
				<p>
Creates a new LibKxArticulatedSystemDefs library with the specified Id, adds it to this LibsKxArticulatedSystemDef, and returns it.
If this LibsKxArticulatedSystemDef already contains a LibKxArticulatedSystemDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxJointDef">type <a href="/target/kxjoint.gt.go?s=3455:3501#L115">LibsKxJointDef</a></h2>
			<pre>type LibsKxJointDef map[string]*LibKxJointDefs</pre>
			<p>
The underlying type of the global AllKxJointDefLibs variable:
a hash-table that contains LibKxJointDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxJointDef.AddNew">func (LibsKxJointDef) <a href="/target/kxjoint.gt.go?s=3735:3799#L119">AddNew</a></h3>
				<pre>func (me LibsKxJointDef) AddNew(id string) (lib *LibKxJointDefs)</pre>
				<p>
Creates a new LibKxJointDefs library with the specified Id, adds it to this LibsKxJointDef, and returns it.
If this LibsKxJointDef already contains a LibKxJointDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxModelDef">type <a href="/target/kxmodel.gt.go?s=3847:3893#L129">LibsKxModelDef</a></h2>
			<pre>type LibsKxModelDef map[string]*LibKxModelDefs</pre>
			<p>
The underlying type of the global AllKxModelDefLibs variable:
a hash-table that contains LibKxModelDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxModelDef.AddNew">func (LibsKxModelDef) <a href="/target/kxmodel.gt.go?s=4127:4191#L133">AddNew</a></h3>
				<pre>func (me LibsKxModelDef) AddNew(id string) (lib *LibKxModelDefs)</pre>
				<p>
Creates a new LibKxModelDefs library with the specified Id, adds it to this LibsKxModelDef, and returns it.
If this LibsKxModelDef already contains a LibKxModelDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxSceneDef">type <a href="/target/kxscene.gt.go?s=3815:3861#L116">LibsKxSceneDef</a></h2>
			<pre>type LibsKxSceneDef map[string]*LibKxSceneDefs</pre>
			<p>
The underlying type of the global AllKxSceneDefLibs variable:
a hash-table that contains LibKxSceneDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxSceneDef.AddNew">func (LibsKxSceneDef) <a href="/target/kxscene.gt.go?s=4095:4159#L120">AddNew</a></h3>
				<pre>func (me LibsKxSceneDef) AddNew(id string) (lib *LibKxSceneDefs)</pre>
				<p>
Creates a new LibKxSceneDefs library with the specified Id, adds it to this LibsKxSceneDef, and returns it.
If this LibsKxSceneDef already contains a LibKxSceneDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsLightDef">type <a href="/target/light.gt.go?s=5043:5085#L169">LibsLightDef</a></h2>
			<pre>type LibsLightDef map[string]*LibLightDefs</pre>
			<p>
The underlying type of the global AllLightDefLibs variable:
a hash-table that contains LibLightDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsLightDef.AddNew">func (LibsLightDef) <a href="/target/light.gt.go?s=5311:5371#L173">AddNew</a></h3>
				<pre>func (me LibsLightDef) AddNew(id string) (lib *LibLightDefs)</pre>
				<p>
Creates a new LibLightDefs library with the specified Id, adds it to this LibsLightDef, and returns it.
If this LibsLightDef already contains a LibLightDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsNodeDef">type <a href="/target/node.gt.go?s=3044:3084#L107">LibsNodeDef</a></h2>
			<pre>type LibsNodeDef map[string]*LibNodeDefs</pre>
			<p>
The underlying type of the global AllNodeDefLibs variable:
a hash-table that contains LibNodeDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsNodeDef.AddNew">func (LibsNodeDef) <a href="/target/node.gt.go?s=3306:3364#L111">AddNew</a></h3>
				<pre>func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</pre>
				<p>
Creates a new LibNodeDefs library with the specified Id, adds it to this LibsNodeDef, and returns it.
If this LibsNodeDef already contains a LibNodeDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxForceFieldDef">type <a href="/target/pxforcefield.gt.go?s=2417:2473#L78">LibsPxForceFieldDef</a></h2>
			<pre>type LibsPxForceFieldDef map[string]*LibPxForceFieldDefs</pre>
			<p>
The underlying type of the global AllPxForceFieldDefLibs variable:
a hash-table that contains LibPxForceFieldDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxForceFieldDef.AddNew">func (LibsPxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=2727:2801#L82">AddNew</a></h3>
				<pre>func (me LibsPxForceFieldDef) AddNew(id string) (lib *LibPxForceFieldDefs)</pre>
				<p>
Creates a new LibPxForceFieldDefs library with the specified Id, adds it to this LibsPxForceFieldDef, and returns it.
If this LibsPxForceFieldDef already contains a LibPxForceFieldDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxMaterialDef">type <a href="/target/pxmaterial.gt.go?s=2606:2658#L86">LibsPxMaterialDef</a></h2>
			<pre>type LibsPxMaterialDef map[string]*LibPxMaterialDefs</pre>
			<p>
The underlying type of the global AllPxMaterialDefLibs variable:
a hash-table that contains LibPxMaterialDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxMaterialDef.AddNew">func (LibsPxMaterialDef) <a href="/target/pxmaterial.gt.go?s=2904:2974#L90">AddNew</a></h3>
				<pre>func (me LibsPxMaterialDef) AddNew(id string) (lib *LibPxMaterialDefs)</pre>
				<p>
Creates a new LibPxMaterialDefs library with the specified Id, adds it to this LibsPxMaterialDef, and returns it.
If this LibsPxMaterialDef already contains a LibPxMaterialDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxModelDef">type <a href="/target/pxmodel.gt.go?s=3571:3617#L96">LibsPxModelDef</a></h2>
			<pre>type LibsPxModelDef map[string]*LibPxModelDefs</pre>
			<p>
The underlying type of the global AllPxModelDefLibs variable:
a hash-table that contains LibPxModelDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxModelDef.AddNew">func (LibsPxModelDef) <a href="/target/pxmodel.gt.go?s=3851:3915#L100">AddNew</a></h3>
				<pre>func (me LibsPxModelDef) AddNew(id string) (lib *LibPxModelDefs)</pre>
				<p>
Creates a new LibPxModelDefs library with the specified Id, adds it to this LibsPxModelDef, and returns it.
If this LibsPxModelDef already contains a LibPxModelDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxSceneDef">type <a href="/target/pxscene.gt.go?s=2828:2874#L90">LibsPxSceneDef</a></h2>
			<pre>type LibsPxSceneDef map[string]*LibPxSceneDefs</pre>
			<p>
The underlying type of the global AllPxSceneDefLibs variable:
a hash-table that contains LibPxSceneDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxSceneDef.AddNew">func (LibsPxSceneDef) <a href="/target/pxscene.gt.go?s=3108:3172#L94">AddNew</a></h3>
				<pre>func (me LibsPxSceneDef) AddNew(id string) (lib *LibPxSceneDefs)</pre>
				<p>
Creates a new LibPxSceneDefs library with the specified Id, adds it to this LibsPxSceneDef, and returns it.
If this LibsPxSceneDef already contains a LibPxSceneDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LibsVisualSceneDef">type <a href="/target/visualscene.gt.go?s=4041:4095#L130">LibsVisualSceneDef</a></h2>
			<pre>type LibsVisualSceneDef map[string]*LibVisualSceneDefs</pre>
			<p>
The underlying type of the global AllVisualSceneDefLibs variable:
a hash-table that contains LibVisualSceneDefs libraries associated by their Id.
</p>


			

			

			

			

			
				
				<h3 id="LibsVisualSceneDef.AddNew">func (LibsVisualSceneDef) <a href="/target/visualscene.gt.go?s=4345:4417#L134">AddNew</a></h3>
				<pre>func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</pre>
				<p>
Creates a new LibVisualSceneDefs library with the specified Id, adds it to this LibsVisualSceneDef, and returns it.
If this LibsVisualSceneDef already contains a LibVisualSceneDefs library with the specified Id, does nothing and returns nil.
</p>

				
				
			
		
			
			
			<h2 id="LightAmbient">type <a href="/target/light.gt.go?s=151:200#L1">LightAmbient</a></h2>
			<pre>type LightAmbient struct {
    <span class="comment">//	Color</span>
    LightBase
}</pre>
			<p>
Describes an ambient light source.
An ambient light is one that lights everything evenly, regardless of location or orientation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightAttenuation">type <a href="/target/light.gt.go?s=266:464#L1">LightAttenuation</a></h2>
			<pre>type LightAttenuation struct {
    <span class="comment">//	Constant light attenuation. Defaults to 1.</span>
    Constant SidFloat
    <span class="comment">//	Linear light attenuation.</span>
    Linear SidFloat
    <span class="comment">//	Quadratic light attenuation.</span>
    Quadratic SidFloat
}</pre>
			<p>
Describes how the intensity of a light source is attenuated.
</p>


			

			

			

			
				
				<h3 id="NewLightAttenuation">func <a href="/target/light.gt.go?s=481:530#L11">NewLightAttenuation</a></h3>
				<pre>func NewLightAttenuation() (me *LightAttenuation)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="LightBase">type <a href="/target/light.gt.go?s=663:771#L18">LightBase</a></h2>
			<pre>type LightBase struct {
    <span class="comment">//	Three floating-point numbers specifying the color of this light.</span>
    Color Float3
}</pre>
			<p>
Contains three floating-point numbers specifying the color of a light.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightDef">type <a href="/target/light.gt.go?s=2685:3175#L76">LightDef</a></h2>
			<pre>type LightDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile. At least and at most one of its fields should ever be set.</span>
    TC struct {
        <span class="comment">//	If set, this light declares an ambient light.</span>
        Ambient *LightAmbient
        <span class="comment">//	If set, this light declares a directional light.</span>
        Directional *LightDirectional
        <span class="comment">//	If set, this light declares a point light.</span>
        Point *LightPoint
        <span class="comment">//	If set, this light declares a spot light.</span>
        Spot *LightSpot
    }
}</pre>
			<p>
Declares a light source that illuminates a scene.
</p>


			

			

			

			

			
				
				<h3 id="LightDef.Init">func (*LightDef) <a href="/target/light.gt.go?s=3195:3221#L95">Init</a></h3>
				<pre>func (me *LightDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="LightDef.NewInst">func (*LightDef) <a href="/target/light.gt.go?s=3817:3864#L122">NewInst</a></h3>
				<pre>func (me *LightDef) NewInst() (inst *LightInst)</pre>
				<p>
Creates and returns a new LightInst instance referencing this LightDef definition.
</p>

				
				
			
		
			
			
			<h2 id="LightDirectional">type <a href="/target/light.gt.go?s=1135:1188#L27">LightDirectional</a></h2>
			<pre>type LightDirectional struct {
    <span class="comment">//	Color</span>
    LightBase
}</pre>
			<p>
Describes a directional light source.
A directional light is one that lights everything from the same direction, regardless of location.
The light&#39;s default direction vector in local coordinates is [0,0,-1], pointing down the negative z axis.
The actual direction of the light is defined by the transform of the node where the light is instantiated.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightInst">type <a href="/target/light.gt.go?s=3261:3525#L99">LightInst</a></h2>
			<pre>type LightInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *LightDef
}</pre>
			<p>
Instantiates a light resource.
</p>


			

			

			

			

			
				
				<h3 id="LightInst.EnsureDef">func (*LightInst) <a href="/target/light.gt.go?s=4119:4161#L132">EnsureDef</a></h3>
				<pre>func (me *LightInst) EnsureDef() *LightDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct LightDef
according to the current me.DefRef value (by searching AllLightDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="LightInst.Init">func (*LightInst) <a href="/target/light.gt.go?s=3545:3572#L108">Init</a></h3>
				<pre>func (me *LightInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="LightPoint">type <a href="/target/light.gt.go?s=1412:1592#L35">LightPoint</a></h2>
			<pre>type LightPoint struct {
    <span class="comment">//	Color</span>
    LightBase
    <span class="comment">//	The intensity of a point light source is attenuated as the distance to the light source increases.</span>
    Attenuation LightAttenuation
}</pre>
			<p>
Describes a point light source.
A point light source radiates light in all directions from a known location in space.
The position of the light is defined by the transform of the node in which it is instantiated.
</p>


			

			

			

			
				
				<h3 id="NewLightPoint">func <a href="/target/light.gt.go?s=1609:1646#L43">NewLightPoint</a></h3>
				<pre>func NewLightPoint() (me *LightPoint)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="LightSpot">type <a href="/target/light.gt.go?s=2070:2490#L53">LightSpot</a></h2>
			<pre>type LightSpot struct {
    <span class="comment">//	Color</span>
    LightBase
    <span class="comment">//	 The intensity of a spot light is also attenuated as the distance to the light source increases.</span>
    Attenuation LightAttenuation
    <span class="comment">//	The light&#39;s intensity is also attenuated as the radiation angle increases away from the direction of the light source.</span>
    Falloff struct {
        <span class="comment">//	Fall-off angle. Defaults to 180.</span>
        Angle SidFloat
        <span class="comment">//	Fall-off exponent.</span>
        Exponent SidFloat
    }
}</pre>
			<p>
Describes a spot light source.
A spot light source radiates light in one direction in a cone shape from a known location in space.
The light&#39;s default direction vector in local coordinates is [0,0,-1], pointing down the negative z axis.
The actual direction of the light is defined by the transform of the node in which the light is instantiated.
</p>


			

			

			

			
				
				<h3 id="NewLightSpot">func <a href="/target/light.gt.go?s=2507:2542#L68">NewLightSpot</a></h3>
				<pre>func NewLightSpot() (me *LightSpot)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="MaterialBinding">type <a href="/target/common.go?s=7338:7608#L213">MaterialBinding</a></h2>
			<pre>type MaterialBinding struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Targets for animation</span>
    Params []*Param
    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	References to the materials included in this material binding.</span>
        Materials []*FxMaterialInst
    }
}</pre>
			<p>
Binds a specific material to a piece of geometry,
binding varying and uniform parameters at the same time.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshData">type <a href="/target/meshdata.go?s=1164:1387#L40">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">//	Vertex positions</span>
    Positions []MeshVertAtt3
    <span class="comment">//	Vertex texture coordinates</span>
    TexCoords []MeshVertAtt2
    <span class="comment">//	Vertex normals</span>
    Normals []MeshVertAtt3
    <span class="comment">//	Indexed triangle definitions</span>
    Faces []MeshFace3
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="NewMeshData">func <a href="/target/meshdata.go?s=1443:1476#L52">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
				
				<h3 id="MeshData.AddFaces">func (*MeshData) <a href="/target/meshdata.go?s=1554:1602#L58">AddFaces</a></h3>
				<pre>func (me *MeshData) AddFaces(faces ...MeshFace3)</pre>
				<p>
Adds all specified Faces to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddNormals">func (*MeshData) <a href="/target/meshdata.go?s=1865:1920#L68">AddNormals</a></h3>
				<pre>func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</pre>
				<p>
Adds all the specified Normals to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddPositions">func (*MeshData) <a href="/target/meshdata.go?s=1697:1756#L63">AddPositions</a></h3>
				<pre>func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</pre>
				<p>
Adds all specified Positions to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddTexCoords">func (*MeshData) <a href="/target/meshdata.go?s=2025:2084#L73">AddTexCoords</a></h3>
				<pre>func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</pre>
				<p>
Adds all the specified TexCoords to this MeshData.
</p>

				
				
			
		
			
			
			<h2 id="MeshFace3">type <a href="/target/meshdata.go?s=140:166#L1">MeshFace3</a></h2>
			<pre>type MeshFace3 [3]MeshVert</pre>
			<p>
Represents an indexed triangle.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/meshdata.go?s=41:103#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Temporary concoction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRaw">type <a href="/target/meshdata.go?s=255:400#L1">MeshRaw</a></h2>
			<pre>type MeshRaw struct {
    <span class="comment">//	Raw vertices</span>
    MeshVerts []float32
    <span class="comment">//	Vertex indices</span>
    Indices []uint32
    <span class="comment">//	Raw face definitions</span>
    Faces []*MeshRawFace
}</pre>
			<p>
Represents semi-processed loaded mesh data &#34;almost ready&#34; to core.Mesh.GpuUpload().
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRawFace">type <a href="/target/meshdata.go?s=450:532#L10">MeshRawFace</a></h2>
			<pre>type MeshRawFace struct {
    <span class="comment">//	Indices of the triangle corners</span>
    Entries [3]uint32
}</pre>
			<p>
Represents a triangle face inside a MeshRaw.
</p>


			

			

			

			
				
				<h3 id="NewMeshRawFace">func <a href="/target/meshdata.go?s=591:630#L16">NewMeshRawFace</a></h3>
				<pre>func NewMeshRawFace() (me *MeshRawFace)</pre>
				<p>
Initializes and returns a new *MeshRawFace* instance.
</p>

				
			

			
		
			
			
			<h2 id="MeshVert">type <a href="/target/meshdata.go?s=698:885#L22">MeshVert</a></h2>
			<pre>type MeshVert struct {
    <span class="comment">//	Index of the vertex position</span>
    PosIndex uint32

    <span class="comment">//	Index of the texture-coordinate.</span>
    TexCoordIndex uint32

    <span class="comment">//	Index of the vertex normal.</span>
    NormalIndex uint32
}</pre>
			<p>
Represents an indexed vertex.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt2">type <a href="/target/meshdata.go?s=974:1002#L34">MeshVertAtt2</a></h2>
			<pre>type MeshVertAtt2 [2]float32</pre>
			<p>
Represents a 2-component vertex attribute (such as for example texture-coordinates)
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt3">type <a href="/target/meshdata.go?s=1086:1114#L37">MeshVertAtt3</a></h2>
			<pre>type MeshVertAtt3 [3]float32</pre>
			<p>
Represents a 3-component vertex attribute (such as for example vertex-normals)
</p>


			

			

			

			

			
		
			
			
			<h2 id="NodeDef">type <a href="/target/node.gt.go?s=295:1027#L2">NodeDef</a></h2>
			<pre>type NodeDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Indicates whether this node is a joint for a skin controller.</span>
    IsSkinJoint bool
    <span class="comment">//	The names of the layers to which this node belongs.</span>
    Layers Layers
    <span class="comment">//	Any combination of zero or more transformations of any type.</span>
    Transforms []*Transform
    <span class="comment">//	Content resources participating in this node.</span>
    Insts struct {
        <span class="comment">//	Cameras participating in this node.</span>
        Camera []*CameraInst
        <span class="comment">//	Controllers participating in this node.</span>
        Controller []*ControllerInst
        <span class="comment">//	Geometries participating in this node.</span>
        Geometry []*GeometryInst
        <span class="comment">//	Lights participating in this node.</span>
        Light []*LightInst
    }
    <span class="comment">//	Child nodes to recursively define a hierarchy.</span>
    Nodes []ChildNode
}</pre>
			<p>
Declares a point of interest in a scene.
</p>


			

			

			

			

			
				
				<h3 id="NodeDef.Init">func (*NodeDef) <a href="/target/node.gt.go?s=1047:1072#L29">Init</a></h3>
				<pre>func (me *NodeDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="NodeDef.NewInst">func (*NodeDef) <a href="/target/node.gt.go?s=1842:1887#L60">NewInst</a></h3>
				<pre>func (me *NodeDef) NewInst() (inst *NodeInst)</pre>
				<p>
Creates and returns a new NodeInst instance referencing this NodeDef definition.
</p>

				
				
			
		
			
			
			<h2 id="NodeInst">type <a href="/target/node.gt.go?s=1133:1557#L34">NodeInst</a></h2>
			<pre>type NodeInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *NodeDef
    <span class="comment">//	Optional. The mechanism and use of this attribute is application-defined.</span>
    <span class="comment">//	For example, it can be used for bounding boxes or level of detail.</span>
    Proxy RefId
}</pre>
			<p>
Instantiates a node resource.
</p>


			

			

			

			

			
				
				<h3 id="NodeInst.EnsureDef">func (*NodeInst) <a href="/target/node.gt.go?s=2139:2179#L70">EnsureDef</a></h3>
				<pre>func (me *NodeInst) EnsureDef() *NodeDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct NodeDef
according to the current me.DefRef value (by searching AllNodeDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="NodeInst.Init">func (*NodeInst) <a href="/target/node.gt.go?s=1577:1603#L46">Init</a></h3>
				<pre>func (me *NodeInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="Param">type <a href="/target/common.go?s=7670:7890#L228">Param</a></h2>
			<pre>type Param struct {
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The user-defined meaning of the parameter.</span>
    Semantic string
    <span class="comment">//	The type of the value data. This text string must be understood by the application.</span>
    Type string
}</pre>
			<p>
Declares parametric information for its parent resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamDef">type <a href="/target/common.go?s=7978:8074#L240">ParamDef</a></h2>
			<pre>type ParamDef struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Initial value for this parameter</span>
    Value interface{}
}</pre>
			<p>
Declares a new parameter for its parent resource, and assigns it an initial value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamDefs">type <a href="/target/common.go?s=8144:8179#L248">ParamDefs</a></h2>
			<pre>type ParamDefs map[string]*ParamDef</pre>
			<p>
A hash-table containing parameter declarations of this resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamInst">type <a href="/target/common.go?s=8239:8559#L251">ParamInst</a></h2>
			<pre>type ParamInst struct {
    <span class="comment">//	References the identifier of the pre-defined parameter (ParamDef) that will have its value set.</span>
    Ref RefSid
    <span class="comment">//	Indicates if the Value is a string referencing the identifier of a connected parameter.</span>
    IsConnectParamRef bool
    <span class="comment">//	The new value for the referenced parameter.</span>
    Value interface{}
}</pre>
			<p>
Assigns a new value to a previously defined parameter.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamInsts">type <a href="/target/common.go?s=8632:8669#L261">ParamInsts</a></h2>
			<pre>type ParamInsts map[string]*ParamInst</pre>
			<p>
A hash-table containing parameter values assigned by this resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrBool">type <a href="/target/types.go?s=1330:1497#L64">ParamOrBool</a></h2>
			<pre>type ParamOrBool struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    B bool
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a bool value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrFloat">type <a href="/target/types.go?s=1528:1699#L72">ParamOrFloat</a></h2>
			<pre>type ParamOrFloat struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    F float64
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a float64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrFloat2">type <a href="/target/types.go?s=1733:1906#L80">ParamOrFloat2</a></h2>
			<pre>type ParamOrFloat2 struct {
    <span class="comment">//	The values provided if Param is empty.</span>
    F Float2
    <span class="comment">//	If set, refers to a previously defined parameter providing the values.</span>
    Param RefParam
}</pre>
			<p>
Provides two float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrInt">type <a href="/target/types.go?s=1935:2102#L88">ParamOrInt</a></h2>
			<pre>type ParamOrInt struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    I int64
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a int64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrRefSid">type <a href="/target/types.go?s=2345:2517#L104">ParamOrRefSid</a></h2>
			<pre>type ParamOrRefSid struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    Sr RefSid
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a RefSid value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrSidFloat">type <a href="/target/types.go?s=2140:2315#L96">ParamOrSidFloat</a></h2>
			<pre>type ParamOrSidFloat struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    F SidFloat
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a scoped float64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamOrUint">type <a href="/target/types.go?s=2547:2716#L112">ParamOrUint</a></h2>
			<pre>type ParamOrUint struct {
    <span class="comment">//	The value provided if Param is empty.</span>
    U uint64
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Param RefParam
}</pre>
			<p>
Provides a uint64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxCylinder">type <a href="/target/pxrigidbody.go?s=181:360#L1">PxCylinder</a></h2>
			<pre>type PxCylinder struct {
    <span class="comment">//	Radii, Extras</span>
    GeometryBrepCylinder
    <span class="comment">//	Contains a floating-point value that represents the length of the cylinder along the y axis.</span>
    Height float64
}</pre>
			<p>
Declares a cylinder primitive that is centered around its local origin
and aligned along its local y axis.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxForceFieldDef">type <a href="/target/pxforcefield.gt.go?s=207:305#L1">PxForceFieldDef</a></h2>
			<pre>type PxForceFieldDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
}</pre>
			<p>
Provides a general container for force fields.
Force fields affect physical objects, such as rigid bodies, and
may be instantiated under a physics scene or a physics model instance.
</p>


			

			

			

			

			
				
				<h3 id="PxForceFieldDef.Init">func (*PxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=325:358#L4">Init</a></h3>
				<pre>func (me *PxForceFieldDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="PxForceFieldDef.NewInst">func (*PxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=1023:1084#L31">NewInst</a></h3>
				<pre>func (me *PxForceFieldDef) NewInst() (inst *PxForceFieldInst)</pre>
				<p>
Creates and returns a new PxForceFieldInst instance referencing this PxForceFieldDef definition.
</p>

				
				
			
		
			
			
			<h2 id="PxForceFieldInst">type <a href="/target/pxforcefield.gt.go?s=404:682#L8">PxForceFieldInst</a></h2>
			<pre>type PxForceFieldInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxForceFieldDef
}</pre>
			<p>
Instantiates a force field resource.
</p>


			

			

			

			

			
				
				<h3 id="PxForceFieldInst.EnsureDef">func (*PxForceFieldInst) <a href="/target/pxforcefield.gt.go?s=1360:1416#L41">EnsureDef</a></h3>
				<pre>func (me *PxForceFieldInst) EnsureDef() *PxForceFieldDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct PxForceFieldDef
according to the current me.DefRef value (by searching AllPxForceFieldDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="PxForceFieldInst.Init">func (*PxForceFieldInst) <a href="/target/pxforcefield.gt.go?s=702:736#L17">Init</a></h3>
				<pre>func (me *PxForceFieldInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxMaterial">type <a href="/target/pxrigidbody.go?s=514:685#L8">PxMaterial</a></h2>
			<pre>type PxMaterial struct {
    <span class="comment">//	An inline physics material definition.</span>
    Def *PxMaterialDef
    <span class="comment">//	Instantiation of a previously defined physics material.</span>
    Inst *PxMaterialInst
}</pre>
			<p>
Describes the physical surface properties for a rigid body or one of its shapes.
Either Def or Inst (or none), but not both, should be specified.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxMaterialDef">type <a href="/target/pxmaterial.gt.go?s=65:510#L1">PxMaterialDef</a></h2>
			<pre>type PxMaterialDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	The dynamic friction coefficient.</span>
        DynamicFriction SidFloat
        <span class="comment">//	The proportion of the kinetic energy preserved in the impact</span>
        <span class="comment">//	(typically ranges from 0.0 to 1.0). Also known as &#34;bounciness&#34; or &#34;elasticity.&#34;</span>
        Restitution SidFloat
        <span class="comment">//	The static friction coefficient.</span>
        StaticFriction SidFloat
    }
}</pre>
			<p>
Defines the physical properties of an object.
</p>


			

			

			

			

			
				
				<h3 id="PxMaterialDef.Init">func (*PxMaterialDef) <a href="/target/pxmaterial.gt.go?s=530:561#L12">Init</a></h3>
				<pre>func (me *PxMaterialDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="PxMaterialDef.NewInst">func (*PxMaterialDef) <a href="/target/pxmaterial.gt.go?s=1260:1317#L39">NewInst</a></h3>
				<pre>func (me *PxMaterialDef) NewInst() (inst *PxMaterialInst)</pre>
				<p>
Creates and returns a new PxMaterialInst instance referencing this PxMaterialDef definition.
</p>

				
				
			
		
			
			
			<h2 id="PxMaterialInst">type <a href="/target/pxmaterial.gt.go?s=659:933#L16">PxMaterialInst</a></h2>
			<pre>type PxMaterialInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxMaterialDef
}</pre>
			<p>
Lets a shape specify its surface properties using a previously defined physics material.
</p>


			

			

			

			

			
				
				<h3 id="PxMaterialInst.EnsureDef">func (*PxMaterialInst) <a href="/target/pxmaterial.gt.go?s=1587:1639#L49">EnsureDef</a></h3>
				<pre>func (me *PxMaterialInst) EnsureDef() *PxMaterialDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct PxMaterialDef
according to the current me.DefRef value (by searching AllPxMaterialDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="PxMaterialInst.Init">func (*PxMaterialInst) <a href="/target/pxmaterial.gt.go?s=953:985#L25">Init</a></h3>
				<pre>func (me *PxMaterialInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxModelDef">type <a href="/target/pxmodel.gt.go?s=136:547#L1">PxModelDef</a></h2>
			<pre>type PxModelDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Contains zero or more rigid bodies participating in this physics model.</span>
    RigidBodies []*PxRigidBodyDef
    <span class="comment">//	Contains zero or more rigid constraints participating in this physics model.</span>
    RigidConstraints []*PxRigidConstraintDef
    <span class="comment">//	Child physics models participating in this physics model, with optional property overrides.</span>
    Insts []*PxModelInst
}</pre>
			<p>
Allows for building complex combinations of rigid bodies and constraints
that may be instantiated multiple times.
</p>


			

			

			

			

			
				
				<h3 id="PxModelDef.Init">func (*PxModelDef) <a href="/target/pxmodel.gt.go?s=567:595#L7">Init</a></h3>
				<pre>func (me *PxModelDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="PxModelDef.NewInst">func (*PxModelDef) <a href="/target/pxmodel.gt.go?s=2297:2348#L49">NewInst</a></h3>
				<pre>func (me *PxModelDef) NewInst() (inst *PxModelInst)</pre>
				<p>
Creates and returns a new PxModelInst instance referencing this PxModelDef definition.
</p>

				
				
			
		
			
			
			<h2 id="PxModelInst">type <a href="/target/pxmodel.gt.go?s=715:1991#L12">PxModelInst</a></h2>
			<pre>type PxModelInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxModelDef
    <span class="comment">//	Points to the Id of a node in the visual scene. This allows a physics model to be instantiated</span>
    <span class="comment">//	under a specific transform node, which will dictate the initial position and orientation,</span>
    <span class="comment">//	and could be animated to influence kinematic rigid bodies. Optional.</span>
    <span class="comment">//	By default, the physics model is instantiated under the world, rather than a specific transform node.</span>
    <span class="comment">//	This parameter is only meaningful when the parent element of the current physics model is a physics scene.</span>
    Parent RefId
    <span class="comment">//	Zero or more force fields influencing this physics model.</span>
    ForceFields []*PxForceFieldInst
    <span class="comment">//	Contains instances of those rigid bodies included in the instantiated physics model that should</span>
    <span class="comment">//	have some properties overridden, or should be linked with transform nodes in the visual scene.</span>
    RigidBodies []*PxRigidBodyInst
    <span class="comment">//	Contains instances of those rigid constraints included in the instantiated</span>
    <span class="comment">//	physics model that should have some properties overridden.</span>
    RigidConstraints []*PxRigidConstraintInst
}</pre>
			<p>
Embeds a physics model inside another physics model or
instantiates a physics model within a physics scene.
</p>


			

			

			

			

			
				
				<h3 id="PxModelInst.EnsureDef">func (*PxModelInst) <a href="/target/pxmodel.gt.go?s=2609:2655#L59">EnsureDef</a></h3>
				<pre>func (me *PxModelInst) EnsureDef() *PxModelDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct PxModelDef
according to the current me.DefRef value (by searching AllPxModelDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="PxModelInst.Init">func (*PxModelInst) <a href="/target/pxmodel.gt.go?s=2011:2040#L35">Init</a></h3>
				<pre>func (me *PxModelInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidBodyCommon">type <a href="/target/pxrigidbody.go?s=1879:2768#L47">PxRigidBodyCommon</a></h2>
			<pre>type PxRigidBodyCommon struct {
    <span class="comment">//	Specifies whether this rigid body is movable. Defaults to true.</span>
    Dynamic SidBool
    <span class="comment">//	If set, specifies the total mass of this rigid body.</span>
    Mass *SidFloat
    <span class="comment">//	Zero or more TRANSFORM_TYPE_TRANSLATE and/or TRANSFORM_TYPE_ROTATE transformations defining the</span>
    <span class="comment">//	center and orientation of mass of the rigid-body relative to the local origin of the &#34;root&#34; shape.</span>
    <span class="comment">//	This makes the off-diagonal elements of the inertia tensor (products of inertia) all 0</span>
    <span class="comment">//	and allows us to just store the diagonal elements (moments of inertia).</span>
    MassFrame []*Transform
    <span class="comment">//	The diagonal elements of the inertia tensor (moments of inertia),</span>
    <span class="comment">//	represented in the local frame of the center of mass.</span>
    Inertia *SidFloat3
    <span class="comment">//	Describes the physical surface properties for this rigid body.</span>
    Material PxMaterial
    <span class="comment">//	Zero or more shapes for collision detection.</span>
    Shapes []*PxShape
}</pre>
			<p>
Common-technique profile for rigid body definitions and instances.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidBodyDef">type <a href="/target/pxrigidbody.go?s=2770:3005#L66">PxRigidBodyDef</a></h2>
			<pre>type PxRigidBodyDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Dynamic, Mass, MassFrame, Inertia, Material, Shapes</span>
        PxRigidBodyCommon
    }
}</pre>
			

			

			

			

			

			
				
				<h3 id="PxRigidBodyDef.Init">func (*PxRigidBodyDef) <a href="/target/pxrigidbody.go?s=3025:3057#L81">Init</a></h3>
				<pre>func (me *PxRigidBodyDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidBodyInst">type <a href="/target/pxrigidbody.go?s=3126:3873#L86">PxRigidBodyInst</a></h2>
			<pre>type PxRigidBodyInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxRigidBodyDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Refers to the NodeDef influenced by this rigid body instance.</span>
    TargetNode RefId
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Dynamic, Mass, MassFrame, Inertia, Material, Shapes</span>
        PxRigidBodyCommon
        <span class="comment">//	Initial spin or angular velocity, also known as the axis of rotation,</span>
        <span class="comment">//	with a magnitude equal to the rate of rotation in radians per second.</span>
        AngularVelocity unum.Vec3
        <span class="comment">//	Initial linear velocity.</span>
        LinearVelocity unum.Vec3
    }
}</pre>
			<p>
Instantiates a rigid-body resource.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidBodyInst.Init">func (*PxRigidBodyInst) <a href="/target/pxrigidbody.go?s=3893:3926#L109">Init</a></h3>
				<pre>func (me *PxRigidBodyInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintAttachment">type <a href="/target/pxrigidconstraint.go?s=140:605#L1">PxRigidConstraintAttachment</a></h2>
			<pre>type PxRigidConstraintAttachment struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Refers to a RigidBodyDef or NodeDef.</span>
    RigidBody RefSid
    <span class="comment">//	Zero or more translation and/or rotation transformations:</span>
    <span class="comment">//	The position of a TRANSFORM_TYPE_TRANSLATE Transform indicates</span>
    <span class="comment">//	the attachment point on the corresponding RigidBodyDef.</span>
    <span class="comment">//	The orientation of a TRANSFORM_TYPE_ROTATE Transform indicates</span>
    <span class="comment">//	the alignment of the joint frame for that RigidBodyDef.</span>
    Transforms []*Transform
}</pre>
			<p>
Defines an attachment frame (or attachment frame of reference),
to a rigid body or a node, within a rigid constraint.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidConstraintDef">type <a href="/target/pxrigidconstraint.go?s=1371:2504#L35">PxRigidConstraintDef</a></h2>
			<pre>type PxRigidConstraintDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Defines the attachment frame of reference (to a rigid_body or a node) within this rigid constraint.</span>
    RefAttachment PxRigidConstraintAttachment
    <span class="comment">//	Defines an attachment frame (to a rigid body or a node) within this rigid constraint.</span>
    Attachment PxRigidConstraintAttachment
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	If false, this rigid constraint doesn&#39;t exert any force or influence on the rigid bodies.</span>
        Enabled SidBool
        <span class="comment">//	If true, the attached rigid bodies may interpenetrate.</span>
        Interpenetrate SidBool
        <span class="comment">//	Degrees of freedom and ranges.</span>
        Limits struct {
            <span class="comment">//	Describes the angular limits along each rotation axis in degrees.</span>
            Angular *PxRigidConstraintLimit
            <span class="comment">//	Describes linear (translational) limits along each axis.</span>
            Linear *PxRigidConstraintLimit
        }
        <span class="comment">//	Spring is based based on either distance (Linear) or angle (Angular), or both.</span>
        Spring struct {
            <span class="comment">//	Angle-based spring.</span>
            Angular *PxRigidConstraintSpring
            <span class="comment">//	Distance-based spring.</span>
            Linear *PxRigidConstraintSpring
        }
    }
}</pre>
			<p>
Constrains rigid bodies to each other or to the world.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidConstraintDef.Init">func (*PxRigidConstraintDef) <a href="/target/pxrigidconstraint.go?s=2524:2562#L70">Init</a></h3>
				<pre>func (me *PxRigidConstraintDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintInst">type <a href="/target/pxrigidconstraint.go?s=2637:2925#L75">PxRigidConstraintInst</a></h2>
			<pre>type PxRigidConstraintInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxRigidConstraintDef
}</pre>
			<p>
Instantiates a rigid constraint resource.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidConstraintInst.Init">func (*PxRigidConstraintInst) <a href="/target/pxrigidconstraint.go?s=2945:2984#L84">Init</a></h3>
				<pre>func (me *PxRigidConstraintInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintLimit">type <a href="/target/pxrigidconstraint.go?s=641:807#L9">PxRigidConstraintLimit</a></h2>
			<pre>type PxRigidConstraintLimit struct {
    <span class="comment">//	Lower bounds for this limit across all 3 axes.</span>
    Min SidVec3
    <span class="comment">//	Upper bounds for this limit across all 3 axes.</span>
    Max SidVec3
}</pre>
			<p>
Degrees of freedom and ranges.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidConstraintSpring">type <a href="/target/pxrigidconstraint.go?s=891:1166#L17">PxRigidConstraintSpring</a></h2>
			<pre>type PxRigidConstraintSpring struct {
    <span class="comment">//	Also called spring coefficient.</span>
    <span class="comment">//	Has units of force/distance (for Linear) or force/angle (for Angular).</span>
    Stiffness SidFloat
    <span class="comment">//	How this spring is damped.</span>
    Damping SidFloat
    <span class="comment">//	Target value for this spring.</span>
    TargetValue SidFloat
}</pre>
			<p>
Spring is based based on either distance (Linear) or angle (Angular), or both.
</p>


			

			

			

			
				
				<h3 id="NewPxRigidConstraintSpring">func <a href="/target/pxrigidconstraint.go?s=1183:1246#L28">NewPxRigidConstraintSpring</a></h3>
				<pre>func NewPxRigidConstraintSpring() (me *PxRigidConstraintSpring)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="PxSceneDef">type <a href="/target/pxscene.gt.go?s=102:884#L1">PxSceneDef</a></h2>
			<pre>type PxSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Force fields influencing this physics scene.</span>
    ForceFields []*PxForceFieldInst
    <span class="comment">//	Refers to the rigid bodies and constraints participating in this scene.</span>
    Models []*PxModelInst
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	If set, a vector representation of this physics scene&#39;s gravity force field.</span>
        <span class="comment">//	It is given as a denormalized direction vector of three floating-point values that</span>
        <span class="comment">//	indicate both the magnitude and direction of acceleration caused by the field.</span>
        Gravity *SidVec3
        <span class="comment">//	If set, the integration time step, measured in seconds, of the physics scene.</span>
        <span class="comment">//	This value is engine-specific. If omitted, the physics engine&#39;s default is used.</span>
        TimeStep *SidFloat
    }
}</pre>
			<p>
Specifies an environment in which physical objects are instantiated and simulated.
</p>


			

			

			

			

			
				
				<h3 id="PxSceneDef.Init">func (*PxSceneDef) <a href="/target/pxscene.gt.go?s=904:932#L16">Init</a></h3>
				<pre>func (me *PxSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="PxSceneDef.NewInst">func (*PxSceneDef) <a href="/target/pxscene.gt.go?s=1554:1605#L43">NewInst</a></h3>
				<pre>func (me *PxSceneDef) NewInst() (inst *PxSceneInst)</pre>
				<p>
Creates and returns a new PxSceneInst instance referencing this PxSceneDef definition.
</p>

				
				
			
		
			
			
			<h2 id="PxSceneInst">type <a href="/target/pxscene.gt.go?s=980:1248#L20">PxSceneInst</a></h2>
			<pre>type PxSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *PxSceneDef
}</pre>
			<p>
Instantiates a physics scene resource.
</p>


			

			

			

			

			
				
				<h3 id="PxSceneInst.EnsureDef">func (*PxSceneInst) <a href="/target/pxscene.gt.go?s=1866:1912#L53">EnsureDef</a></h3>
				<pre>func (me *PxSceneInst) EnsureDef() *PxSceneDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct PxSceneDef
according to the current me.DefRef value (by searching AllPxSceneDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="PxSceneInst.Init">func (*PxSceneInst) <a href="/target/pxscene.gt.go?s=1268:1297#L29">Init</a></h3>
				<pre>func (me *PxSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxShape">type <a href="/target/pxrigidbody.go?s=780:1807#L16">PxShape</a></h2>
			<pre>type PxShape struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	If true, the mass is distributed along the surface of this shape.</span>
    Hollow SidBool
    <span class="comment">//	The mass of this shape.</span>
    Mass *SidFloat
    <span class="comment">//	The density of this shape.</span>
    Density *SidFloat
    <span class="comment">//	Describes the physical surface properties for this shape.</span>
    Material PxMaterial
    <span class="comment">//	Geometry of the shape. At least and at most one of its fields should ever be set.</span>
    Geometry struct {
        <span class="comment">//	A flat plane.</span>
        Plane *GeometryBrepPlane
        <span class="comment">//	Axis-aligned box.</span>
        Box *GeometryBrepBox
        <span class="comment">//	A perfectly round sphere.</span>
        Sphere *GeometryBrepSphere
        <span class="comment">//	A cylinder primitive that is centered on its local origin and aligned along its y axis.</span>
        Cylinder *PxCylinder
        <span class="comment">//	A capsule primitive that is centered on the local origin and aligned along the y axis.</span>
        Capsule *GeometryBrepCapsule
        <span class="comment">//	Refers to a previously defined mesh or spline geometric primitive.</span>
        Inst *GeometryInst
    }
    <span class="comment">//	Zero or more TRANSFORM_TYPE_ROTATE and/or TRANSFORM_TYPE_TRANSLATE transformations for the shape.</span>
    Transforms []*Transform
}</pre>
			<p>
A component part of a rigid body&#39;s collection of bounding shapes for collision detection.
</p>


			

			

			

			

			
		
			
			
			<h2 id="RefId">type <a href="/target/refid.go?s=72:89#L1">RefId</a></h2>
			<pre>type RefId string</pre>
			<p>
References a resource by its unique identifier (Id).
</p>


			

			

			

			

			
				
				<h3 id="RefId.AnimationClipDef">func (RefId) <a href="/target/animationclip.gt.go?s=2300:2358#L71">AnimationClipDef</a></h3>
				<pre>func (me RefId) AnimationClipDef() (def *AnimationClipDef)</pre>
				<p>
Searches (all LibAnimationClipDefs contained in AllAnimationClipDefLibs) for the AnimationClipDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.AnimationDef">func (RefId) <a href="/target/animation.gt.go?s=3610:3660#L109">AnimationDef</a></h3>
				<pre>func (me RefId) AnimationDef() (def *AnimationDef)</pre>
				<p>
Searches (all LibAnimationDefs contained in AllAnimationDefLibs) for the AnimationDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.AnimationSampler">func (RefId) <a href="/target/refid.go?s=250:307#L1">AnimationSampler</a></h3>
				<pre>func (me RefId) AnimationSampler() (as *AnimationSampler)</pre>
				<p>
Searches (all LibAnimationDefs contained in AllAnimationDefLibs) for the AnimationSampler
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.ArrayInAnimationDef">func (RefId) <a href="/target/refid.go?s=691:741#L18">ArrayInAnimationDef</a></h3>
				<pre>func (me RefId) ArrayInAnimationDef() *SourceArray</pre>
				<p>
Searches (all LibAnimationDefs contained in AllAnimationDefLibs) for the SourceArray
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.ArrayInControllerDef">func (RefId) <a href="/target/refid.go?s=1145:1196#L38">ArrayInControllerDef</a></h3>
				<pre>func (me RefId) ArrayInControllerDef() *SourceArray</pre>
				<p>
Searches (all LibControllerDefs contained in AllControllerDefLibs) for the SourceArray
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.ArrayInGeometryDef">func (RefId) <a href="/target/refid.go?s=1755:1809#L66">ArrayInGeometryDef</a></h3>
				<pre>func (me RefId) ArrayInGeometryDef() (sa *SourceArray)</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the SourceArray
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.CameraDef">func (RefId) <a href="/target/camera.gt.go?s=3105:3149#L111">CameraDef</a></h3>
				<pre>func (me RefId) CameraDef() (def *CameraDef)</pre>
				<p>
Searches (all LibCameraDefs contained in AllCameraDefLibs) for the CameraDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.ControllerDef">func (RefId) <a href="/target/controller.gt.go?s=4011:4063#L128">ControllerDef</a></h3>
				<pre>func (me RefId) ControllerDef() (def *ControllerDef)</pre>
				<p>
Searches (all LibControllerDefs contained in AllControllerDefLibs) for the ControllerDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FormulaDef">func (RefId) <a href="/target/formula.gt.go?s=2435:2481#L92">FormulaDef</a></h3>
				<pre>func (me RefId) FormulaDef() (def *FormulaDef)</pre>
				<p>
Searches (all LibFormulaDefs contained in AllFormulaDefLibs) for the FormulaDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxEffectDef">func (RefId) <a href="/target/fxeffect.gt.go?s=16320:16368#L457">FxEffectDef</a></h3>
				<pre>func (me RefId) FxEffectDef() (def *FxEffectDef)</pre>
				<p>
Searches (all LibFxEffectDefs contained in AllFxEffectDefLibs) for the FxEffectDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxImageDef">func (RefId) <a href="/target/fximage.gt.go?s=12411:12457#L327">FxImageDef</a></h3>
				<pre>func (me RefId) FxImageDef() (def *FxImageDef)</pre>
				<p>
Searches (all LibFxImageDefs contained in AllFxImageDefLibs) for the FxImageDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxMaterialDef">func (RefId) <a href="/target/fxmaterial.gt.go?s=2879:2931#L88">FxMaterialDef</a></h3>
				<pre>func (me RefId) FxMaterialDef() (def *FxMaterialDef)</pre>
				<p>
Searches (all LibFxMaterialDefs contained in AllFxMaterialDefLibs) for the FxMaterialDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxProfile">func (RefId) <a href="/target/refid.go?s=3341:3384#L126">FxProfile</a></h3>
				<pre>func (me RefId) FxProfile() (fp *FxProfile)</pre>
				<p>
Searches (all LibFxEffectDefs contained in AllFxEffectDefLibs) for the FxProfile
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxTechniqueCommon">func (RefId) <a href="/target/refid.go?s=3770:3824#L146">FxTechniqueCommon</a></h3>
				<pre>func (me RefId) FxTechniqueCommon() *FxTechniqueCommon</pre>
				<p>
Searches (all LibFxEffectDefs contained in AllFxEffectDefLibs) for the FxTechniqueCommon
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.FxTechniqueGlsl">func (RefId) <a href="/target/refid.go?s=4279:4333#L166">FxTechniqueGlsl</a></h3>
				<pre>func (me RefId) FxTechniqueGlsl() (t *FxTechniqueGlsl)</pre>
				<p>
Searches (all LibFxEffectDefs contained in AllFxEffectDefLibs) for the FxTechniqueGlsl
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepEdges">func (RefId) <a href="/target/refid.go?s=4822:4876#L191">GeometryBrepEdges</a></h3>
				<pre>func (me RefId) GeometryBrepEdges() *GeometryBrepEdges</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepEdges
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepFaces">func (RefId) <a href="/target/refid.go?s=5287:5341#L208">GeometryBrepFaces</a></h3>
				<pre>func (me RefId) GeometryBrepFaces() *GeometryBrepFaces</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepFaces
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepPcurves">func (RefId) <a href="/target/refid.go?s=5754:5812#L225">GeometryBrepPcurves</a></h3>
				<pre>func (me RefId) GeometryBrepPcurves() *GeometryBrepPcurves</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepPcurves
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepShells">func (RefId) <a href="/target/refid.go?s=6230:6286#L242">GeometryBrepShells</a></h3>
				<pre>func (me RefId) GeometryBrepShells() *GeometryBrepShells</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepShells
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepSolids">func (RefId) <a href="/target/refid.go?s=6701:6757#L259">GeometryBrepSolids</a></h3>
				<pre>func (me RefId) GeometryBrepSolids() *GeometryBrepSolids</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepSolids
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryBrepWires">func (RefId) <a href="/target/refid.go?s=8025:8079#L304">GeometryBrepWires</a></h3>
				<pre>func (me RefId) GeometryBrepWires() *GeometryBrepWires</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryBrepWires
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryDef">func (RefId) <a href="/target/geometry.gt.go?s=5720:5768#L178">GeometryDef</a></h3>
				<pre>func (me RefId) GeometryDef() (def *GeometryDef)</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryMesh">func (RefId) <a href="/target/refid.go?s=7177:7226#L276">GeometryMesh</a></h3>
				<pre>func (me RefId) GeometryMesh() (gm *GeometryMesh)</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryDef
whose Id is referenced by me, returning the Mesh of the first match found.
</p>

				
				
			
				
				<h3 id="RefId.GeometryVertices">func (RefId) <a href="/target/refid.go?s=7458:7510#L285">GeometryVertices</a></h3>
				<pre>func (me RefId) GeometryVertices() *GeometryVertices</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the GeometryVertices
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.KxArticulatedSystemDef">func (RefId) <a href="/target/kxarticulatedsystem.gt.go?s=8472:8542#L261">KxArticulatedSystemDef</a></h3>
				<pre>func (me RefId) KxArticulatedSystemDef() (def *KxArticulatedSystemDef)</pre>
				<p>
Searches (all LibKxArticulatedSystemDefs contained in AllKxArticulatedSystemDefLibs) for the KxArticulatedSystemDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.KxJointDef">func (RefId) <a href="/target/kxjoint.gt.go?s=3144:3190#L103">KxJointDef</a></h3>
				<pre>func (me RefId) KxJointDef() (def *KxJointDef)</pre>
				<p>
Searches (all LibKxJointDefs contained in AllKxJointDefLibs) for the KxJointDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.KxModelDef">func (RefId) <a href="/target/kxmodel.gt.go?s=3536:3582#L117">KxModelDef</a></h3>
				<pre>func (me RefId) KxModelDef() (def *KxModelDef)</pre>
				<p>
Searches (all LibKxModelDefs contained in AllKxModelDefLibs) for the KxModelDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.KxSceneDef">func (RefId) <a href="/target/kxscene.gt.go?s=3504:3550#L104">KxSceneDef</a></h3>
				<pre>func (me RefId) KxSceneDef() (def *KxSceneDef)</pre>
				<p>
Searches (all LibKxSceneDefs contained in AllKxSceneDefLibs) for the KxSceneDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.LightDef">func (RefId) <a href="/target/light.gt.go?s=4742:4784#L157">LightDef</a></h3>
				<pre>func (me RefId) LightDef() (def *LightDef)</pre>
				<p>
Searches (all LibLightDefs contained in AllLightDefLibs) for the LightDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.NodeDef">func (RefId) <a href="/target/node.gt.go?s=2748:2788#L95">NodeDef</a></h3>
				<pre>func (me RefId) NodeDef() (def *NodeDef)</pre>
				<p>
Searches (all LibNodeDefs contained in AllNodeDefLibs) for the NodeDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.PxForceFieldDef">func (RefId) <a href="/target/pxforcefield.gt.go?s=2081:2137#L66">PxForceFieldDef</a></h3>
				<pre>func (me RefId) PxForceFieldDef() (def *PxForceFieldDef)</pre>
				<p>
Searches (all LibPxForceFieldDefs contained in AllPxForceFieldDefLibs) for the PxForceFieldDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.PxMaterialDef">func (RefId) <a href="/target/pxmaterial.gt.go?s=2280:2332#L74">PxMaterialDef</a></h3>
				<pre>func (me RefId) PxMaterialDef() (def *PxMaterialDef)</pre>
				<p>
Searches (all LibPxMaterialDefs contained in AllPxMaterialDefLibs) for the PxMaterialDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.PxModelDef">func (RefId) <a href="/target/pxmodel.gt.go?s=3260:3306#L84">PxModelDef</a></h3>
				<pre>func (me RefId) PxModelDef() (def *PxModelDef)</pre>
				<p>
Searches (all LibPxModelDefs contained in AllPxModelDefLibs) for the PxModelDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.PxSceneDef">func (RefId) <a href="/target/pxscene.gt.go?s=2517:2563#L78">PxSceneDef</a></h3>
				<pre>func (me RefId) PxSceneDef() (def *PxSceneDef)</pre>
				<p>
Searches (all LibPxSceneDefs contained in AllPxSceneDefLibs) for the PxSceneDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.S">func (RefId) <a href="/target/refid.go?s=8378:8404#L320">S</a></h3>
				<pre>func (me RefId) S() string</pre>
				<p>
Returns the Id currently referenced by me.
</p>

				
				
			
				
				<h3 id="RefId.SetIdRef">func (*RefId) <a href="/target/refid.go?s=8476:8511#L325">SetIdRef</a></h3>
				<pre>func (me *RefId) SetIdRef(v string)</pre>
				<p>
Modifies the Id currently referenced by me.
</p>

				
				
			
				
				<h3 id="RefId.SourceInAnimationDef">func (RefId) <a href="/target/refid.go?s=8682:8732#L331">SourceInAnimationDef</a></h3>
				<pre>func (me RefId) SourceInAnimationDef() (s *Source)</pre>
				<p>
Searches (all LibAnimationDefs contained in AllAnimationDefLibs) for the Source
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.SourceInControllerDef">func (RefId) <a href="/target/refid.go?s=9075:9126#L348">SourceInControllerDef</a></h3>
				<pre>func (me RefId) SourceInControllerDef() (s *Source)</pre>
				<p>
Searches (all LibControllerDefs contained in AllControllerDefLibs) for the Source
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.SourceInGeometryDef">func (RefId) <a href="/target/refid.go?s=9622:9671#L373">SourceInGeometryDef</a></h3>
				<pre>func (me RefId) SourceInGeometryDef() (s *Source)</pre>
				<p>
Searches (all LibGeometryDefs contained in AllGeometryDefLibs) for the Source
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
				
				<h3 id="RefId.VisualSceneDef">func (RefId) <a href="/target/visualscene.gt.go?s=3710:3764#L118">VisualSceneDef</a></h3>
				<pre>func (me RefId) VisualSceneDef() (def *VisualSceneDef)</pre>
				<p>
Searches (all LibVisualSceneDefs contained in AllVisualSceneDefLibs) for the VisualSceneDef
whose Id is referenced by me, returning the first match found.
</p>

				
				
			
		
			
			
			<h2 id="RefParam">type <a href="/target/refparam.go?s=62:82#L1">RefParam</a></h2>
			<pre>type RefParam RefSid</pre>
			<p>
References a previously defined parameter.
</p>


			

			

			

			

			
				
				<h3 id="RefParam.S">func (RefParam) <a href="/target/refparam.go?s=131:160#L1">S</a></h3>
				<pre>func (me RefParam) S() string</pre>
				<p>
Returns the Sid currently referenced by me.
</p>

				
				
			
				
				<h3 id="RefParam.SetParamRef">func (*RefParam) <a href="/target/refparam.go?s=233:274#L2">SetParamRef</a></h3>
				<pre>func (me *RefParam) SetParamRef(v string)</pre>
				<p>
Modifies the Sid currently referenced by me.
</p>

				
				
			
				
				<h3 id="RefParam.Sr">func (RefParam) <a href="/target/refparam.go?s=358:388#L7">Sr</a></h3>
				<pre>func (me RefParam) Sr() RefSid</pre>
				<p>
Returns the Sid currently referenced by me as a RefSid.
</p>

				
				
			
		
			
			
			<h2 id="RefSid">type <a href="/target/refsid.go?s=73:91#L1">RefSid</a></h2>
			<pre>type RefSid string</pre>
			<p>
References a resource by its scoped identifier (Sid).
</p>


			

			

			

			

			
				
				<h3 id="RefSid.S">func (RefSid) <a href="/target/refsid.go?s=140:167#L1">S</a></h3>
				<pre>func (me RefSid) S() string</pre>
				<p>
Returns the Sid currently referenced by me.
</p>

				
				
			
				
				<h3 id="RefSid.SetSidRef">func (*RefSid) <a href="/target/refsid.go?s=240:277#L2">SetSidRef</a></h3>
				<pre>func (me *RefSid) SetSidRef(v string)</pre>
				<p>
Modifies the Sid currently referenced by me.
</p>

				
				
			
		
			
			
			<h2 id="Scene">type <a href="/target/common.go?s=8752:9153#L264">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Embodies the entire set of information that can be visualized from the contents of a resource.</span>
    Visual *VisualSceneInst
    <span class="comment">//	Embodies the entire set of information that can be articulated kinematically from a resource.</span>
    Kinematics *KxSceneInst
    <span class="comment">//	Specifies an environment in which physical objects are instantiated and simulated.</span>
    Physics []*PxSceneInst
}</pre>
			<p>
Declares a complete, self-contained base of a scene hierarchy or scene graph.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SidBool">type <a href="/target/types.go?s=2764:2826#L120">SidBool</a></h2>
			<pre>type SidBool struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The value.</span>
    B bool
}</pre>
			<p>
A bool value that has a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SidFloat">type <a href="/target/types.go?s=2877:2943#L128">SidFloat</a></h2>
			<pre>type SidFloat struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The value.</span>
    F float64
}</pre>
			<p>
A float64 value that has a scoped identifier.
</p>


			

			

			

			
				
				<h3 id="SidF">func <a href="/target/assets.go?s=608:643#L18">SidF</a></h3>
				<pre>func SidF(f float64) (sf *SidFloat)</pre>
				<p>
Returns a ScopedFloat with the specified value and no Sid.
</p>

				
			

			
		
			
			
			<h2 id="SidFloat3">type <a href="/target/types.go?s=3000:3067#L136">SidFloat3</a></h2>
			<pre>type SidFloat3 struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The values.</span>
    F Float3
}</pre>
			<p>
Three float64 values that have a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SidString">type <a href="/target/types.go?s=3117:3183#L144">SidString</a></h2>
			<pre>type SidString struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The value.</span>
    S string
}</pre>
			<p>
A string value that has a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SidVec3">type <a href="/target/types.go?s=3230:3292#L152">SidVec3</a></h2>
			<pre>type SidVec3 struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	X, Y, Z</span>
    unum.Vec3
}</pre>
			<p>
A 3D vector that has a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Source">type <a href="/target/source.go?s=128:421#L1">Source</a></h2>
			<pre>type Source struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Asset</span>
    HasAsset
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	The data array of this Source.</span>
    Array SourceArray
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Describes a stream of values from this array data source.</span>
        Accessor *SourceAccessor
    }
}</pre>
			<p>
Declares a data repository that provides values
according to the semantics of an Input that refers to it.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SourceAccessor">type <a href="/target/source.go?s=482:1232#L14">SourceAccessor</a></h2>
			<pre>type SourceAccessor struct {
    <span class="comment">//	The number of times the array is accessed. Required.</span>
    Count uint64
    <span class="comment">//	The index of the first value to be read from the array. The default is 0. Optional.</span>
    Offset uint64
    <span class="comment">//	The Id of the array to access. Required.</span>
    Source RefId
    <span class="comment">//	The number of values that are to be considered a unit during each access to the array.</span>
    <span class="comment">//	The default is 1, indicating that a single value is accessed. Optional.</span>
    Stride uint64
    <span class="comment">//	The number and order of Params define the output of the accessor.</span>
    <span class="comment">//	Parameters are bound to values in the order in which both are specified. No reordering of the data can occur.</span>
    <span class="comment">//	A Param without a Name indicates that the value is not part of the output, so the Param is unbound.</span>
    Params []*Param
}</pre>
			<p>
Describes a stream of values from an array data source.
</p>


			

			

			

			
				
				<h3 id="NewSourceAccessor">func <a href="/target/source.go?s=1294:1339#L31">NewSourceAccessor</a></h3>
				<pre>func NewSourceAccessor() (me *SourceAccessor)</pre>
				<p>
Allocates, initializes and returns a new SourceAccessor.
</p>

				
			

			
		
			
			
			<h2 id="SourceArray">type <a href="/target/source.go?s=1502:2190#L38">SourceArray</a></h2>
			<pre>type SourceArray struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	A slice into the array of bools that this Source represents, if any.</span>
    Bools []bool
    <span class="comment">//	A slice into the array of floats that this Source represents, if any.</span>
    Floats []float64
    <span class="comment">//	A slice into the array of RefIds that this Source represents, if any.</span>
    IdRefs []string
    <span class="comment">//	A slice into the array of ints that this Source represents, if any.</span>
    Ints []int64
    <span class="comment">//	A slice into the array of names that this Source represents, if any.</span>
    Names []string
    <span class="comment">//	A slice into the array of RefSids that this Source represents, if any.</span>
    SidRefs []string
    <span class="comment">//	A slice into the array of tokens that this Source represents, if any.</span>
    Tokens []string
}</pre>
			<p>
The data array of a Source.
Of all its []slice fields, only ONE should ever be non-nil/non-empty at any time.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Sources">type <a href="/target/source.go?s=2244:2275#L60">Sources</a></h2>
			<pre>type Sources map[string]*Source</pre>
			<p>
A hash-table of Sources, each keyed with its Id.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Technique">type <a href="/target/common.go?s=9265:9519#L277">Technique</a></h2>
			<pre>type Technique struct {
    <span class="comment">//	The type of profile. This is a vendor-defined character string</span>
    <span class="comment">//	that indicates the platform or capability target for the technique.</span>
    Profile string
    <span class="comment">//	Arbitrary content or meta-data for this Technique.</span>
    Data []*xmlx.Node
}</pre>
			<p>
Declares platform-specific or program-specific information
used to process some portion of the content.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Transform">type <a href="/target/common.go?s=9579:10445#L286">Transform</a></h2>
			<pre>type Transform struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The type of this transformation (rotation, skewing, scaling, translation, &#34;look-at&#34;, or matrix).</span>
    <span class="comment">//	Must be one of the TRANSFORM_TYPE_* enumerated constants.</span>
    Type int
    <span class="comment">//	Contains one or more vectors and values representing this transformation.</span>
    <span class="comment">//	For TRANSFORM_TYPE_LOOKAT:</span>
    <span class="comment">//		9 values representing three 3D vectors (eye position, interest point, up-axis).</span>
    <span class="comment">//	For TRANSFORM_TYPE_MATRIX:</span>
    <span class="comment">//		16 values representing one column-major 4x4 matrix.</span>
    <span class="comment">//	For TRANSFORM_TYPE_SKEW:</span>
    <span class="comment">//		7 values -- one angle in degrees, then two 3D vectors for the axes of rotation and translation.</span>
    <span class="comment">//	For TRANSFORM_TYPE_ROTATE:</span>
    <span class="comment">//		4 values -- one 3D vector specifying the axis of rotation, then one angle in degrees.</span>
    <span class="comment">//	For TRANSFORM_TYPE_TRANSLATE or TRANSFORM_TYPE_SCALE:</span>
    <span class="comment">//		3 values representing a single 3D vector.</span>
    F []float64
}</pre>
			<p>
Represents a single transformation of a specific kind.
</p>


			

			

			

			

			
		
			
			
			<h2 id="VisualSceneDef">type <a href="/target/visualscene.gt.go?s=1715:1962#L46">VisualSceneDef</a></h2>
			<pre>type VisualSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	A scene graph containing nodes of visual information and related data.</span>
    Nodes []*NodeDef
    <span class="comment">//	Specifies how to evaluate this visual scene.</span>
    Evaluations []*VisualSceneEvaluation
}</pre>
			<p>
Embodies the entire set of information that can be visualized from the contents of a resource.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneDef.Init">func (*VisualSceneDef) <a href="/target/visualscene.gt.go?s=1982:2014#L56">Init</a></h3>
				<pre>func (me *VisualSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
				
				<h3 id="VisualSceneDef.NewInst">func (*VisualSceneDef) <a href="/target/visualscene.gt.go?s=2671:2730#L83">NewInst</a></h3>
				<pre>func (me *VisualSceneDef) NewInst() (inst *VisualSceneInst)</pre>
				<p>
Creates and returns a new VisualSceneInst instance referencing this VisualSceneDef definition.
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneEvaluation">type <a href="/target/visualscene.gt.go?s=83:359#L1">VisualSceneEvaluation</a></h2>
			<pre>type VisualSceneEvaluation struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Whether evaluation is enabled. Disabling evaluation can be useful for debugging.</span>
    Disabled bool
    <span class="comment">//	Describes effects passes to render a scene.</span>
    RenderPasses []*VisualSceneRendering
}</pre>
			<p>
Declares information specifying how to evaluate a visual scene.
</p>


			

			

			

			

			
		
			
			
			<h2 id="VisualSceneInst">type <a href="/target/visualscene.gt.go?s=2061:2337#L60">VisualSceneInst</a></h2>
			<pre>type VisualSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	A pointer to the resource definition referenced by this instance.</span>
    <span class="comment">//	Is nil by default and meant to be set ONLY by the EnsureDef() method (which uses BaseInst.DefRef to find it).</span>
    Def *VisualSceneDef
}</pre>
			<p>
Instantiates a visual scene resource.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneInst.EnsureDef">func (*VisualSceneInst) <a href="/target/visualscene.gt.go?s=3003:3057#L93">EnsureDef</a></h3>
				<pre>func (me *VisualSceneInst) EnsureDef() *VisualSceneDef</pre>
				<p>
If me is dirty or me.Def is nil, sets me.Def to the correct VisualSceneDef
according to the current me.DefRef value (by searching AllVisualSceneDefLibs).
Then returns me.Def.
</p>

				
				
			
				
				<h3 id="VisualSceneInst.Init">func (*VisualSceneInst) <a href="/target/visualscene.gt.go?s=2357:2390#L69">Init</a></h3>
				<pre>func (me *VisualSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneRendering">type <a href="/target/visualscene.gt.go?s=411:911#L6">VisualSceneRendering</a></h2>
			<pre>type VisualSceneRendering struct {
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Refers to a NodeDef that contains a camera describing</span>
    <span class="comment">//	the viewpoint from which to render this compositing step. Optional.</span>
    CameraNode RefId
    <span class="comment">//	Specifies which layer or layers to render in this compositing step while evaluating the scene.</span>
    Layers Layers
    <span class="comment">//	If set, specifies which effect to render in this compositing step while evaluating the scene.</span>
    MaterialInst *VisualSceneRenderingMaterialInst
}</pre>
			<p>
Describes one effect pass to evaluate a scene.
</p>


			

			

			

			
				
				<h3 id="NewVisualSceneRendering">func <a href="/target/visualscene.gt.go?s=928:985#L23">NewVisualSceneRendering</a></h3>
				<pre>func NewVisualSceneRendering() (me *VisualSceneRendering)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="VisualSceneRenderingMaterialInst">type <a href="/target/visualscene.gt.go?s=1102:1615#L29">VisualSceneRenderingMaterialInst</a></h2>
			<pre>type VisualSceneRenderingMaterialInst struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Binds values to effect parameters upon instantiation.</span>
    Bindings []*FxBinding
    <span class="comment">//	Target specific techniques and passes inside a material</span>
    <span class="comment">//	rather than having to split the effects techniques and passes into multiple effects.</span>
    OverrideTechnique struct {
        <span class="comment">//	Specifies the Sid of a Technique</span>
        Ref RefSid
        <span class="comment">//	Specifies the Sid of one FxPass to execute.</span>
        <span class="comment">//	If not specified, then all of the Technique&#39;s passes are used.</span>
        Pass RefSid
    }
}</pre>
			<p>
Instantiates a material resource for a screen effect.
</p>


			

			

			

			

			
		
		</div>
	

	







	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="collada/">collada</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>
	


		</div></div>
	</body>
</html>