<html>
	<head>
		<title>Package github.com/go3d/go-ngine/assets</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/assets</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/assets"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
File generated by github.com/ungerik/pkgreflect
</p>
<pre>The *assets* package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.

________

First off, the go:ngine 3 RULES of bugless(er) development:

1. you do NOT set exported fields directly, those are provided for simplified read-access. If a field is
meant to be modifiable, there will be a *SetFoo()* method or it will be documented explicitly as directly
modifiable, but such instances will be rare.

2. you do NOT instantiate exported struct types directly, as in &#34;new(ImageDef)&#34; or &#34;&amp;ImageDef {}&#34;. Many of
those are exported only for documentation, but are to be instantiated only inside the go:ngine package.
For types to be instantiated by package-external code (ie. your code), go:ngine packages provide constructor
functions -- often in collections, ie. img := ImageDefs.New(&#34;id&#34;) instead of, say, img := NewImageDef(&#34;id&#34;).

3. Those 2 are *default* assumptions and modes of operation -- there are a few &#34;if you know what you&#39;re
doing&#34; exemptions and those are (or will be) explicitly documented as such.

________

The *assets* package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.
These data structures only describe resource definitions and instances, but do not provide
any specific logic or algorithms, such as physics or visual rendering.

Context: any go:ngine app uses a variety of both simple and complex resource types, including for
example geometry definitions, image textures, material and light descriptions and many others.

While for all these resource types, the go:ngine *core* package manages their respective run-time
representation in its entirety,	some basic part of that representation is &#34;merely descriptive&#34; and
should be readable from or writable to a binary stream (&#34;design-time&#34;). That &#34;merely descriptive&#34;
sub-set of resource definitions is fully contained in this go:ngine *assets* package and thus decoupled
from the go:ngine *core* package.

This *assets* package thus allows for things such as server-side procedural asset generators, networked
resource streaming or simple custom asset-import/export/conversion tools, all of which shouldn&#39;t have to
needlessly depend on the graphics, windowing etc. stacks.

NOTE: there are essentially TWO distinct &#34;modes&#34; or use-cases in which the *assets* package is active:

1. in graphics-independent, server-side or non-interactive &#34;toolage&#34;, dealing only with the raw resource
data where it can be generated, loaded, stored, manipulated at will with no particular repercussions.

2. in an interactive graphical go:ngine app that also has the *core* package loaded:

All &#34;Sync&#34;-related functions pertain to use-case #2, where the *assets* package essentially becomes the
live repository for all resource definitions loaded, used, or manipulated by the *core* package at runtime.
So now every image definition in *assets* may have a corresponding GPU-bound texture object in *core*, every
*assets* mesh definition may be bound to a *core* *MeshBuffer*, etc.

Structure: generally speaking, all resource types are organized in a consistent fashion as follows ---
users familiar with the COLLADA format will notice a stark resemblance in terminology and resource organization:

1. First, there is a *FooDef* struct for the one-time definition of a unique resource:
GeometryMeshDef, ImageDef, LightDef, MaterialDef etc.

2. Next, there is a smaller *FooInst* struct for handling many individual (sometimes parameterized) instances of
an *FooDef*: GeometryMeshInst, ImageInst, LightInst, MaterialInst etc.

3. Finally, there is a light-weight *LibFooDefs* struct type (based on a *map* collection) containing Defs
associated with their ID: LibGeometryMeshDefs, LibImageDefs, LibLightDefs, LibMaterialDefs etc.

4. The package also provides a pre-initialized global *FooDefs* variable for each such Lib type, in simple apps
considered the &#34;default / main / only Lib you&#39;ll need&#34;: GeometryMeshDefs, ImageDefs, LightDefs, MaterialDefs etc.

5. For more complex use-cases, you can also organize multiple libs for any given resource type in the global
*AllFooDefLibs* variable, essentially a *map* collection of Libs: AllGeometryMeshDefLibs (of type
LibsGeometryMeshDef), AllImageDefLibs (of type LibsImageDef), AllLightDefLibs (of type LibsLightDef),
AllMaterialDefLibs (of type LibsMaterialDef) etc.

Any exported types in this package not following the above pattern (such as MeshData etc.) should be
considered &#34;auxiliary helpers&#34; rather than primary / &#34;first-class&#34; resource types.
</pre>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#SyncChanges">func SyncChanges()</a></dd>
			
			
				
				<dd><a href="#AnimationChannel">type AnimationChannel</a></dd>
				
				
			
				
				<dd><a href="#AnimationClipDef">type AnimationClipDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationClipDef.Init">func (me *AnimationClipDef) Init()</a></dd>
				
			
				
				<dd><a href="#AnimationDef">type AnimationDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationDef.Init">func (me *AnimationDef) Init()</a></dd>
				
			
				
				<dd><a href="#AnimationInst">type AnimationInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AnimationInst.Init">func (me *AnimationInst) Init()</a></dd>
				
			
				
				<dd><a href="#AnimationSampler">type AnimationSampler</a></dd>
				
				
			
				
				<dd><a href="#Asset">type Asset</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAsset">func NewAsset() (me *Asset)</a></dd>
				
				
			
				
				<dd><a href="#AssetContributor">type AssetContributor</a></dd>
				
				
			
				
				<dd><a href="#AssetGeographicLocation">type AssetGeographicLocation</a></dd>
				
				
			
				
				<dd><a href="#Base">type Base</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SetDirty">func (me *Base) SetDirty()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SetFieldB">func (me *Base) SetFieldB(field *bool, val bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SetFieldF">func (me *Base) SetFieldF(field *float64, val float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SyncChanges">func (me *Base) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#BaseDef">type BaseDef</a></dd>
				
				
			
				
				<dd><a href="#BaseInst">type BaseInst</a></dd>
				
				
			
				
				<dd><a href="#BaseLib">type BaseLib</a></dd>
				
				
			
				
				<dd><a href="#Bool2">type Bool2</a></dd>
				
				
			
				
				<dd><a href="#Bool3">type Bool3</a></dd>
				
				
			
				
				<dd><a href="#Bool4">type Bool4</a></dd>
				
				
			
				
				<dd><a href="#CameraDef">type CameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.Init">func (me *CameraDef) Init()</a></dd>
				
			
				
				<dd><a href="#CameraImager">type CameraImager</a></dd>
				
				
			
				
				<dd><a href="#CameraInst">type CameraInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraInst.Init">func (me *CameraInst) Init()</a></dd>
				
			
				
				<dd><a href="#CameraOptics">type CameraOptics</a></dd>
				
				
			
				
				<dd><a href="#CameraOrthographic">type CameraOrthographic</a></dd>
				
				
			
				
				<dd><a href="#CameraPerspective">type CameraPerspective</a></dd>
				
				
			
				
				<dd><a href="#ChildNode">type ChildNode</a></dd>
				
				
			
				
				<dd><a href="#ControllerDef">type ControllerDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerDef.Init">func (me *ControllerDef) Init()</a></dd>
				
			
				
				<dd><a href="#ControllerInputs">type ControllerInputs</a></dd>
				
				
			
				
				<dd><a href="#ControllerInst">type ControllerInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ControllerInst.Init">func (me *ControllerInst) Init()</a></dd>
				
			
				
				<dd><a href="#ControllerMorph">type ControllerMorph</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerMorph">func NewControllerMorph() (me *ControllerMorph)</a></dd>
				
				
			
				
				<dd><a href="#ControllerSkin">type ControllerSkin</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerSkin">func NewControllerSkin() (me *ControllerSkin)</a></dd>
				
				
			
				
				<dd><a href="#Document">type Document</a></dd>
				
				
			
				
				<dd><a href="#Extra">type Extra</a></dd>
				
				
			
				
				<dd><a href="#Float2">type Float2</a></dd>
				
				
			
				
				<dd><a href="#Float2x2">type Float2x2</a></dd>
				
				
			
				
				<dd><a href="#Float2x3">type Float2x3</a></dd>
				
				
			
				
				<dd><a href="#Float2x4">type Float2x4</a></dd>
				
				
			
				
				<dd><a href="#Float3">type Float3</a></dd>
				
				
			
				
				<dd><a href="#Float3x2">type Float3x2</a></dd>
				
				
			
				
				<dd><a href="#Float3x3">type Float3x3</a></dd>
				
				
			
				
				<dd><a href="#Float3x4">type Float3x4</a></dd>
				
				
			
				
				<dd><a href="#Float4">type Float4</a></dd>
				
				
			
				
				<dd><a href="#Float4x2">type Float4x2</a></dd>
				
				
			
				
				<dd><a href="#Float4x3">type Float4x3</a></dd>
				
				
			
				
				<dd><a href="#Float4x4">type Float4x4</a></dd>
				
				
			
				
				<dd><a href="#Float7">type Float7</a></dd>
				
				
			
				
				<dd><a href="#Formula">type Formula</a></dd>
				
				
			
				
				<dd><a href="#FormulaDef">type FormulaDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaDef.Init">func (me *FormulaDef) Init()</a></dd>
				
			
				
				<dd><a href="#FormulaInst">type FormulaInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FormulaInst.Init">func (me *FormulaInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxAnnotation">type FxAnnotation</a></dd>
				
				
			
				
				<dd><a href="#FxBinding">type FxBinding</a></dd>
				
				
			
				
				<dd><a href="#FxColorOrTexture">type FxColorOrTexture</a></dd>
				
				
			
				
				<dd><a href="#FxCreate">type FxCreate</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2D">type FxCreate2D</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2DSizeExact">type FxCreate2DSizeExact</a></dd>
				
				
			
				
				<dd><a href="#FxCreate2DSizeRatio">type FxCreate2DSizeRatio</a></dd>
				
				
			
				
				<dd><a href="#FxCreate3D">type FxCreate3D</a></dd>
				
				
			
				
				<dd><a href="#FxCreate3DInitFrom">type FxCreate3DInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateCube">type FxCreateCube</a></dd>
				
				
			
				
				<dd><a href="#FxCreateCubeInitFrom">type FxCreateCubeInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateFormat">type FxCreateFormat</a></dd>
				
				
			
				
				<dd><a href="#FxCreateFormatHint">type FxCreateFormatHint</a></dd>
				
				
			
				
				<dd><a href="#FxCreateInitFrom">type FxCreateInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxCreateMips">type FxCreateMips</a></dd>
				
				
			
				
				<dd><a href="#FxEffectDef">type FxEffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectDef.Init">func (me *FxEffectDef) Init()</a></dd>
				
			
				
				<dd><a href="#FxEffectInst">type FxEffectInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxEffectInst.Init">func (me *FxEffectInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxEffectInstTechniqueHint">type FxEffectInstTechniqueHint</a></dd>
				
				
			
				
				<dd><a href="#FxImageDef">type FxImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageDef.Init">func (me *FxImageDef) Init()</a></dd>
				
			
				
				<dd><a href="#FxImageInitFrom">type FxImageInitFrom</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxImageInitFrom">func NewFxImageInitFrom(refUrl string) (me *FxImageInitFrom)</a></dd>
				
				
			
				
				<dd><a href="#FxImageInst">type FxImageInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxImageInst.Init">func (me *FxImageInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxInitFrom">type FxInitFrom</a></dd>
				
				
			
				
				<dd><a href="#FxMaterialDef">type FxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialDef.Init">func (me *FxMaterialDef) Init()</a></dd>
				
			
				
				<dd><a href="#FxMaterialInst">type FxMaterialInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FxMaterialInst.Init">func (me *FxMaterialInst) Init()</a></dd>
				
			
				
				<dd><a href="#FxParamDef">type FxParamDef</a></dd>
				
				
			
				
				<dd><a href="#FxParamDefs">type FxParamDefs</a></dd>
				
				
			
				
				<dd><a href="#FxPass">type FxPass</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxPass">func NewFxPass() (me *FxPass)</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluation">type FxPassEvaluation</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearColor">type FxPassEvaluationClearColor</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearDepth">type FxPassEvaluationClearDepth</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationClearStencil">type FxPassEvaluationClearStencil</a></dd>
				
				
			
				
				<dd><a href="#FxPassEvaluationTarget">type FxPassEvaluationTarget</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxPassEvaluationTarget">func NewFxPassEvaluationTarget() (me *FxPassEvaluationTarget)</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgram">type FxPassProgram</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramBindAttribute">type FxPassProgramBindAttribute</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramBindUniform">type FxPassProgramBindUniform</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramShader">type FxPassProgramShader</a></dd>
				
				
			
				
				<dd><a href="#FxPassProgramShaderSources">type FxPassProgramShaderSources</a></dd>
				
				
			
				
				<dd><a href="#FxPassState">type FxPassState</a></dd>
				
				
			
				
				<dd><a href="#FxProfile">type FxProfile</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProfile">func NewProfile() (me *FxProfile)</a></dd>
				
				
			
				
				<dd><a href="#FxProfileCommon">type FxProfileCommon</a></dd>
				
				
			
				
				<dd><a href="#FxProfileGlSl">type FxProfileGlSl</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxProfileGlSl">func NewFxProfileGlSl() (me *FxProfileGlSl)</a></dd>
				
				
			
				
				<dd><a href="#FxProfileGlSlCodeInclude">type FxProfileGlSlCodeInclude</a></dd>
				
				
			
				
				<dd><a href="#FxSampler">type FxSampler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSampler">func NewFxSampler() (me *FxSampler)</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerFiltering">type FxSamplerFiltering</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerImage">type FxSamplerImage</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerStates">type FxSamplerStates</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSamplerStates">func NewFxSamplerStates() (me *FxSamplerStates)</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerWrapping">type FxSamplerWrapping</a></dd>
				
				
			
				
				<dd><a href="#FxTechnique">type FxTechnique</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommon">type FxTechniqueCommon</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommonBlinn">type FxTechniqueCommonBlinn</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommonConstant">type FxTechniqueCommonConstant</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommonLambert">type FxTechniqueCommonLambert</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueCommonPhong">type FxTechniqueCommonPhong</a></dd>
				
				
			
				
				<dd><a href="#FxTechniqueGlsl">type FxTechniqueGlsl</a></dd>
				
				
			
				
				<dd><a href="#FxTexture">type FxTexture</a></dd>
				
				
			
				
				<dd><a href="#FxVertexInputBinding">type FxVertexInputBinding</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrep">type GeometryBrep</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrep">func NewGeometryBrep() (me *GeometryBrep)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepBox">type GeometryBrepBox</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCapsule">type GeometryBrepCapsule</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCircle">type GeometryBrepCircle</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCone">type GeometryBrepCone</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCurve">type GeometryBrepCurve</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCurves">type GeometryBrepCurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepCylinder">type GeometryBrepCylinder</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepEdges">type GeometryBrepEdges</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepEllipse">type GeometryBrepEllipse</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepFaces">type GeometryBrepFaces</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepHyperbola">type GeometryBrepHyperbola</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepLine">type GeometryBrepLine</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepNurbs">type GeometryBrepNurbs</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrepNurbs">func NewGeometryBrepNurbs() (me *GeometryBrepNurbs)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepNurbsSurface">type GeometryBrepNurbsSurface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryBrepNurbsSurface">func NewGeometryBrepNurbsSurface() (me *GeometryBrepNurbsSurface)</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepOrientation">type GeometryBrepOrientation</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepParabola">type GeometryBrepParabola</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepPcurves">type GeometryBrepPcurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepPlane">type GeometryBrepPlane</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepShells">type GeometryBrepShells</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSolids">type GeometryBrepSolids</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSphere">type GeometryBrepSphere</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurface">type GeometryBrepSurface</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurfaceCurves">type GeometryBrepSurfaceCurves</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSurfaces">type GeometryBrepSurfaces</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepSweptSurface">type GeometryBrepSweptSurface</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepTorus">type GeometryBrepTorus</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrepWires">type GeometryBrepWires</a></dd>
				
				
			
				
				<dd><a href="#GeometryControlVertices">type GeometryControlVertices</a></dd>
				
				
			
				
				<dd><a href="#GeometryDef">type GeometryDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryDef.Init">func (me *GeometryDef) Init()</a></dd>
				
			
				
				<dd><a href="#GeometryInst">type GeometryInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GeometryInst.Init">func (me *GeometryInst) Init()</a></dd>
				
			
				
				<dd><a href="#GeometryMesh">type GeometryMesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryMesh">func NewGeometryMesh() (me *GeometryMesh)</a></dd>
				
				
			
				
				<dd><a href="#GeometryPolygonHole">type GeometryPolygonHole</a></dd>
				
				
			
				
				<dd><a href="#GeometryPrimitives">type GeometryPrimitives</a></dd>
				
				
			
				
				<dd><a href="#GeometrySpline">type GeometrySpline</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometrySpline">func NewGeometrySpline() (me *GeometrySpline)</a></dd>
				
				
			
				
				<dd><a href="#GeometryVertices">type GeometryVertices</a></dd>
				
				
			
				
				<dd><a href="#HasAsset">type HasAsset</a></dd>
				
				
			
				
				<dd><a href="#HasExtras">type HasExtras</a></dd>
				
				
			
				
				<dd><a href="#HasFxParamDefs">type HasFxParamDefs</a></dd>
				
				
			
				
				<dd><a href="#HasId">type HasId</a></dd>
				
				
			
				
				<dd><a href="#HasInputs">type HasInputs</a></dd>
				
				
			
				
				<dd><a href="#HasName">type HasName</a></dd>
				
				
			
				
				<dd><a href="#HasParamDefs">type HasParamDefs</a></dd>
				
				
			
				
				<dd><a href="#HasParamInsts">type HasParamInsts</a></dd>
				
				
			
				
				<dd><a href="#HasSid">type HasSid</a></dd>
				
				
			
				
				<dd><a href="#HasSources">type HasSources</a></dd>
				
				
			
				
				<dd><a href="#HasTechniques">type HasTechniques</a></dd>
				
				
			
				
				<dd><a href="#IndexedInputs">type IndexedInputs</a></dd>
				
				
			
				
				<dd><a href="#Input">type Input</a></dd>
				
				
			
				
				<dd><a href="#InputShared">type InputShared</a></dd>
				
				
			
				
				<dd><a href="#Int2">type Int2</a></dd>
				
				
			
				
				<dd><a href="#Int2x2">type Int2x2</a></dd>
				
				
			
				
				<dd><a href="#Int3">type Int3</a></dd>
				
				
			
				
				<dd><a href="#Int3x3">type Int3x3</a></dd>
				
				
			
				
				<dd><a href="#Int4">type Int4</a></dd>
				
				
			
				
				<dd><a href="#Int4x4">type Int4x4</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemAxisIndex">type KxArticulatedSystemAxisIndex</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemAxisLimits">type KxArticulatedSystemAxisLimits</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemDef">type KxArticulatedSystemDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemDef.Init">func (me *KxArticulatedSystemDef) Init()</a></dd>
				
			
				
				<dd><a href="#KxArticulatedSystemEffector">type KxArticulatedSystemEffector</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxArticulatedSystemEffector">func NewKxArticulatedSystemEffector() (me *KxArticulatedSystemEffector)</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemInst">type KxArticulatedSystemInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxArticulatedSystemInst.Init">func (me *KxArticulatedSystemInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxArticulatedSystemKinematics">type KxArticulatedSystemKinematics</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemKinematicsAxis">type KxArticulatedSystemKinematicsAxis</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxArticulatedSystemKinematicsAxis">func NewKxArticulatedSystemKinematicsAxis() (me *KxArticulatedSystemKinematicsAxis)</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemKinematicsFrame">type KxArticulatedSystemKinematicsFrame</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemMotion">type KxArticulatedSystemMotion</a></dd>
				
				
			
				
				<dd><a href="#KxArticulatedSystemMotionAxis">type KxArticulatedSystemMotionAxis</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewKxArticulatedSystemMotionAxis">func NewKxArticulatedSystemMotionAxis() (me *KxArticulatedSystemMotionAxis)</a></dd>
				
				
			
				
				<dd><a href="#KxAttachment">type KxAttachment</a></dd>
				
				
			
				
				<dd><a href="#KxBinding">type KxBinding</a></dd>
				
				
			
				
				<dd><a href="#KxJoint">type KxJoint</a></dd>
				
				
			
				
				<dd><a href="#KxJointAxisBinding">type KxJointAxisBinding</a></dd>
				
				
			
				
				<dd><a href="#KxJointDef">type KxJointDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointDef.Init">func (me *KxJointDef) Init()</a></dd>
				
			
				
				<dd><a href="#KxJointInst">type KxJointInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxJointInst.Init">func (me *KxJointInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxJointLimits">type KxJointLimits</a></dd>
				
				
			
				
				<dd><a href="#KxLink">type KxLink</a></dd>
				
				
			
				
				<dd><a href="#KxModelBinding">type KxModelBinding</a></dd>
				
				
			
				
				<dd><a href="#KxModelDef">type KxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelDef.Init">func (me *KxModelDef) Init()</a></dd>
				
			
				
				<dd><a href="#KxModelInst">type KxModelInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxModelInst.Init">func (me *KxModelInst) Init()</a></dd>
				
			
				
				<dd><a href="#KxSceneDef">type KxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneDef.Init">func (me *KxSceneDef) Init()</a></dd>
				
			
				
				<dd><a href="#KxSceneInst">type KxSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KxSceneInst.Init">func (me *KxSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#Layers">type Layers</a></dd>
				
				
			
				
				<dd><a href="#LibAnimationClipDefs">type LibAnimationClipDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Add">func (me *LibAnimationClipDefs) Add(d *AnimationClipDef) (n *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.AddNew">func (me *LibAnimationClipDefs) AddNew(id string) *AnimationClipDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Len">func (me *LibAnimationClipDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.New">func (me *LibAnimationClipDefs) New(id string) (def *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Remove">func (me *LibAnimationClipDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.SyncChanges">func (me *LibAnimationClipDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibAnimationDefs">type LibAnimationDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Add">func (me *LibAnimationDefs) Add(d *AnimationDef) (n *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.AddNew">func (me *LibAnimationDefs) AddNew(id string) *AnimationDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Len">func (me *LibAnimationDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.New">func (me *LibAnimationDefs) New(id string) (def *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Remove">func (me *LibAnimationDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.SyncChanges">func (me *LibAnimationDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibCameraDefs">type LibCameraDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Add">func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.AddNew">func (me *LibCameraDefs) AddNew(id string) *CameraDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Len">func (me *LibCameraDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.New">func (me *LibCameraDefs) New(id string) (def *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Remove">func (me *LibCameraDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.SyncChanges">func (me *LibCameraDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibControllerDefs">type LibControllerDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Add">func (me *LibControllerDefs) Add(d *ControllerDef) (n *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.AddNew">func (me *LibControllerDefs) AddNew(id string) *ControllerDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Len">func (me *LibControllerDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.New">func (me *LibControllerDefs) New(id string) (def *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Remove">func (me *LibControllerDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.SyncChanges">func (me *LibControllerDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFormulaDefs">type LibFormulaDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Add">func (me *LibFormulaDefs) Add(d *FormulaDef) (n *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.AddNew">func (me *LibFormulaDefs) AddNew(id string) *FormulaDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Len">func (me *LibFormulaDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.New">func (me *LibFormulaDefs) New(id string) (def *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Remove">func (me *LibFormulaDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.SyncChanges">func (me *LibFormulaDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxEffectDefs">type LibFxEffectDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Add">func (me *LibFxEffectDefs) Add(d *FxEffectDef) (n *FxEffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.AddNew">func (me *LibFxEffectDefs) AddNew(id string) *FxEffectDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Len">func (me *LibFxEffectDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.New">func (me *LibFxEffectDefs) New(id string) (def *FxEffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.Remove">func (me *LibFxEffectDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxEffectDefs.SyncChanges">func (me *LibFxEffectDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxImageDefs">type LibFxImageDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Add">func (me *LibFxImageDefs) Add(d *FxImageDef) (n *FxImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.AddFromRefUrls">func (me *LibFxImageDefs) AddFromRefUrls(idRefUrls map[string]string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.AddNew">func (me *LibFxImageDefs) AddNew(id string) *FxImageDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Len">func (me *LibFxImageDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.New">func (me *LibFxImageDefs) New(id string) (def *FxImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.Remove">func (me *LibFxImageDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxImageDefs.SyncChanges">func (me *LibFxImageDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFxMaterialDefs">type LibFxMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Add">func (me *LibFxMaterialDefs) Add(d *FxMaterialDef) (n *FxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.AddNew">func (me *LibFxMaterialDefs) AddNew(id string) *FxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Len">func (me *LibFxMaterialDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.New">func (me *LibFxMaterialDefs) New(id string) (def *FxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.Remove">func (me *LibFxMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFxMaterialDefs.SyncChanges">func (me *LibFxMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibGeometryDefs">type LibGeometryDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Add">func (me *LibGeometryDefs) Add(d *GeometryDef) (n *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.AddNew">func (me *LibGeometryDefs) AddNew(id string) *GeometryDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Len">func (me *LibGeometryDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.New">func (me *LibGeometryDefs) New(id string) (def *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Remove">func (me *LibGeometryDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.SyncChanges">func (me *LibGeometryDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxArticulatedSystemDefs">type LibKxArticulatedSystemDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Add">func (me *LibKxArticulatedSystemDefs) Add(d *KxArticulatedSystemDef) (n *KxArticulatedSystemDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.AddNew">func (me *LibKxArticulatedSystemDefs) AddNew(id string) *KxArticulatedSystemDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Len">func (me *LibKxArticulatedSystemDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.New">func (me *LibKxArticulatedSystemDefs) New(id string) (def *KxArticulatedSystemDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.Remove">func (me *LibKxArticulatedSystemDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxArticulatedSystemDefs.SyncChanges">func (me *LibKxArticulatedSystemDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxJointDefs">type LibKxJointDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Add">func (me *LibKxJointDefs) Add(d *KxJointDef) (n *KxJointDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.AddNew">func (me *LibKxJointDefs) AddNew(id string) *KxJointDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Len">func (me *LibKxJointDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.New">func (me *LibKxJointDefs) New(id string) (def *KxJointDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.Remove">func (me *LibKxJointDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxJointDefs.SyncChanges">func (me *LibKxJointDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxModelDefs">type LibKxModelDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Add">func (me *LibKxModelDefs) Add(d *KxModelDef) (n *KxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.AddNew">func (me *LibKxModelDefs) AddNew(id string) *KxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Len">func (me *LibKxModelDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.New">func (me *LibKxModelDefs) New(id string) (def *KxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.Remove">func (me *LibKxModelDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxModelDefs.SyncChanges">func (me *LibKxModelDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibKxSceneDefs">type LibKxSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Add">func (me *LibKxSceneDefs) Add(d *KxSceneDef) (n *KxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.AddNew">func (me *LibKxSceneDefs) AddNew(id string) *KxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Len">func (me *LibKxSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.New">func (me *LibKxSceneDefs) New(id string) (def *KxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.Remove">func (me *LibKxSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibKxSceneDefs.SyncChanges">func (me *LibKxSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibLightDefs">type LibLightDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Add">func (me *LibLightDefs) Add(d *LightDef) (n *LightDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.AddNew">func (me *LibLightDefs) AddNew(id string) *LightDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Len">func (me *LibLightDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.New">func (me *LibLightDefs) New(id string) (def *LightDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.Remove">func (me *LibLightDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibLightDefs.SyncChanges">func (me *LibLightDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibNodeDefs">type LibNodeDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Add">func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.AddNew">func (me *LibNodeDefs) AddNew(id string) *NodeDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Len">func (me *LibNodeDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.New">func (me *LibNodeDefs) New(id string) (def *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Remove">func (me *LibNodeDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.SyncChanges">func (me *LibNodeDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxForceFieldDefs">type LibPxForceFieldDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Add">func (me *LibPxForceFieldDefs) Add(d *PxForceFieldDef) (n *PxForceFieldDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.AddNew">func (me *LibPxForceFieldDefs) AddNew(id string) *PxForceFieldDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Len">func (me *LibPxForceFieldDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.New">func (me *LibPxForceFieldDefs) New(id string) (def *PxForceFieldDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.Remove">func (me *LibPxForceFieldDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxForceFieldDefs.SyncChanges">func (me *LibPxForceFieldDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxMaterialDefs">type LibPxMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Add">func (me *LibPxMaterialDefs) Add(d *PxMaterialDef) (n *PxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.AddNew">func (me *LibPxMaterialDefs) AddNew(id string) *PxMaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Len">func (me *LibPxMaterialDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.New">func (me *LibPxMaterialDefs) New(id string) (def *PxMaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.Remove">func (me *LibPxMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxMaterialDefs.SyncChanges">func (me *LibPxMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxModelDefs">type LibPxModelDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Add">func (me *LibPxModelDefs) Add(d *PxModelDef) (n *PxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.AddNew">func (me *LibPxModelDefs) AddNew(id string) *PxModelDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Len">func (me *LibPxModelDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.New">func (me *LibPxModelDefs) New(id string) (def *PxModelDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.Remove">func (me *LibPxModelDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxModelDefs.SyncChanges">func (me *LibPxModelDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibPxSceneDefs">type LibPxSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Add">func (me *LibPxSceneDefs) Add(d *PxSceneDef) (n *PxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.AddNew">func (me *LibPxSceneDefs) AddNew(id string) *PxSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Len">func (me *LibPxSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.New">func (me *LibPxSceneDefs) New(id string) (def *PxSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.Remove">func (me *LibPxSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibPxSceneDefs.SyncChanges">func (me *LibPxSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibVisualSceneDefs">type LibVisualSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Add">func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.AddNew">func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Len">func (me *LibVisualSceneDefs) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.New">func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Remove">func (me *LibVisualSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.SyncChanges">func (me *LibVisualSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibsAnimationClipDef">type LibsAnimationClipDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsAnimationClipDef.AddNew">func (me LibsAnimationClipDef) AddNew(id string) (lib *LibAnimationClipDefs)</a></dd>
				
			
				
				<dd><a href="#LibsAnimationDef">type LibsAnimationDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsAnimationDef.AddNew">func (me LibsAnimationDef) AddNew(id string) (lib *LibAnimationDefs)</a></dd>
				
			
				
				<dd><a href="#LibsCameraDef">type LibsCameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsCameraDef.AddNew">func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</a></dd>
				
			
				
				<dd><a href="#LibsControllerDef">type LibsControllerDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsControllerDef.AddNew">func (me LibsControllerDef) AddNew(id string) (lib *LibControllerDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFormulaDef">type LibsFormulaDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFormulaDef.AddNew">func (me LibsFormulaDef) AddNew(id string) (lib *LibFormulaDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxEffectDef">type LibsFxEffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxEffectDef.AddNew">func (me LibsFxEffectDef) AddNew(id string) (lib *LibFxEffectDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxImageDef">type LibsFxImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxImageDef.AddNew">func (me LibsFxImageDef) AddNew(id string) (lib *LibFxImageDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFxMaterialDef">type LibsFxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFxMaterialDef.AddNew">func (me LibsFxMaterialDef) AddNew(id string) (lib *LibFxMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsGeometryDef">type LibsGeometryDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsGeometryDef.AddNew">func (me LibsGeometryDef) AddNew(id string) (lib *LibGeometryDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxArticulatedSystemDef">type LibsKxArticulatedSystemDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxArticulatedSystemDef.AddNew">func (me LibsKxArticulatedSystemDef) AddNew(id string) (lib *LibKxArticulatedSystemDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxJointDef">type LibsKxJointDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxJointDef.AddNew">func (me LibsKxJointDef) AddNew(id string) (lib *LibKxJointDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxModelDef">type LibsKxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxModelDef.AddNew">func (me LibsKxModelDef) AddNew(id string) (lib *LibKxModelDefs)</a></dd>
				
			
				
				<dd><a href="#LibsKxSceneDef">type LibsKxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsKxSceneDef.AddNew">func (me LibsKxSceneDef) AddNew(id string) (lib *LibKxSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LibsLightDef">type LibsLightDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsLightDef.AddNew">func (me LibsLightDef) AddNew(id string) (lib *LibLightDefs)</a></dd>
				
			
				
				<dd><a href="#LibsNodeDef">type LibsNodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsNodeDef.AddNew">func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxForceFieldDef">type LibsPxForceFieldDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxForceFieldDef.AddNew">func (me LibsPxForceFieldDef) AddNew(id string) (lib *LibPxForceFieldDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxMaterialDef">type LibsPxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxMaterialDef.AddNew">func (me LibsPxMaterialDef) AddNew(id string) (lib *LibPxMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxModelDef">type LibsPxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxModelDef.AddNew">func (me LibsPxModelDef) AddNew(id string) (lib *LibPxModelDefs)</a></dd>
				
			
				
				<dd><a href="#LibsPxSceneDef">type LibsPxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsPxSceneDef.AddNew">func (me LibsPxSceneDef) AddNew(id string) (lib *LibPxSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LibsVisualSceneDef">type LibsVisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsVisualSceneDef.AddNew">func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</a></dd>
				
			
				
				<dd><a href="#LightAmbient">type LightAmbient</a></dd>
				
				
			
				
				<dd><a href="#LightAttenuation">type LightAttenuation</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightAttenuation">func NewLightAttenuation() (me *LightAttenuation)</a></dd>
				
				
			
				
				<dd><a href="#LightBase">type LightBase</a></dd>
				
				
			
				
				<dd><a href="#LightDef">type LightDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LightDef.Init">func (me *LightDef) Init()</a></dd>
				
			
				
				<dd><a href="#LightDirectional">type LightDirectional</a></dd>
				
				
			
				
				<dd><a href="#LightInst">type LightInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LightInst.Init">func (me *LightInst) Init()</a></dd>
				
			
				
				<dd><a href="#LightPoint">type LightPoint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightPoint">func NewLightPoint() (me *LightPoint)</a></dd>
				
				
			
				
				<dd><a href="#LightSpot">type LightSpot</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLightSpot">func NewLightSpot() (me *LightSpot)</a></dd>
				
				
			
				
				<dd><a href="#MaterialBinding">type MaterialBinding</a></dd>
				
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddFaces">func (me *MeshData) AddFaces(faces ...MeshFace3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddNormals">func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddPositions">func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddTexCoords">func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</a></dd>
				
			
				
				<dd><a href="#MeshFace3">type MeshFace3</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#MeshRaw">type MeshRaw</a></dd>
				
				
			
				
				<dd><a href="#MeshRawFace">type MeshRawFace</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshRawFace">func NewMeshRawFace() (me *MeshRawFace)</a></dd>
				
				
			
				
				<dd><a href="#MeshVert">type MeshVert</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt2">type MeshVertAtt2</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt3">type MeshVertAtt3</a></dd>
				
				
			
				
				<dd><a href="#NodeDef">type NodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.Init">func (me *NodeDef) Init()</a></dd>
				
			
				
				<dd><a href="#NodeInst">type NodeInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeInst.Init">func (me *NodeInst) Init()</a></dd>
				
			
				
				<dd><a href="#Param">type Param</a></dd>
				
				
			
				
				<dd><a href="#ParamBool">type ParamBool</a></dd>
				
				
			
				
				<dd><a href="#ParamDef">type ParamDef</a></dd>
				
				
			
				
				<dd><a href="#ParamDefs">type ParamDefs</a></dd>
				
				
			
				
				<dd><a href="#ParamFloat">type ParamFloat</a></dd>
				
				
			
				
				<dd><a href="#ParamFloat2">type ParamFloat2</a></dd>
				
				
			
				
				<dd><a href="#ParamInst">type ParamInst</a></dd>
				
				
			
				
				<dd><a href="#ParamInt">type ParamInt</a></dd>
				
				
			
				
				<dd><a href="#ParamScopedFloat">type ParamScopedFloat</a></dd>
				
				
			
				
				<dd><a href="#ParamSidRef">type ParamSidRef</a></dd>
				
				
			
				
				<dd><a href="#ParamUint">type ParamUint</a></dd>
				
				
			
				
				<dd><a href="#PxCylinder">type PxCylinder</a></dd>
				
				
			
				
				<dd><a href="#PxForceFieldDef">type PxForceFieldDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldDef.Init">func (me *PxForceFieldDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxForceFieldInst">type PxForceFieldInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxForceFieldInst.Init">func (me *PxForceFieldInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxMaterial">type PxMaterial</a></dd>
				
				
			
				
				<dd><a href="#PxMaterialDef">type PxMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialDef.Init">func (me *PxMaterialDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxMaterialInst">type PxMaterialInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxMaterialInst.Init">func (me *PxMaterialInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxModelDef">type PxModelDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelDef.Init">func (me *PxModelDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxModelInst">type PxModelInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxModelInst.Init">func (me *PxModelInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidBodyCommon">type PxRigidBodyCommon</a></dd>
				
				
			
				
				<dd><a href="#PxRigidBodyDef">type PxRigidBodyDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidBodyDef.Init">func (me *PxRigidBodyDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidBodyInst">type PxRigidBodyInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidBodyInst.Init">func (me *PxRigidBodyInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintAttachment">type PxRigidConstraintAttachment</a></dd>
				
				
			
				
				<dd><a href="#PxRigidConstraintDef">type PxRigidConstraintDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidConstraintDef.Init">func (me *PxRigidConstraintDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintInst">type PxRigidConstraintInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxRigidConstraintInst.Init">func (me *PxRigidConstraintInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxRigidConstraintLimit">type PxRigidConstraintLimit</a></dd>
				
				
			
				
				<dd><a href="#PxRigidConstraintSpring">type PxRigidConstraintSpring</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPxRigidConstraintSpring">func NewPxRigidConstraintSpring() (me *PxRigidConstraintSpring)</a></dd>
				
				
			
				
				<dd><a href="#PxSceneDef">type PxSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneDef.Init">func (me *PxSceneDef) Init()</a></dd>
				
			
				
				<dd><a href="#PxSceneInst">type PxSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PxSceneInst.Init">func (me *PxSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#PxShape">type PxShape</a></dd>
				
				
			
				
				<dd><a href="#RefId">type RefId</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.S">func (me RefId) S() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefId.Set">func (me *RefId) Set(v string)</a></dd>
				
			
				
				<dd><a href="#RefParam">type RefParam</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefParam.S">func (me RefParam) S() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefParam.Set">func (me *RefParam) Set(v string)</a></dd>
				
			
				
				<dd><a href="#RefSid">type RefSid</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RefSid.S">func (me RefSid) S() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RefSid.Set">func (me *RefSid) Set(v string)</a></dd>
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
				
			
				
				<dd><a href="#ScopedBool">type ScopedBool</a></dd>
				
				
			
				
				<dd><a href="#ScopedFloat">type ScopedFloat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scopedf">func Scopedf(f float64) (sf ScopedFloat)</a></dd>
				
				
			
				
				<dd><a href="#ScopedFloat3">type ScopedFloat3</a></dd>
				
				
			
				
				<dd><a href="#ScopedString">type ScopedString</a></dd>
				
				
			
				
				<dd><a href="#ScopedVec3">type ScopedVec3</a></dd>
				
				
			
				
				<dd><a href="#Source">type Source</a></dd>
				
				
			
				
				<dd><a href="#SourceAccessor">type SourceAccessor</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSourceAccessor">func NewSourceAccessor() (me *SourceAccessor)</a></dd>
				
				
			
				
				<dd><a href="#Sources">type Sources</a></dd>
				
				
			
				
				<dd><a href="#Technique">type Technique</a></dd>
				
				
			
				
				<dd><a href="#Transform">type Transform</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneDef">type VisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneDef.Init">func (me *VisualSceneDef) Init()</a></dd>
				
			
				
				<dd><a href="#VisualSceneEvaluation">type VisualSceneEvaluation</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneInst">type VisualSceneInst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneInst.Init">func (me *VisualSceneInst) Init()</a></dd>
				
			
				
				<dd><a href="#VisualSceneRendering">type VisualSceneRendering</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewVisualSceneRendering">func NewVisualSceneRendering() (me *VisualSceneRendering)</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneRenderingMaterialInst">type VisualSceneRenderingMaterialInst</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/-pkgreflect.go">-pkgreflect.go</a>
			
				<a href="/target/animation.gt.go">animation.gt.go</a>
			
				<a href="/target/animationclip.gt.go">animationclip.gt.go</a>
			
				<a href="/target/assets.go">assets.go</a>
			
				<a href="/target/base.go">base.go</a>
			
				<a href="/target/camera.gt.go">camera.gt.go</a>
			
				<a href="/target/common.go">common.go</a>
			
				<a href="/target/controller.gt.go">controller.gt.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/formula.gt.go">formula.gt.go</a>
			
				<a href="/target/fxeffect.gt.go">fxeffect.gt.go</a>
			
				<a href="/target/fximage.gt.go">fximage.gt.go</a>
			
				<a href="/target/fxmaterial.gt.go">fxmaterial.gt.go</a>
			
				<a href="/target/fxsampler.go">fxsampler.go</a>
			
				<a href="/target/geometry.gt.go">geometry.gt.go</a>
			
				<a href="/target/geometrybrep.go">geometrybrep.go</a>
			
				<a href="/target/kxarticulatedsystem.gt.go">kxarticulatedsystem.gt.go</a>
			
				<a href="/target/kxjoint.gt.go">kxjoint.gt.go</a>
			
				<a href="/target/kxmodel.gt.go">kxmodel.gt.go</a>
			
				<a href="/target/kxscene.gt.go">kxscene.gt.go</a>
			
				<a href="/target/light.gt.go">light.gt.go</a>
			
				<a href="/target/meshdata.go">meshdata.go</a>
			
				<a href="/target/node.gt.go">node.gt.go</a>
			
				<a href="/target/pxforcefield.gt.go">pxforcefield.gt.go</a>
			
				<a href="/target/pxmaterial.gt.go">pxmaterial.gt.go</a>
			
				<a href="/target/pxmodel.gt.go">pxmodel.gt.go</a>
			
				<a href="/target/pxrigidbody.go">pxrigidbody.go</a>
			
				<a href="/target/pxrigidconstraint.go">pxrigidconstraint.go</a>
			
				<a href="/target/pxscene.gt.go">pxscene.gt.go</a>
			
				<a href="/target/source.go">source.go</a>
			
				<a href="/target/types.go">types.go</a>
			
				<a href="/target/visualscene.gt.go">visualscene.gt.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    <span class="comment">//	The before and after behaviors are not defined.</span>
    ANIM_SAMPLER_BEHAVIOR_UNDEFINED = 0

    <span class="comment">//	The value for the first (PreBehavior) or last (PostBehavior) is returned.</span>
    ANIM_SAMPLER_BEHAVIOR_CONSTANT = iota

    <span class="comment">//	The key is mapped in the [first_key , last_key] interval so that the animation cycles.</span>
    ANIM_SAMPLER_BEHAVIOR_CYCLE = iota

    <span class="comment">//	The animation continues indefinitely.</span>
    ANIM_SAMPLER_BEHAVIOR_CYCLE_RELATIVE = iota

    <span class="comment">//	The value follows the line given by the last two keys in the sample.</span>
    ANIM_SAMPLER_BEHAVIOR_GRADIENT = iota

    <span class="comment">//	The key is mapped in the [first_key , last_key] interval so that the animation oscillates.</span>
    ANIM_SAMPLER_BEHAVIOR_OSCILLATE = iota
)</pre>
				
			
				<pre>const (
    <span class="comment">//	A position and orientation transformation suitable for aiming a camera.</span>
    TRANSFORM_TYPE_LOOKAT = 1
    <span class="comment">//	A transformation that embodies mathematical changes to points within a coordinate system or the coordinate system itself.</span>
    TRANSFORM_TYPE_MATRIX = iota
    <span class="comment">//	A transformation that specifies how to rotate an object around an axis.</span>
    TRANSFORM_TYPE_ROTATE = iota
    <span class="comment">//	A transformation that specifies how to deform an object along one axis.</span>
    TRANSFORM_TYPE_SKEW = iota
    <span class="comment">//	A transformation that specifies how to change an object&#39;s size.</span>
    TRANSFORM_TYPE_SCALE = iota
    <span class="comment">//	A transformation that changes the position of an object in a local coordinate system.</span>
    TRANSFORM_TYPE_TRANSLATE = iota
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Takes the transparency information from the color&#39;s alpha channel, where the value 1.0 is opaque.</span>
    FX_COLOR_TEXTURE_OPAQUE_A_ZERO = 0
    <span class="comment">//	Takes the transparency information from the color&#39;s red, green, and blue channels, where the value 0.0 is opaque, with each channel modulated independently.</span>
    FX_COLOR_TEXTURE_OPAQUE_A_ONE = 1
    <span class="comment">//	Takes the transparency information from the color’s alpha channel, where the value 0.0 is opaque.</span>
    FX_COLOR_TEXTURE_OPAQUE_RGB_ZERO = 2
    <span class="comment">//	Takes the transparency information from the color’s red, green, and blue channels, where the value 1.0 is opaque, with each channel modulated independently.</span>
    FX_COLOR_TEXTURE_OPAQUE_RGB_ONE = 3

    FX_PASS_PROGRAM_SHADER_STAGE_TESSELATION = 0
    FX_PASS_PROGRAM_SHADER_STAGE_VERTEX      = 1
    FX_PASS_PROGRAM_SHADER_STAGE_GEOMETRY    = 2
    FX_PASS_PROGRAM_SHADER_STAGE_FRAGMENT    = 3
    FX_PASS_PROGRAM_SHADER_STAGE_COMPUTE     = 4
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Depth map, often used for displacement, parellax, relief, or shadow mapping.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_D = 1
    <span class="comment">//	Luminance map, often used for light mapping.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_L = iota
    <span class="comment">//	Luminance with alpha map, often used for light mapping.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_LA = iota
    <span class="comment">//	RGB color map</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_RGB = iota
    <span class="comment">//	RGB color with alpha map. Often used for color plus transparency or other things packed into channel A, such as specular power.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_RGBA = iota
    <span class="comment">//	RGB color with shared exponent for HDR.</span>
    FX_CREATE_FORMAT_HINT_CHANNELS_RGBE = iota
    <span class="comment">//	Designer does not care as long as it provides “reasonable” precision and performance.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_DEFAULT = 1
    <span class="comment">//	For integers, this typically represents 16 to 32 bits. For floating points, typically 24 to 32 bits.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_HIGH = iota
    <span class="comment">//	For integers, this typically represents 8 bits. For floating points, typically 16 bits.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_LOW = iota
    <span class="comment">//	Typically 32 bits or 64 bits if available. 64 bits has been separated into its own category beyond HIGH because it typically has significant performance impact and is beyond what non-CAD software considers high precision.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_MAX = iota
    <span class="comment">//	For integers, this typically represents 8 to 24 bits. For floating points, typically 16 to 32 bits.</span>
    FX_CREATE_FORMAT_HINT_PRECISION_MID = iota
    <span class="comment">//	Format should support full floating-point ranges. High precision is expected to be 32 bits. Mid precision may be 16 to 32 bits. Low precision is expected to be 16 bits.</span>
    FX_CREATE_FORMAT_HINT_RANGE_FLOAT = 1
    <span class="comment">//	Format represents signed integer numbers. For example, 8 bits is -128 to 127.</span>
    FX_CREATE_FORMAT_HINT_RANGE_SINT = iota
    <span class="comment">//	Format represents a decimal value that remains within the -1 to 1 range. Implementation could be integer-fixed-point or floating point.</span>
    FX_CREATE_FORMAT_HINT_RANGE_SNORM = iota
    <span class="comment">//	Format represent unsigned integer numbers. For example, 8 bits is 0 to 255.</span>
    FX_CREATE_FORMAT_HINT_RANGE_UINT = iota
    <span class="comment">//	Format represents a decimal value that remains within the 0 to 1 range. Implementation could be integer-fixed-point or floating point.</span>
    FX_CREATE_FORMAT_HINT_RANGE_UNORM = iota
    <span class="comment">//	Cube-map face target &#34;X negative&#34;</span>
    FX_CUBE_FACE_NEGATIVE_X = 0x8516
    <span class="comment">//	Cube-map face target &#34;Y negative&#34;</span>
    FX_CUBE_FACE_NEGATIVE_Y = 0x8518
    <span class="comment">//	Cube-map face target &#34;Z negative&#34;</span>
    FX_CUBE_FACE_NEGATIVE_Z = 0x851A
    <span class="comment">//	Cube-map face target &#34;X positive&#34;</span>
    FX_CUBE_FACE_POSITIVE_X = 0x8515
    <span class="comment">//	Cube-map face target &#34;Y positive&#34;</span>
    FX_CUBE_FACE_POSITIVE_Y = 0x8517
    <span class="comment">//	Cube-map face target &#34;Z positive&#34;</span>
    FX_CUBE_FACE_POSITIVE_Z = 0x8519
)</pre>
				
			
				<pre>const (
    <span class="comment">//	No MIP-mapped minification.</span>
    FX_SAMPLER_FILTER_NONE = 20
    <span class="comment">//	Bilinear filtering.</span>
    FX_SAMPLER_FILTER_NEAREST = 0x2600
    <span class="comment">//	Trilinear filtering.</span>
    FX_SAMPLER_FILTER_LINEAR = 0x2601
    <span class="comment">//	Compensates for distortion caused by the difference in angle between the polygon and the plane of the screen.</span>
    FX_SAMPLER_FILTER_ANISOTROPIC = 21

    <span class="comment">//	Declares a one-dimensional texture sampler.</span>
    FX_SAMPLER_TYPE_1D = 0x8B5D
    <span class="comment">//	Declares a two-dimensional texture sampler.</span>
    FX_SAMPLER_TYPE_2D = 0x8B5E
    <span class="comment">//	Declares a three-dimensional texture sampler.</span>
    FX_SAMPLER_TYPE_3D = 0x8B5F
    <span class="comment">//	Declares a texture sampler for cube maps.</span>
    FX_SAMPLER_TYPE_CUBE = 0x8B60
    <span class="comment">//	Declares a texture sampler for depth maps.</span>
    FX_SAMPLER_TYPE_DEPTH = 30
    <span class="comment">//	Declares a rectangular texture sampler.</span>
    FX_SAMPLER_TYPE_RECT = 31

    <span class="comment">//	Ignores the integer part of texture coordinates, using only the fractional part. Tiles the texture at every integer junction. For example, for u values between 0 and 3, the texture is repeated three times; no mirroring is performed.</span>
    FX_SAMPLER_WRAP_WRAP = 0x2901
    <span class="comment">//	First mirrors the texture coordinate. The mirrored coordinate is then clamped as described for FX_SAMPLER_WRAP_CLAMP. Flips the texture at every integer junction. For u values between 0 and 1, for example, the texture is addressed normally; between 1 and 2, the texture is flipped (mirrored); between 2 and 3, the texture is normal again; and so on.</span>
    FX_SAMPLER_WRAP_MIRROR = 0x8370
    <span class="comment">//	Clamps texture coordinates at all MIPmap levels such that the texture filter never samples a border texel.</span>
    FX_SAMPLER_WRAP_CLAMP = 0x812F
    <span class="comment">//	Clamps texture coordinates at all MIPmaps such that the texture filter always samples border texels for fragments whose corresponding texture coordinate is sufficiently far outside the range [0, 1]. Much like FX_SAMPLER_WRAP_CLAMP, except texture coordinates outside the range [0.0, 1.0] are set to the border color.</span>
    FX_SAMPLER_WRAP_BORDER = 0x812D
    <span class="comment">//	Takes the absolute value of the texture coordinate (thus, mirroring around 0), and then clamps to the maximum value.</span>
    FX_SAMPLER_WRAP_MIRROR_ONCE = 40
)</pre>
				
			
				<pre>const (
    GEOMETRY_PRIMITIVE_TYPE_LINES       = 0x0001
    GEOMETRY_PRIMITIVE_TYPE_LINE_STRIPS = 0x0003
    GEOMETRY_PRIMITIVE_TYPE_POLYGONS    = 2
    GEOMETRY_PRIMITIVE_TYPE_POLYLIST    = 7
    GEOMETRY_PRIMITIVE_TYPE_TRIANGLES   = 0x0004
    GEOMETRY_PRIMITIVE_TYPE_TRIFANS     = 0x0006
    GEOMETRY_PRIMITIVE_TYPE_TRISTRIPS   = 0x0005
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Defines the base frame for kinematics calculation.</span>
    KX_FRAME_TYPE_ORIGIN = 1
    <span class="comment">//	Defines the frame at the end of the kinematics chain.</span>
    KX_FRAME_TYPE_TIP = iota
    <span class="comment">//	Defines the offset frame from the kinematics KX_FRAME_TYPE_TIP frame, which usually represents the work point of the end effector (for example, a welding gun).</span>
    KX_FRAME_TYPE_TCP = iota
    <span class="comment">//	Defines the offset frame from the kinematics KX_FRAME_TYPE_ORIGIN frame; this offset usually represents the transformation to a work piece.</span>
    KX_FRAME_TYPE_OBJECT = iota
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Defines a single translational degree of freedom of a joint.</span>
    KX_JOINT_TYPE_PRISMATIC = 1
    <span class="comment">//	Defines a single rotational degree of freedom of a joint.</span>
    KX_JOINT_TYPE_REVOLUTE = iota
)</pre>
				
			
				<pre>const (
    <span class="comment">//	Connects two links, describing a real parent-child dependency between them.</span>
    KX_ATTACHMENT_TYPE_FULL = 1
    <span class="comment">//	Connects two links and defines one end of a closed loop.</span>
    KX_ATTACHMENT_TYPE_START = iota
    <span class="comment">//	Defines one end of the closed loop in an attachment.</span>
    KX_ATTACHMENT_TYPE_END = iota
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibAnimationDefs* libraries associated by their *Id*.</span>
    AllAnimationDefLibs = LibsAnimationDef{}

    <span class="comment">//	The &#34;default&#34; *LibAnimationDefs* library for *AnimationDef*s.</span>
    AnimationDefs = AllAnimationDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibAnimationClipDefs* libraries associated by their *Id*.</span>
    AllAnimationClipDefLibs = LibsAnimationClipDef{}

    <span class="comment">//	The &#34;default&#34; *LibAnimationClipDefs* library for *AnimationClipDef*s.</span>
    AnimationClipDefs = AllAnimationClipDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	This callback, set by *core* (or your custom package), gets called before SyncChanges() proceeds with syncing.</span>
    OnBeforeSyncAll func()

    <span class="comment">//	This callback, set by *core* (or your custom package), gets called after SyncChanges() has finished syncing.</span>
    OnAfterSyncAll func()

    <span class="comment">//	Your default unit-in-meters for geometry, coordinates and transformations.</span>
    <span class="comment">//	If a unit represents:</span>
    <span class="comment">//	- a meter, set to 1;</span>
    <span class="comment">//	- a centimeter, set to 0.01;</span>
    <span class="comment">//	- a kilometer, set to 1000;</span>
    <span class="comment">//	- an inch, set to 0.02539999969303608... etc.</span>
    <span class="comment">//	The *assets* package does not support multiple different or individual per-asset units.</span>
    <span class="comment">//	This is ONLY used when importing assets that specify their own unit-in-meters, those will be re-scaled to this unit.</span>
    <span class="comment">//	If you need to customize this value, do so before populating the *assets* package&#39;s libraries.</span>
    UnitInMeters float64 = 1
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibCameraDefs* libraries associated by their *Id*.</span>
    AllCameraDefLibs = LibsCameraDef{}

    <span class="comment">//	The &#34;default&#34; *LibCameraDefs* library for *CameraDef*s.</span>
    CameraDefs = AllCameraDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibControllerDefs* libraries associated by their *Id*.</span>
    AllControllerDefLibs = LibsControllerDef{}

    <span class="comment">//	The &#34;default&#34; *LibControllerDefs* library for *ControllerDef*s.</span>
    ControllerDefs = AllControllerDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibFormulaDefs* libraries associated by their *Id*.</span>
    AllFormulaDefLibs = LibsFormulaDef{}

    <span class="comment">//	The &#34;default&#34; *LibFormulaDefs* library for *FormulaDef*s.</span>
    FormulaDefs = AllFormulaDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibFxEffectDefs* libraries associated by their *Id*.</span>
    AllFxEffectDefLibs = LibsFxEffectDef{}

    <span class="comment">//	The &#34;default&#34; *LibFxEffectDefs* library for *FxEffectDef*s.</span>
    FxEffectDefs = AllFxEffectDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibFxImageDefs* libraries associated by their *Id*.</span>
    AllFxImageDefLibs = LibsFxImageDef{}

    <span class="comment">//	The &#34;default&#34; *LibFxImageDefs* library for *FxImageDef*s.</span>
    FxImageDefs = AllFxImageDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibFxMaterialDefs* libraries associated by their *Id*.</span>
    AllFxMaterialDefLibs = LibsFxMaterialDef{}

    <span class="comment">//	The &#34;default&#34; *LibFxMaterialDefs* library for *FxMaterialDef*s.</span>
    FxMaterialDefs = AllFxMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	Default texture minification, magnification and MIP-mapping.</span>
    DefaultFxSamplerFiltering = &amp;FxSamplerFiltering{
        FilterMag:     FX_SAMPLER_FILTER_LINEAR,
        FilterMin:     FX_SAMPLER_FILTER_LINEAR,
        FilterMip:     FX_SAMPLER_FILTER_LINEAR,
        MaxAnisotropy: 1,
    }
    <span class="comment">//	Default texture repeating and clamping.</span>
    DefaultFxSamplerWrapping = &amp;FxSamplerWrapping{
        BorderColor: ugfx.Rgba32{R: 0, G: 0, B: 0, A: 1},
        WrapS:       FX_SAMPLER_WRAP_WRAP,
        WrapT:       FX_SAMPLER_WRAP_WRAP,
        WrapP:       FX_SAMPLER_WRAP_WRAP,
    }
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibGeometryDefs* libraries associated by their *Id*.</span>
    AllGeometryDefLibs = LibsGeometryDef{}

    <span class="comment">//	The &#34;default&#34; *LibGeometryDefs* library for *GeometryDef*s.</span>
    GeometryDefs = AllGeometryDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibKxArticulatedSystemDefs* libraries associated by their *Id*.</span>
    AllKxArticulatedSystemDefLibs = LibsKxArticulatedSystemDef{}

    <span class="comment">//	The &#34;default&#34; *LibKxArticulatedSystemDefs* library for *KxArticulatedSystemDef*s.</span>
    KxArticulatedSystemDefs = AllKxArticulatedSystemDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibKxJointDefs* libraries associated by their *Id*.</span>
    AllKxJointDefLibs = LibsKxJointDef{}

    <span class="comment">//	The &#34;default&#34; *LibKxJointDefs* library for *KxJointDef*s.</span>
    KxJointDefs = AllKxJointDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibKxModelDefs* libraries associated by their *Id*.</span>
    AllKxModelDefLibs = LibsKxModelDef{}

    <span class="comment">//	The &#34;default&#34; *LibKxModelDefs* library for *KxModelDef*s.</span>
    KxModelDefs = AllKxModelDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibKxSceneDefs* libraries associated by their *Id*.</span>
    AllKxSceneDefLibs = LibsKxSceneDef{}

    <span class="comment">//	The &#34;default&#34; *LibKxSceneDefs* library for *KxSceneDef*s.</span>
    KxSceneDefs = AllKxSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibLightDefs* libraries associated by their *Id*.</span>
    AllLightDefLibs = LibsLightDef{}

    <span class="comment">//	The &#34;default&#34; *LibLightDefs* library for *LightDef*s.</span>
    LightDefs = AllLightDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibNodeDefs* libraries associated by their *Id*.</span>
    AllNodeDefLibs = LibsNodeDef{}

    <span class="comment">//	The &#34;default&#34; *LibNodeDefs* library for *NodeDef*s.</span>
    NodeDefs = AllNodeDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibPxForceFieldDefs* libraries associated by their *Id*.</span>
    AllPxForceFieldDefLibs = LibsPxForceFieldDef{}

    <span class="comment">//	The &#34;default&#34; *LibPxForceFieldDefs* library for *PxForceFieldDef*s.</span>
    PxForceFieldDefs = AllPxForceFieldDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibPxMaterialDefs* libraries associated by their *Id*.</span>
    AllPxMaterialDefLibs = LibsPxMaterialDef{}

    <span class="comment">//	The &#34;default&#34; *LibPxMaterialDefs* library for *PxMaterialDef*s.</span>
    PxMaterialDefs = AllPxMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibPxModelDefs* libraries associated by their *Id*.</span>
    AllPxModelDefLibs = LibsPxModelDef{}

    <span class="comment">//	The &#34;default&#34; *LibPxModelDefs* library for *PxModelDef*s.</span>
    PxModelDefs = AllPxModelDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibPxSceneDefs* libraries associated by their *Id*.</span>
    AllPxSceneDefLibs = LibsPxSceneDef{}

    <span class="comment">//	The &#34;default&#34; *LibPxSceneDefs* library for *PxSceneDef*s.</span>
    PxSceneDefs = AllPxSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibVisualSceneDefs* libraries associated by their *Id*.</span>
    AllVisualSceneDefLibs = LibsVisualSceneDef{}

    <span class="comment">//	The &#34;default&#34; *LibVisualSceneDefs* library for *VisualSceneDef*s.</span>
    VisualSceneDefs = AllVisualSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var Functions = map[string]reflect.Value{
    &#34;NewGeometryMesh&#34;:                      reflect.ValueOf(NewGeometryMesh),
    &#34;NewGeometrySpline&#34;:                    reflect.ValueOf(NewGeometrySpline),
    &#34;Scopedf&#34;:                              reflect.ValueOf(Scopedf),
    &#34;SyncChanges&#34;:                          reflect.ValueOf(SyncChanges),
    &#34;NewPxRigidConstraintSpring&#34;:           reflect.ValueOf(NewPxRigidConstraintSpring),
    &#34;NewAsset&#34;:                             reflect.ValueOf(NewAsset),
    &#34;NewKxArticulatedSystemEffector&#34;:       reflect.ValueOf(NewKxArticulatedSystemEffector),
    &#34;NewKxArticulatedSystemMotionAxis&#34;:     reflect.ValueOf(NewKxArticulatedSystemMotionAxis),
    &#34;NewKxArticulatedSystemKinematicsAxis&#34;: reflect.ValueOf(NewKxArticulatedSystemKinematicsAxis),
    &#34;NewLightAttenuation&#34;:                  reflect.ValueOf(NewLightAttenuation),
    &#34;NewLightPoint&#34;:                        reflect.ValueOf(NewLightPoint),
    &#34;NewLightSpot&#34;:                         reflect.ValueOf(NewLightSpot),
    &#34;NewGeometryBrepNurbs&#34;:                 reflect.ValueOf(NewGeometryBrepNurbs),
    &#34;NewGeometryBrep&#34;:                      reflect.ValueOf(NewGeometryBrep),
    &#34;NewGeometryBrepNurbsSurface&#34;:          reflect.ValueOf(NewGeometryBrepNurbsSurface),
    &#34;NewFxImageInitFrom&#34;:                   reflect.ValueOf(NewFxImageInitFrom),
    &#34;NewControllerSkin&#34;:                    reflect.ValueOf(NewControllerSkin),
    &#34;NewControllerMorph&#34;:                   reflect.ValueOf(NewControllerMorph),
    &#34;NewVisualSceneRendering&#34;:              reflect.ValueOf(NewVisualSceneRendering),
    &#34;NewSourceAccessor&#34;:                    reflect.ValueOf(NewSourceAccessor),
    &#34;NewMeshRawFace&#34;:                       reflect.ValueOf(NewMeshRawFace),
    &#34;NewMeshData&#34;:                          reflect.ValueOf(NewMeshData),
    &#34;NewProfile&#34;:                           reflect.ValueOf(NewProfile),
    &#34;NewFxPass&#34;:                            reflect.ValueOf(NewFxPass),
    &#34;NewFxPassEvaluationTarget&#34;:            reflect.ValueOf(NewFxPassEvaluationTarget),
    &#34;NewFxProfileGlSl&#34;:                     reflect.ValueOf(NewFxProfileGlSl),
    &#34;NewFxSampler&#34;:                         reflect.ValueOf(NewFxSampler),
    &#34;NewFxSamplerStates&#34;:                   reflect.ValueOf(NewFxSamplerStates),
}</pre>
				
			
				<pre>var Types = map[string]reflect.Type{
    &#34;MeshData&#34;:                           reflect.TypeOf((*MeshData)(nil)).Elem(),
    &#34;MeshVertAtt2&#34;:                       reflect.TypeOf((*MeshVertAtt2)(nil)).Elem(),
    &#34;MeshFace3&#34;:                          reflect.TypeOf((*MeshFace3)(nil)).Elem(),
    &#34;MeshRaw&#34;:                            reflect.TypeOf((*MeshRaw)(nil)).Elem(),
    &#34;MeshRawFace&#34;:                        reflect.TypeOf((*MeshRawFace)(nil)).Elem(),
    &#34;MeshVert&#34;:                           reflect.TypeOf((*MeshVert)(nil)).Elem(),
    &#34;MeshVertAtt3&#34;:                       reflect.TypeOf((*MeshVertAtt3)(nil)).Elem(),
    &#34;MeshProvider&#34;:                       reflect.TypeOf((*MeshProvider)(nil)).Elem(),
    &#34;FxTechniqueCommonPhong&#34;:             reflect.TypeOf((*FxTechniqueCommonPhong)(nil)).Elem(),
    &#34;FxPassProgramBindUniform&#34;:           reflect.TypeOf((*FxPassProgramBindUniform)(nil)).Elem(),
    &#34;FxProfileGlSl&#34;:                      reflect.TypeOf((*FxProfileGlSl)(nil)).Elem(),
    &#34;FxTechniqueCommonConstant&#34;:          reflect.TypeOf((*FxTechniqueCommonConstant)(nil)).Elem(),
    &#34;FxEffectInst&#34;:                       reflect.TypeOf((*FxEffectInst)(nil)).Elem(),
    &#34;FxPass&#34;:                             reflect.TypeOf((*FxPass)(nil)).Elem(),
    &#34;FxTechnique&#34;:                        reflect.TypeOf((*FxTechnique)(nil)).Elem(),
    &#34;FxParamDefs&#34;:                        reflect.TypeOf((*FxParamDefs)(nil)).Elem(),
    &#34;FxProfileGlSlCodeInclude&#34;:           reflect.TypeOf((*FxProfileGlSlCodeInclude)(nil)).Elem(),
    &#34;LibFxEffectDefs&#34;:                    reflect.TypeOf((*LibFxEffectDefs)(nil)).Elem(),
    &#34;FxPassProgramShader&#34;:                reflect.TypeOf((*FxPassProgramShader)(nil)).Elem(),
    &#34;FxTechniqueCommon&#34;:                  reflect.TypeOf((*FxTechniqueCommon)(nil)).Elem(),
    &#34;FxTechniqueGlsl&#34;:                    reflect.TypeOf((*FxTechniqueGlsl)(nil)).Elem(),
    &#34;FxPassEvaluationClearStencil&#34;:       reflect.TypeOf((*FxPassEvaluationClearStencil)(nil)).Elem(),
    &#34;FxEffectInstTechniqueHint&#34;:          reflect.TypeOf((*FxEffectInstTechniqueHint)(nil)).Elem(),
    &#34;FxPassState&#34;:                        reflect.TypeOf((*FxPassState)(nil)).Elem(),
    &#34;FxTexture&#34;:                          reflect.TypeOf((*FxTexture)(nil)).Elem(),
    &#34;FxParamDef&#34;:                         reflect.TypeOf((*FxParamDef)(nil)).Elem(),
    &#34;FxTechniqueCommonBlinn&#34;:             reflect.TypeOf((*FxTechniqueCommonBlinn)(nil)).Elem(),
    &#34;FxProfile&#34;:                          reflect.TypeOf((*FxProfile)(nil)).Elem(),
    &#34;FxAnnotation&#34;:                       reflect.TypeOf((*FxAnnotation)(nil)).Elem(),
    &#34;FxPassEvaluationClearColor&#34;:         reflect.TypeOf((*FxPassEvaluationClearColor)(nil)).Elem(),
    &#34;FxTechniqueCommonLambert&#34;:           reflect.TypeOf((*FxTechniqueCommonLambert)(nil)).Elem(),
    &#34;FxPassProgramShaderSources&#34;:         reflect.TypeOf((*FxPassProgramShaderSources)(nil)).Elem(),
    &#34;FxPassEvaluationTarget&#34;:             reflect.TypeOf((*FxPassEvaluationTarget)(nil)).Elem(),
    &#34;FxEffectDef&#34;:                        reflect.TypeOf((*FxEffectDef)(nil)).Elem(),
    &#34;FxProfileCommon&#34;:                    reflect.TypeOf((*FxProfileCommon)(nil)).Elem(),
    &#34;FxPassEvaluation&#34;:                   reflect.TypeOf((*FxPassEvaluation)(nil)).Elem(),
    &#34;FxPassProgramBindAttribute&#34;:         reflect.TypeOf((*FxPassProgramBindAttribute)(nil)).Elem(),
    &#34;FxPassEvaluationClearDepth&#34;:         reflect.TypeOf((*FxPassEvaluationClearDepth)(nil)).Elem(),
    &#34;FxColorOrTexture&#34;:                   reflect.TypeOf((*FxColorOrTexture)(nil)).Elem(),
    &#34;LibsFxEffectDef&#34;:                    reflect.TypeOf((*LibsFxEffectDef)(nil)).Elem(),
    &#34;FxPassProgram&#34;:                      reflect.TypeOf((*FxPassProgram)(nil)).Elem(),
    &#34;FxSampler&#34;:                          reflect.TypeOf((*FxSampler)(nil)).Elem(),
    &#34;FxSamplerStates&#34;:                    reflect.TypeOf((*FxSamplerStates)(nil)).Elem(),
    &#34;FxSamplerFiltering&#34;:                 reflect.TypeOf((*FxSamplerFiltering)(nil)).Elem(),
    &#34;FxSamplerWrapping&#34;:                  reflect.TypeOf((*FxSamplerWrapping)(nil)).Elem(),
    &#34;FxSamplerImage&#34;:                     reflect.TypeOf((*FxSamplerImage)(nil)).Elem(),
    &#34;GeometrySpline&#34;:                     reflect.TypeOf((*GeometrySpline)(nil)).Elem(),
    &#34;GeometryControlVertices&#34;:            reflect.TypeOf((*GeometryControlVertices)(nil)).Elem(),
    &#34;GeometryPrimitives&#34;:                 reflect.TypeOf((*GeometryPrimitives)(nil)).Elem(),
    &#34;LibGeometryDefs&#34;:                    reflect.TypeOf((*LibGeometryDefs)(nil)).Elem(),
    &#34;LibsGeometryDef&#34;:                    reflect.TypeOf((*LibsGeometryDef)(nil)).Elem(),
    &#34;GeometryDef&#34;:                        reflect.TypeOf((*GeometryDef)(nil)).Elem(),
    &#34;GeometryPolygonHole&#34;:                reflect.TypeOf((*GeometryPolygonHole)(nil)).Elem(),
    &#34;GeometryInst&#34;:                       reflect.TypeOf((*GeometryInst)(nil)).Elem(),
    &#34;GeometryMesh&#34;:                       reflect.TypeOf((*GeometryMesh)(nil)).Elem(),
    &#34;GeometryVertices&#34;:                   reflect.TypeOf((*GeometryVertices)(nil)).Elem(),
    &#34;PxRigidConstraintAttachment&#34;:        reflect.TypeOf((*PxRigidConstraintAttachment)(nil)).Elem(),
    &#34;PxRigidConstraintDef&#34;:               reflect.TypeOf((*PxRigidConstraintDef)(nil)).Elem(),
    &#34;PxRigidConstraintInst&#34;:              reflect.TypeOf((*PxRigidConstraintInst)(nil)).Elem(),
    &#34;PxRigidConstraintLimit&#34;:             reflect.TypeOf((*PxRigidConstraintLimit)(nil)).Elem(),
    &#34;PxRigidConstraintSpring&#34;:            reflect.TypeOf((*PxRigidConstraintSpring)(nil)).Elem(),
    &#34;LibsKxSceneDef&#34;:                     reflect.TypeOf((*LibsKxSceneDef)(nil)).Elem(),
    &#34;KxModelBinding&#34;:                     reflect.TypeOf((*KxModelBinding)(nil)).Elem(),
    &#34;LibKxSceneDefs&#34;:                     reflect.TypeOf((*LibKxSceneDefs)(nil)).Elem(),
    &#34;KxJointAxisBinding&#34;:                 reflect.TypeOf((*KxJointAxisBinding)(nil)).Elem(),
    &#34;KxSceneInst&#34;:                        reflect.TypeOf((*KxSceneInst)(nil)).Elem(),
    &#34;KxSceneDef&#34;:                         reflect.TypeOf((*KxSceneDef)(nil)).Elem(),
    &#34;LibsPxForceFieldDef&#34;:                reflect.TypeOf((*LibsPxForceFieldDef)(nil)).Elem(),
    &#34;PxForceFieldInst&#34;:                   reflect.TypeOf((*PxForceFieldInst)(nil)).Elem(),
    &#34;PxForceFieldDef&#34;:                    reflect.TypeOf((*PxForceFieldDef)(nil)).Elem(),
    &#34;LibPxForceFieldDefs&#34;:                reflect.TypeOf((*LibPxForceFieldDefs)(nil)).Elem(),
    &#34;KxJointLimits&#34;:                      reflect.TypeOf((*KxJointLimits)(nil)).Elem(),
    &#34;KxJoint&#34;:                            reflect.TypeOf((*KxJoint)(nil)).Elem(),
    &#34;KxJointDef&#34;:                         reflect.TypeOf((*KxJointDef)(nil)).Elem(),
    &#34;KxJointInst&#34;:                        reflect.TypeOf((*KxJointInst)(nil)).Elem(),
    &#34;LibKxJointDefs&#34;:                     reflect.TypeOf((*LibKxJointDefs)(nil)).Elem(),
    &#34;LibsKxJointDef&#34;:                     reflect.TypeOf((*LibsKxJointDef)(nil)).Elem(),
    &#34;LibKxModelDefs&#34;:                     reflect.TypeOf((*LibKxModelDefs)(nil)).Elem(),
    &#34;KxModelDef&#34;:                         reflect.TypeOf((*KxModelDef)(nil)).Elem(),
    &#34;KxModelInst&#34;:                        reflect.TypeOf((*KxModelInst)(nil)).Elem(),
    &#34;KxLink&#34;:                             reflect.TypeOf((*KxLink)(nil)).Elem(),
    &#34;LibsKxModelDef&#34;:                     reflect.TypeOf((*LibsKxModelDef)(nil)).Elem(),
    &#34;KxAttachment&#34;:                       reflect.TypeOf((*KxAttachment)(nil)).Elem(),
    &#34;AnimationChannel&#34;:                   reflect.TypeOf((*AnimationChannel)(nil)).Elem(),
    &#34;LibsAnimationDef&#34;:                   reflect.TypeOf((*LibsAnimationDef)(nil)).Elem(),
    &#34;AnimationSampler&#34;:                   reflect.TypeOf((*AnimationSampler)(nil)).Elem(),
    &#34;LibAnimationDefs&#34;:                   reflect.TypeOf((*LibAnimationDefs)(nil)).Elem(),
    &#34;AnimationInst&#34;:                      reflect.TypeOf((*AnimationInst)(nil)).Elem(),
    &#34;AnimationDef&#34;:                       reflect.TypeOf((*AnimationDef)(nil)).Elem(),
    &#34;HasName&#34;:                            reflect.TypeOf((*HasName)(nil)).Elem(),
    &#34;Asset&#34;:                              reflect.TypeOf((*Asset)(nil)).Elem(),
    &#34;RefSid&#34;:                             reflect.TypeOf((*RefSid)(nil)).Elem(),
    &#34;AssetContributor&#34;:                   reflect.TypeOf((*AssetContributor)(nil)).Elem(),
    &#34;Technique&#34;:                          reflect.TypeOf((*Technique)(nil)).Elem(),
    &#34;HasId&#34;:                              reflect.TypeOf((*HasId)(nil)).Elem(),
    &#34;Transform&#34;:                          reflect.TypeOf((*Transform)(nil)).Elem(),
    &#34;HasAsset&#34;:                           reflect.TypeOf((*HasAsset)(nil)).Elem(),
    &#34;Scene&#34;:                              reflect.TypeOf((*Scene)(nil)).Elem(),
    &#34;HasTechniques&#34;:                      reflect.TypeOf((*HasTechniques)(nil)).Elem(),
    &#34;MaterialBinding&#34;:                    reflect.TypeOf((*MaterialBinding)(nil)).Elem(),
    &#34;HasParamDefs&#34;:                       reflect.TypeOf((*HasParamDefs)(nil)).Elem(),
    &#34;HasParamInsts&#34;:                      reflect.TypeOf((*HasParamInsts)(nil)).Elem(),
    &#34;HasExtras&#34;:                          reflect.TypeOf((*HasExtras)(nil)).Elem(),
    &#34;RefId&#34;:                              reflect.TypeOf((*RefId)(nil)).Elem(),
    &#34;HasSid&#34;:                             reflect.TypeOf((*HasSid)(nil)).Elem(),
    &#34;HasInputs&#34;:                          reflect.TypeOf((*HasInputs)(nil)).Elem(),
    &#34;Param&#34;:                              reflect.TypeOf((*Param)(nil)).Elem(),
    &#34;RefParam&#34;:                           reflect.TypeOf((*RefParam)(nil)).Elem(),
    &#34;HasSources&#34;:                         reflect.TypeOf((*HasSources)(nil)).Elem(),
    &#34;Layers&#34;:                             reflect.TypeOf((*Layers)(nil)).Elem(),
    &#34;ParamInst&#34;:                          reflect.TypeOf((*ParamInst)(nil)).Elem(),
    &#34;ParamDef&#34;:                           reflect.TypeOf((*ParamDef)(nil)).Elem(),
    &#34;Input&#34;:                              reflect.TypeOf((*Input)(nil)).Elem(),
    &#34;IndexedInputs&#34;:                      reflect.TypeOf((*IndexedInputs)(nil)).Elem(),
    &#34;Extra&#34;:                              reflect.TypeOf((*Extra)(nil)).Elem(),
    &#34;HasFxParamDefs&#34;:                     reflect.TypeOf((*HasFxParamDefs)(nil)).Elem(),
    &#34;InputShared&#34;:                        reflect.TypeOf((*InputShared)(nil)).Elem(),
    &#34;AssetGeographicLocation&#34;:            reflect.TypeOf((*AssetGeographicLocation)(nil)).Elem(),
    &#34;ParamDefs&#34;:                          reflect.TypeOf((*ParamDefs)(nil)).Elem(),
    &#34;FxMaterialInst&#34;:                     reflect.TypeOf((*FxMaterialInst)(nil)).Elem(),
    &#34;LibsFxMaterialDef&#34;:                  reflect.TypeOf((*LibsFxMaterialDef)(nil)).Elem(),
    &#34;FxVertexInputBinding&#34;:               reflect.TypeOf((*FxVertexInputBinding)(nil)).Elem(),
    &#34;FxBinding&#34;:                          reflect.TypeOf((*FxBinding)(nil)).Elem(),
    &#34;FxMaterialDef&#34;:                      reflect.TypeOf((*FxMaterialDef)(nil)).Elem(),
    &#34;LibFxMaterialDefs&#34;:                  reflect.TypeOf((*LibFxMaterialDefs)(nil)).Elem(),
    &#34;KxArticulatedSystemKinematicsAxis&#34;:  reflect.TypeOf((*KxArticulatedSystemKinematicsAxis)(nil)).Elem(),
    &#34;KxArticulatedSystemEffector&#34;:        reflect.TypeOf((*KxArticulatedSystemEffector)(nil)).Elem(),
    &#34;LibKxArticulatedSystemDefs&#34;:         reflect.TypeOf((*LibKxArticulatedSystemDefs)(nil)).Elem(),
    &#34;KxArticulatedSystemAxisLimits&#34;:      reflect.TypeOf((*KxArticulatedSystemAxisLimits)(nil)).Elem(),
    &#34;KxArticulatedSystemKinematicsFrame&#34;: reflect.TypeOf((*KxArticulatedSystemKinematicsFrame)(nil)).Elem(),
    &#34;KxArticulatedSystemKinematics&#34;:      reflect.TypeOf((*KxArticulatedSystemKinematics)(nil)).Elem(),
    &#34;KxArticulatedSystemDef&#34;:             reflect.TypeOf((*KxArticulatedSystemDef)(nil)).Elem(),
    &#34;KxArticulatedSystemAxisIndex&#34;:       reflect.TypeOf((*KxArticulatedSystemAxisIndex)(nil)).Elem(),
    &#34;KxArticulatedSystemMotion&#34;:          reflect.TypeOf((*KxArticulatedSystemMotion)(nil)).Elem(),
    &#34;LibsKxArticulatedSystemDef&#34;:         reflect.TypeOf((*LibsKxArticulatedSystemDef)(nil)).Elem(),
    &#34;KxArticulatedSystemInst&#34;:            reflect.TypeOf((*KxArticulatedSystemInst)(nil)).Elem(),
    &#34;KxBinding&#34;:                          reflect.TypeOf((*KxBinding)(nil)).Elem(),
    &#34;KxArticulatedSystemMotionAxis&#34;:      reflect.TypeOf((*KxArticulatedSystemMotionAxis)(nil)).Elem(),
    &#34;LibsFormulaDef&#34;:                     reflect.TypeOf((*LibsFormulaDef)(nil)).Elem(),
    &#34;Formula&#34;:                            reflect.TypeOf((*Formula)(nil)).Elem(),
    &#34;LibFormulaDefs&#34;:                     reflect.TypeOf((*LibFormulaDefs)(nil)).Elem(),
    &#34;FormulaInst&#34;:                        reflect.TypeOf((*FormulaInst)(nil)).Elem(),
    &#34;FormulaDef&#34;:                         reflect.TypeOf((*FormulaDef)(nil)).Elem(),
    &#34;LightPoint&#34;:                         reflect.TypeOf((*LightPoint)(nil)).Elem(),
    &#34;LightDirectional&#34;:                   reflect.TypeOf((*LightDirectional)(nil)).Elem(),
    &#34;LibsLightDef&#34;:                       reflect.TypeOf((*LibsLightDef)(nil)).Elem(),
    &#34;LightDef&#34;:                           reflect.TypeOf((*LightDef)(nil)).Elem(),
    &#34;LightInst&#34;:                          reflect.TypeOf((*LightInst)(nil)).Elem(),
    &#34;LightSpot&#34;:                          reflect.TypeOf((*LightSpot)(nil)).Elem(),
    &#34;LibLightDefs&#34;:                       reflect.TypeOf((*LibLightDefs)(nil)).Elem(),
    &#34;LightBase&#34;:                          reflect.TypeOf((*LightBase)(nil)).Elem(),
    &#34;LightAttenuation&#34;:                   reflect.TypeOf((*LightAttenuation)(nil)).Elem(),
    &#34;LightAmbient&#34;:                       reflect.TypeOf((*LightAmbient)(nil)).Elem(),
    &#34;CameraOptics&#34;:                       reflect.TypeOf((*CameraOptics)(nil)).Elem(),
    &#34;LibsCameraDef&#34;:                      reflect.TypeOf((*LibsCameraDef)(nil)).Elem(),
    &#34;CameraImager&#34;:                       reflect.TypeOf((*CameraImager)(nil)).Elem(),
    &#34;CameraDef&#34;:                          reflect.TypeOf((*CameraDef)(nil)).Elem(),
    &#34;CameraOrthographic&#34;:                 reflect.TypeOf((*CameraOrthographic)(nil)).Elem(),
    &#34;CameraInst&#34;:                         reflect.TypeOf((*CameraInst)(nil)).Elem(),
    &#34;CameraPerspective&#34;:                  reflect.TypeOf((*CameraPerspective)(nil)).Elem(),
    &#34;LibCameraDefs&#34;:                      reflect.TypeOf((*LibCameraDefs)(nil)).Elem(),
    &#34;PxModelDef&#34;:                         reflect.TypeOf((*PxModelDef)(nil)).Elem(),
    &#34;LibsPxModelDef&#34;:                     reflect.TypeOf((*LibsPxModelDef)(nil)).Elem(),
    &#34;LibPxModelDefs&#34;:                     reflect.TypeOf((*LibPxModelDefs)(nil)).Elem(),
    &#34;PxModelInst&#34;:                        reflect.TypeOf((*PxModelInst)(nil)).Elem(),
    &#34;Document&#34;:                           reflect.TypeOf((*Document)(nil)).Elem(),
    &#34;GeometryBrepPcurves&#34;:                reflect.TypeOf((*GeometryBrepPcurves)(nil)).Elem(),
    &#34;GeometryBrepSurfaceCurves&#34;:          reflect.TypeOf((*GeometryBrepSurfaceCurves)(nil)).Elem(),
    &#34;GeometryBrepTorus&#34;:                  reflect.TypeOf((*GeometryBrepTorus)(nil)).Elem(),
    &#34;GeometryBrep&#34;:                       reflect.TypeOf((*GeometryBrep)(nil)).Elem(),
    &#34;GeometryBrepHyperbola&#34;:              reflect.TypeOf((*GeometryBrepHyperbola)(nil)).Elem(),
    &#34;GeometryBrepCurve&#34;:                  reflect.TypeOf((*GeometryBrepCurve)(nil)).Elem(),
    &#34;GeometryBrepBox&#34;:                    reflect.TypeOf((*GeometryBrepBox)(nil)).Elem(),
    &#34;GeometryBrepOrientation&#34;:            reflect.TypeOf((*GeometryBrepOrientation)(nil)).Elem(),
    &#34;GeometryBrepLine&#34;:                   reflect.TypeOf((*GeometryBrepLine)(nil)).Elem(),
    &#34;GeometryBrepPlane&#34;:                  reflect.TypeOf((*GeometryBrepPlane)(nil)).Elem(),
    &#34;GeometryBrepEllipse&#34;:                reflect.TypeOf((*GeometryBrepEllipse)(nil)).Elem(),
    &#34;GeometryBrepNurbs&#34;:                  reflect.TypeOf((*GeometryBrepNurbs)(nil)).Elem(),
    &#34;GeometryBrepSurface&#34;:                reflect.TypeOf((*GeometryBrepSurface)(nil)).Elem(),
    &#34;GeometryBrepCapsule&#34;:                reflect.TypeOf((*GeometryBrepCapsule)(nil)).Elem(),
    &#34;GeometryBrepWires&#34;:                  reflect.TypeOf((*GeometryBrepWires)(nil)).Elem(),
    &#34;GeometryBrepNurbsSurface&#34;:           reflect.TypeOf((*GeometryBrepNurbsSurface)(nil)).Elem(),
    &#34;GeometryBrepSolids&#34;:                 reflect.TypeOf((*GeometryBrepSolids)(nil)).Elem(),
    &#34;GeometryBrepParabola&#34;:               reflect.TypeOf((*GeometryBrepParabola)(nil)).Elem(),
    &#34;GeometryBrepSphere&#34;:                 reflect.TypeOf((*GeometryBrepSphere)(nil)).Elem(),
    &#34;GeometryBrepFaces&#34;:                  reflect.TypeOf((*GeometryBrepFaces)(nil)).Elem(),
    &#34;GeometryBrepCircle&#34;:                 reflect.TypeOf((*GeometryBrepCircle)(nil)).Elem(),
    &#34;GeometryBrepCone&#34;:                   reflect.TypeOf((*GeometryBrepCone)(nil)).Elem(),
    &#34;GeometryBrepSurfaces&#34;:               reflect.TypeOf((*GeometryBrepSurfaces)(nil)).Elem(),
    &#34;GeometryBrepCylinder&#34;:               reflect.TypeOf((*GeometryBrepCylinder)(nil)).Elem(),
    &#34;GeometryBrepShells&#34;:                 reflect.TypeOf((*GeometryBrepShells)(nil)).Elem(),
    &#34;GeometryBrepEdges&#34;:                  reflect.TypeOf((*GeometryBrepEdges)(nil)).Elem(),
    &#34;GeometryBrepSweptSurface&#34;:           reflect.TypeOf((*GeometryBrepSweptSurface)(nil)).Elem(),
    &#34;GeometryBrepCurves&#34;:                 reflect.TypeOf((*GeometryBrepCurves)(nil)).Elem(),
    &#34;PxSceneDef&#34;:                         reflect.TypeOf((*PxSceneDef)(nil)).Elem(),
    &#34;PxSceneInst&#34;:                        reflect.TypeOf((*PxSceneInst)(nil)).Elem(),
    &#34;LibsPxSceneDef&#34;:                     reflect.TypeOf((*LibsPxSceneDef)(nil)).Elem(),
    &#34;LibPxSceneDefs&#34;:                     reflect.TypeOf((*LibPxSceneDefs)(nil)).Elem(),
    &#34;FxCreateCube&#34;:                       reflect.TypeOf((*FxCreateCube)(nil)).Elem(),
    &#34;FxCreateFormatHint&#34;:                 reflect.TypeOf((*FxCreateFormatHint)(nil)).Elem(),
    &#34;LibFxImageDefs&#34;:                     reflect.TypeOf((*LibFxImageDefs)(nil)).Elem(),
    &#34;FxInitFrom&#34;:                         reflect.TypeOf((*FxInitFrom)(nil)).Elem(),
    &#34;FxCreate&#34;:                           reflect.TypeOf((*FxCreate)(nil)).Elem(),
    &#34;FxCreate2DSizeExact&#34;:                reflect.TypeOf((*FxCreate2DSizeExact)(nil)).Elem(),
    &#34;FxImageInitFrom&#34;:                    reflect.TypeOf((*FxImageInitFrom)(nil)).Elem(),
    &#34;FxCreateInitFrom&#34;:                   reflect.TypeOf((*FxCreateInitFrom)(nil)).Elem(),
    &#34;LibsFxImageDef&#34;:                     reflect.TypeOf((*LibsFxImageDef)(nil)).Elem(),
    &#34;FxCreate2DSizeRatio&#34;:                reflect.TypeOf((*FxCreate2DSizeRatio)(nil)).Elem(),
    &#34;FxCreate2D&#34;:                         reflect.TypeOf((*FxCreate2D)(nil)).Elem(),
    &#34;FxImageInst&#34;:                        reflect.TypeOf((*FxImageInst)(nil)).Elem(),
    &#34;FxCreateFormat&#34;:                     reflect.TypeOf((*FxCreateFormat)(nil)).Elem(),
    &#34;FxCreateMips&#34;:                       reflect.TypeOf((*FxCreateMips)(nil)).Elem(),
    &#34;FxImageDef&#34;:                         reflect.TypeOf((*FxImageDef)(nil)).Elem(),
    &#34;FxCreate3D&#34;:                         reflect.TypeOf((*FxCreate3D)(nil)).Elem(),
    &#34;FxCreate3DInitFrom&#34;:                 reflect.TypeOf((*FxCreate3DInitFrom)(nil)).Elem(),
    &#34;FxCreateCubeInitFrom&#34;:               reflect.TypeOf((*FxCreateCubeInitFrom)(nil)).Elem(),
    &#34;PxMaterialInst&#34;:                     reflect.TypeOf((*PxMaterialInst)(nil)).Elem(),
    &#34;LibPxMaterialDefs&#34;:                  reflect.TypeOf((*LibPxMaterialDefs)(nil)).Elem(),
    &#34;LibsPxMaterialDef&#34;:                  reflect.TypeOf((*LibsPxMaterialDef)(nil)).Elem(),
    &#34;PxMaterialDef&#34;:                      reflect.TypeOf((*PxMaterialDef)(nil)).Elem(),
    &#34;ControllerInputs&#34;:                   reflect.TypeOf((*ControllerInputs)(nil)).Elem(),
    &#34;ControllerDef&#34;:                      reflect.TypeOf((*ControllerDef)(nil)).Elem(),
    &#34;ControllerMorph&#34;:                    reflect.TypeOf((*ControllerMorph)(nil)).Elem(),
    &#34;ControllerInst&#34;:                     reflect.TypeOf((*ControllerInst)(nil)).Elem(),
    &#34;LibsControllerDef&#34;:                  reflect.TypeOf((*LibsControllerDef)(nil)).Elem(),
    &#34;ControllerSkin&#34;:                     reflect.TypeOf((*ControllerSkin)(nil)).Elem(),
    &#34;LibControllerDefs&#34;:                  reflect.TypeOf((*LibControllerDefs)(nil)).Elem(),
    &#34;PxShape&#34;:                            reflect.TypeOf((*PxShape)(nil)).Elem(),
    &#34;PxRigidBodyInst&#34;:                    reflect.TypeOf((*PxRigidBodyInst)(nil)).Elem(),
    &#34;PxMaterial&#34;:                         reflect.TypeOf((*PxMaterial)(nil)).Elem(),
    &#34;PxRigidBodyCommon&#34;:                  reflect.TypeOf((*PxRigidBodyCommon)(nil)).Elem(),
    &#34;PxCylinder&#34;:                         reflect.TypeOf((*PxCylinder)(nil)).Elem(),
    &#34;PxRigidBodyDef&#34;:                     reflect.TypeOf((*PxRigidBodyDef)(nil)).Elem(),
    &#34;VisualSceneInst&#34;:                    reflect.TypeOf((*VisualSceneInst)(nil)).Elem(),
    &#34;LibVisualSceneDefs&#34;:                 reflect.TypeOf((*LibVisualSceneDefs)(nil)).Elem(),
    &#34;VisualSceneRenderingMaterialInst&#34;:   reflect.TypeOf((*VisualSceneRenderingMaterialInst)(nil)).Elem(),
    &#34;VisualSceneDef&#34;:                     reflect.TypeOf((*VisualSceneDef)(nil)).Elem(),
    &#34;VisualSceneRendering&#34;:               reflect.TypeOf((*VisualSceneRendering)(nil)).Elem(),
    &#34;VisualSceneEvaluation&#34;:              reflect.TypeOf((*VisualSceneEvaluation)(nil)).Elem(),
    &#34;LibsVisualSceneDef&#34;:                 reflect.TypeOf((*LibsVisualSceneDef)(nil)).Elem(),
    &#34;AnimationClipDef&#34;:                   reflect.TypeOf((*AnimationClipDef)(nil)).Elem(),
    &#34;LibAnimationClipDefs&#34;:               reflect.TypeOf((*LibAnimationClipDefs)(nil)).Elem(),
    &#34;LibsAnimationClipDef&#34;:               reflect.TypeOf((*LibsAnimationClipDef)(nil)).Elem(),
    &#34;BaseInst&#34;:                           reflect.TypeOf((*BaseInst)(nil)).Elem(),
    &#34;BaseDef&#34;:                            reflect.TypeOf((*BaseDef)(nil)).Elem(),
    &#34;Base&#34;:                               reflect.TypeOf((*Base)(nil)).Elem(),
    &#34;BaseLib&#34;:                            reflect.TypeOf((*BaseLib)(nil)).Elem(),
    &#34;ChildNode&#34;:                          reflect.TypeOf((*ChildNode)(nil)).Elem(),
    &#34;LibsNodeDef&#34;:                        reflect.TypeOf((*LibsNodeDef)(nil)).Elem(),
    &#34;LibNodeDefs&#34;:                        reflect.TypeOf((*LibNodeDefs)(nil)).Elem(),
    &#34;NodeDef&#34;:                            reflect.TypeOf((*NodeDef)(nil)).Elem(),
    &#34;NodeInst&#34;:                           reflect.TypeOf((*NodeInst)(nil)).Elem(),
    &#34;Source&#34;:                             reflect.TypeOf((*Source)(nil)).Elem(),
    &#34;SourceAccessor&#34;:                     reflect.TypeOf((*SourceAccessor)(nil)).Elem(),
    &#34;Sources&#34;:                            reflect.TypeOf((*Sources)(nil)).Elem(),
    &#34;ParamInt&#34;:                           reflect.TypeOf((*ParamInt)(nil)).Elem(),
    &#34;Int4&#34;:                               reflect.TypeOf((*Int4)(nil)).Elem(),
    &#34;Bool2&#34;:                              reflect.TypeOf((*Bool2)(nil)).Elem(),
    &#34;ParamUint&#34;:                          reflect.TypeOf((*ParamUint)(nil)).Elem(),
    &#34;Float4x3&#34;:                           reflect.TypeOf((*Float4x3)(nil)).Elem(),
    &#34;Int4x4&#34;:                             reflect.TypeOf((*Int4x4)(nil)).Elem(),
    &#34;Float7&#34;:                             reflect.TypeOf((*Float7)(nil)).Elem(),
    &#34;Float3x2&#34;:                           reflect.TypeOf((*Float3x2)(nil)).Elem(),
    &#34;ParamFloat&#34;:                         reflect.TypeOf((*ParamFloat)(nil)).Elem(),
    &#34;ParamScopedFloat&#34;:                   reflect.TypeOf((*ParamScopedFloat)(nil)).Elem(),
    &#34;Bool3&#34;:                              reflect.TypeOf((*Bool3)(nil)).Elem(),
    &#34;Int2x2&#34;:                             reflect.TypeOf((*Int2x2)(nil)).Elem(),
    &#34;Float4x4&#34;:                           reflect.TypeOf((*Float4x4)(nil)).Elem(),
    &#34;Float2x3&#34;:                           reflect.TypeOf((*Float2x3)(nil)).Elem(),
    &#34;Float2x2&#34;:                           reflect.TypeOf((*Float2x2)(nil)).Elem(),
    &#34;Float3x3&#34;:                           reflect.TypeOf((*Float3x3)(nil)).Elem(),
    &#34;ScopedFloat&#34;:                        reflect.TypeOf((*ScopedFloat)(nil)).Elem(),
    &#34;Float4&#34;:                             reflect.TypeOf((*Float4)(nil)).Elem(),
    &#34;Float4x2&#34;:                           reflect.TypeOf((*Float4x2)(nil)).Elem(),
    &#34;Float2x4&#34;:                           reflect.TypeOf((*Float2x4)(nil)).Elem(),
    &#34;Float3x4&#34;:                           reflect.TypeOf((*Float3x4)(nil)).Elem(),
    &#34;Float3&#34;:                             reflect.TypeOf((*Float3)(nil)).Elem(),
    &#34;Bool4&#34;:                              reflect.TypeOf((*Bool4)(nil)).Elem(),
    &#34;ParamSidRef&#34;:                        reflect.TypeOf((*ParamSidRef)(nil)).Elem(),
    &#34;ParamBool&#34;:                          reflect.TypeOf((*ParamBool)(nil)).Elem(),
    &#34;Int3&#34;:                               reflect.TypeOf((*Int3)(nil)).Elem(),
    &#34;ScopedString&#34;:                       reflect.TypeOf((*ScopedString)(nil)).Elem(),
    &#34;ScopedBool&#34;:                         reflect.TypeOf((*ScopedBool)(nil)).Elem(),
    &#34;ScopedFloat3&#34;:                       reflect.TypeOf((*ScopedFloat3)(nil)).Elem(),
    &#34;ParamFloat2&#34;:                        reflect.TypeOf((*ParamFloat2)(nil)).Elem(),
    &#34;ScopedVec3&#34;:                         reflect.TypeOf((*ScopedVec3)(nil)).Elem(),
    &#34;Int3x3&#34;:                             reflect.TypeOf((*Int3x3)(nil)).Elem(),
    &#34;Float2&#34;:                             reflect.TypeOf((*Float2)(nil)).Elem(),
    &#34;Int2&#34;:                               reflect.TypeOf((*Int2)(nil)).Elem(),
}</pre>
				
			
		
		
			
			
			<h2 id="SyncChanges">func <a href="/target/assets.go?s=1411:1429#L34">SyncChanges</a></h2>
			<pre>func SyncChanges()</pre>
			<p>
Signals to *core* (or your custom package) that changes have been made that need to be picked up. Call this after you have made any number of changes to your Defs, Insts or Libs.
</p>

			
		
		
			
			
			<h2 id="AnimationChannel">type <a href="/target/animation.gt.go?s=746:935#L14">AnimationChannel</a></h2>
			<pre>type AnimationChannel struct {
    <span class="comment">//	Refers to the Id of the source animation sampler.</span>
    Source RefId

    <span class="comment">//	Refers to the Sid of the element bound to the output of the sampler.</span>
    Target RefSid
}</pre>
			<p>
Declares an output channel of an animation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="AnimationClipDef">type <a href="/target/animationclip.gt.go?s=124:492#L1">AnimationClipDef</a></h2>
			<pre>type AnimationClipDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	The time in seconds of the beginning of the clip.</span>
    Start float64

    <span class="comment">//	The time in seconds of the end of the clip.</span>
    End float64

    <span class="comment">//	The animation instances contributing to this animation clip.</span>
    Animations []*AnimationInst

    <span class="comment">//	Any formulas used in this animation clip.</span>
    Formulas []*FormulaInst
}</pre>
			<p>
Defines a section of a set of animation curves and/or formulas to be used together as an animation clip.
</p>


			

			

			

			

			
				
				<h3 id="AnimationClipDef.Init">func (*AnimationClipDef) <a href="/target/animationclip.gt.go?s=512:546#L12">Init</a></h3>
				<pre>func (me *AnimationClipDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="AnimationDef">type <a href="/target/animation.gt.go?s=1590:2004#L41">AnimationDef</a></h2>
			<pre>type AnimationDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef

    <span class="comment">//	Describes a stream of values from an array data source.</span>
    HasSources

    <span class="comment">//	Allows the formation of a hierarchy of related animations.</span>
    AnimationDefs []*AnimationDef

    <span class="comment">//	Describes output channels for the animation.</span>
    Channels []*AnimationChannel

    <span class="comment">//	Describes the interpolation sampling functions for the animation.</span>
    Samplers []*AnimationSampler
}</pre>
			<p>
Categorizes the declaration of animation information.
</p>


			

			

			

			

			
				
				<h3 id="AnimationDef.Init">func (*AnimationDef) <a href="/target/animation.gt.go?s=2024:2054#L59">Init</a></h3>
				<pre>func (me *AnimationDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="AnimationInst">type <a href="/target/animation.gt.go?s=2123:2192#L64">AnimationInst</a></h2>
			<pre>type AnimationInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates an Animation resource.
</p>


			

			

			

			

			
				
				<h3 id="AnimationInst.Init">func (*AnimationInst) <a href="/target/animation.gt.go?s=2212:2243#L70">Init</a></h3>
				<pre>func (me *AnimationInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="AnimationSampler">type <a href="/target/animation.gt.go?s=1002:1531#L23">AnimationSampler</a></h2>
			<pre>type AnimationSampler struct {
    <span class="comment">//	Unique identifier</span>
    HasId

    <span class="comment">//	These Inputs describe sampling points, referring to Sources.</span>
    <span class="comment">//	At least one of the Inputs must have its Semantic set to INTERPOLATION.</span>
    HasInputs

    <span class="comment">//	Indicates what the sampled value should be before the first key.</span>
    <span class="comment">//	Valid values are the ANIM_SAMPLER_BEHAVIOR_* enumerated constants.</span>
    PreBehavior int

    <span class="comment">//	Indicates what the sampled value should be after the last key.</span>
    <span class="comment">//	Valid values are the ANIM_SAMPLER_BEHAVIOR_* enumerated constants.</span>
    PostBehavior int
}</pre>
			<p>
Declares an interpolation sampling function for an animation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Asset">type <a href="/target/common.go?s=2744:4897#L79">Asset</a></h2>
			<pre>type Asset struct {
    <span class="comment">//	Custom-technique/foreign-profile meta-data.</span>
    HasExtras
    <span class="comment">//	Contains the date and time that the parent element was created.</span>
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field, and is not otherwise used.</span>
    Created string
    <span class="comment">//	Contains the date and time that the parent element was last modified.</span>
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field, and is not otherwise used.</span>
    Modified string
    <span class="comment">//	Contains a list of words used as search criteria.</span>
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field, and is not otherwise used.</span>
    Keywords string
    <span class="comment">//	Contains revision information.</span>
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field, and is not otherwise used.</span>
    Revision string
    <span class="comment">//	Contains a description of the topical subject.</span>
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field, and is not otherwise used.</span>
    Subject string
    <span class="comment">//	Contains title information.</span>
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field, and is not otherwise used.</span>
    Title string
    <span class="comment">//	Contains descriptive information about the coordinate system of the geometric data. All</span>
    <span class="comment">//	coordinates are right-handed by definition. Valid values are &#34;X&#34;, &#34;Y&#34; (the default), or &#34;Z&#34;.</span>
    UpAxis string
    <span class="comment">//	The unit of distance that applies to all spatial measurements within the scope of this resource.</span>
    Unit struct {
        <span class="comment">//	How many real-world meters in one distance unit as a floating-point number. 1.0 for meter, 0.01 for centimeter, 1000 for kilometer etc.</span>
        Meter float64
        <span class="comment">//	Name of the distance unit, such as &#34;centimeter&#34;, &#34;kilometer&#34;, &#34;meter&#34;, &#34;inch&#34;. Default is &#34;meter&#34;.</span>
        Name string
    }
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field, and is not otherwise used.</span>
    Contributors []*AssetContributor
    <span class="comment">//	Provides information about the location of the visual scene in physical space.</span>
    <span class="comment">//	This is only set-and-retained for imported Collada assets that provide this field, and is not otherwise used.</span>
    Coverage *AssetGeographicLocation
}</pre>
			<p>
Resource-specific asset-management information and meta-data.
</p>


			

			

			

			
				
				<h3 id="NewAsset">func <a href="/target/common.go?s=4914:4941#L118">NewAsset</a></h3>
				<pre>func NewAsset() (me *Asset)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="AssetContributor">type <a href="/target/common.go?s=5207:5393#L126">AssetContributor</a></h2>
			<pre>type AssetContributor struct {
    Author        string
    AuthorEmail   string
    AuthorWebsite string
    AuthoringTool string
    Comments      string
    Copyright     string
    SourceData    string
}</pre>
			<p>
Defines authoring information for asset management.
ALL fields are only set-and-retained for imported Collada assets that provide those fields, and are not otherwise written, read or used.
</p>


			

			

			

			

			
		
			
			
			<h2 id="AssetGeographicLocation">type <a href="/target/common.go?s=5617:5757#L138">AssetGeographicLocation</a></h2>
			<pre>type AssetGeographicLocation struct {
    Longitude        float64
    Latitude         float64
    Altitude         float64
    AltitudeAbsolute bool
}</pre>
			<p>
Provides information about the location of the visual scene in physical space.
ALL fields are only set-and-retained for imported Collada assets that provide those fields, and are not otherwise written, read or used.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Base">type <a href="/target/base.go?s=74:453#L1">Base</a></h2>
			<pre>type Base struct {
    <span class="comment">//	This callback, set by *core* (or your custom package), gets called by the *SyncChanges()* method.</span>
    <span class="comment">//	This is the ultimate point in the sync chain where *core* (or your custom package) picks up the changed</span>
    <span class="comment">//	contents of this *Def*, *Inst* or *Lib*. If this is a *Lib* this gets called after all *Defs* in it</span>
    <span class="comment">//	have synced.</span>
    OnSync func()
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Provides a common base for *Def*s, *Inst*s and *Lib*s.
</p>


			

			

			

			

			
				
				<h3 id="Base.SetDirty">func (*Base) <a href="/target/base.go?s=678:704#L6">SetDirty</a></h3>
				<pre>func (me *Base) SetDirty()</pre>
				<p>
You NEED to call this method if you modified this *Def* or *Inst* by setting its fields directly
(instead of using the provided *SetFoo()* methods) for your changes to be picked up by *core* (or your custom package).
</p>

				
				
			
				
				<h3 id="Base.SetFieldB">func (*Base) <a href="/target/base.go?s=799:847#L11">SetFieldB</a></h3>
				<pre>func (me *Base) SetFieldB(field *bool, val bool)</pre>
				<p>
If field does not equal val, sets field to val and calls SetDirty().
</p>

				
				
			
				
				<h3 id="Base.SetFieldF">func (*Base) <a href="/target/base.go?s=979:1033#L19">SetFieldF</a></h3>
				<pre>func (me *Base) SetFieldF(field *float64, val float64)</pre>
				<p>
If field does not equal val, sets field to val and calls SetDirty().
</p>

				
				
			
				
				<h3 id="Base.SyncChanges">func (*Base) <a href="/target/base.go?s=1438:1467#L34">SyncChanges</a></h3>
				<pre>func (me *Base) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *Def*, *Inst* or *Lib* that need to be picked up.
Call this after you have made any number of changes to this this *Def*, *Inst* or *Lib*.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="BaseDef">type <a href="/target/base.go?s=1562:1761#L42">BaseDef</a></h2>
			<pre>type BaseDef struct {
    <span class="comment">//	Syncability</span>
    Base
    <span class="comment">//	Unique identifier</span>
    HasId
    <span class="comment">//	Pretty-print name/title</span>
    HasName
    <span class="comment">//	Asset meta-data</span>
    HasAsset
    <span class="comment">//	Custom-technique/foreign-profile meta-data</span>
    HasExtras
}</pre>
			<p>
Provides a common base for *Def*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseInst">type <a href="/target/base.go?s=1802:2053#L56">BaseInst</a></h2>
			<pre>type BaseInst struct {
    <span class="comment">//	Syncability</span>
    Base
    <span class="comment">//	Pretty-print name/title</span>
    HasName
    <span class="comment">//	Scoped identifier</span>
    HasSid
    <span class="comment">//	Custom-technique/foreign-profile meta-data</span>
    HasExtras
    <span class="comment">//	The unique ID of the definition that this instance refers to.</span>
    DefRef RefId
}</pre>
			<p>
Provides a common base for *Inst*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseLib">type <a href="/target/base.go?s=2093:2204#L70">BaseLib</a></h2>
			<pre>type BaseLib struct {
    <span class="comment">//	Syncability</span>
    Base
    <span class="comment">//	Unique identifier</span>
    HasId
    <span class="comment">//	Pretty-print name/title</span>
    HasName
}</pre>
			<p>
Provides a common base for *Lib*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Bool2">type <a href="/target/types.go?s=97:115#L1">Bool2</a></h2>
			<pre>type Bool2 [2]bool</pre>
			<p>
Contains two bool values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Bool3">type <a href="/target/types.go?s=148:166#L1">Bool3</a></h2>
			<pre>type Bool3 [3]bool</pre>
			<p>
Contains three bool values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Bool4">type <a href="/target/types.go?s=198:216#L4">Bool4</a></h2>
			<pre>type Bool4 [4]bool</pre>
			<p>
Contains four bool values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraDef">type <a href="/target/camera.gt.go?s=1431:1661#L39">CameraDef</a></h2>
			<pre>type CameraDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Describes the field of view and viewing frustum using canonical parameters.</span>
    Optics CameraOptics
    <span class="comment">//	Represents the image sensor of a camera.</span>
    Imager *CameraImager
}</pre>
			<p>
Declares a view of the visual scene hierarchy or scene graph.
</p>


			

			

			

			

			
				
				<h3 id="CameraDef.Init">func (*CameraDef) <a href="/target/camera.gt.go?s=1681:1708#L49">Init</a></h3>
				<pre>func (me *CameraDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="CameraImager">type <a href="/target/camera.gt.go?s=87:233#L1">CameraImager</a></h2>
			<pre>type CameraImager struct {
    <span class="comment">//	Custom-profile/foreign-technique meta-data</span>
    HasExtras
    <span class="comment">//	Custom-profile/foreign-technique support</span>
    HasTechniques
}</pre>
			<p>
Represents the image sensor of a camera (for example, film or CCD).
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraInst">type <a href="/target/camera.gt.go?s=1749:1815#L53">CameraInst</a></h2>
			<pre>type CameraInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates a camera resource.
</p>


			

			

			

			

			
				
				<h3 id="CameraInst.Init">func (*CameraInst) <a href="/target/camera.gt.go?s=1835:1863#L59">Init</a></h3>
				<pre>func (me *CameraInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="CameraOptics">type <a href="/target/camera.gt.go?s=322:941#L2">CameraOptics</a></h2>
			<pre>type CameraOptics struct {
    <span class="comment">//	Custom-profile/foreign-technique meta-data</span>
    HasExtras
    <span class="comment">//	Custom-profile/foreign-technique support</span>
    HasTechniques
    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	Aspect ratio of the field of view.</span>
        AspectRatio *ScopedFloat
        <span class="comment">//	Distance to the far clipping plane.</span>
        Zfar ScopedFloat
        <span class="comment">//	Distance to the near clipping plane.</span>
        Znear ScopedFloat
        <span class="comment">//	Orthographic projection type. To use Perspective instead, also set this to nil.</span>
        Orthographic *CameraOrthographic
        <span class="comment">//	Perspective projection type. To use Orthographic instead, also set this to nil.</span>
        Perspective *CameraPerspective
    }
}</pre>
			<p>
Represents the apparatus on a camera that projects the image onto the image sensor.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraOrthographic">type <a href="/target/camera.gt.go?s=1001:1155#L23">CameraOrthographic</a></h2>
			<pre>type CameraOrthographic struct {
    <span class="comment">//	Horizontal magnification of the view.</span>
    MagX *ScopedFloat
    <span class="comment">//	Vertical magnification of the view.</span>
    MagY *ScopedFloat
}</pre>
			<p>
Describes the field of view of an orthographic camera.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraPerspective">type <a href="/target/camera.gt.go?s=1213:1364#L31">CameraPerspective</a></h2>
			<pre>type CameraPerspective struct {
    <span class="comment">//	Horizontal field of view in degrees.</span>
    FovX *ScopedFloat
    <span class="comment">//	Vertical field of view in degrees.</span>
    FovY *ScopedFloat
}</pre>
			<p>
Describes the field of view of a perspective camera.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ChildNode">type <a href="/target/node.gt.go?s=68:249#L1">ChildNode</a></h2>
			<pre>type ChildNode struct {
    <span class="comment">//	If set, Inst must be nil. An inline node definition.</span>
    Def *NodeDef
    <span class="comment">//	If set, Def must be nil. Instantiates a previously defined node.</span>
    Inst *NodeInst
}</pre>
			<p>
Used to recursively define hierarchies of nodes.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ControllerDef">type <a href="/target/controller.gt.go?s=1855:2187#L47">ControllerDef</a></h2>
			<pre>type ControllerDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Declares this a mesh-morphing controller that deforms meshes and blends them.</span>
    Morph *ControllerMorph
    <span class="comment">//	Declares this a vertex-skinning controller that transforms vertices based on weighted influences to produce a smoothly changing mesh.</span>
    Skin *ControllerSkin
}</pre>
			<p>
Defines generic control information for dynamic content.
</p>


			

			

			

			

			
				
				<h3 id="ControllerDef.Init">func (*ControllerDef) <a href="/target/controller.gt.go?s=2207:2238#L57">Init</a></h3>
				<pre>func (me *ControllerDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="ControllerInputs">type <a href="/target/controller.gt.go?s=121:313#L1">ControllerInputs</a></h2>
			<pre>type ControllerInputs struct {
    <span class="comment">//	Custom-technique/foreign-profile meta-data.</span>
    HasExtras
    <span class="comment">//	Declares the input semantics of a data Source and connects a consumer to that Source.</span>
    HasInputs
}</pre>
			<p>
Used to declare skinning joints or morph targets.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ControllerInst">type <a href="/target/controller.gt.go?s=2283:2613#L61">ControllerInst</a></h2>
			<pre>type ControllerInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	Binds a specific material to this controller instantiation.</span>
    BindMaterial *MaterialBinding
    <span class="comment">//	Indicates where a skin controller is to start to search for the joint nodes it needs. This element is meaningless for morph controllers.</span>
    SkinSkeletons []string
}</pre>
			<p>
Instantiates a controller resource.
</p>


			

			

			

			

			
				
				<h3 id="ControllerInst.Init">func (*ControllerInst) <a href="/target/controller.gt.go?s=2633:2665#L71">Init</a></h3>
				<pre>func (me *ControllerInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="ControllerMorph">type <a href="/target/controller.gt.go?s=386:733#L6">ControllerMorph</a></h2>
			<pre>type ControllerMorph struct {
    <span class="comment">//	Data for morph weights and for morph targets.</span>
    HasSources
    <span class="comment">//	Which blending method to use: true for relative blending, false for normalized blending.</span>
    Relative bool
    <span class="comment">//	Refers to the Geometry that describes the base mesh.</span>
    Source string
    <span class="comment">//	Input meshes (morph targets) to be blended.</span>
    Targets ControllerInputs
}</pre>
			<p>
Describes the data required to blend between sets of static meshes.
</p>


			

			

			

			
				
				<h3 id="NewControllerMorph">func <a href="/target/controller.gt.go?s=750:797#L18">NewControllerMorph</a></h3>
				<pre>func NewControllerMorph() (me *ControllerMorph)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="ControllerSkin">type <a href="/target/controller.gt.go?s=951:1640#L25">ControllerSkin</a></h2>
			<pre>type ControllerSkin struct {
    <span class="comment">//	Provides most of the data required for skinning the given base mesh.</span>
    HasSources
    <span class="comment">//	Provides extra information about the position and orientation of the base mesh before binding.</span>
    BindShapeMatrix unum.Mat4
    <span class="comment">//	Describes a per-vertex combination of joints and weights used in this skin. An index of –1 into the array of joints refers to the bind shape. Weights should be normalized before use.</span>
    VertexWeights IndexedInputs
    <span class="comment">//	Aggregates the per-joint information needed for this skin.</span>
    Joints ControllerInputs
    <span class="comment">//	A URI reference to the base mesh (a static mesh or a morphed mesh). This also provides the bind-shape of the skinned mesh.</span>
    Source string
}</pre>
			<p>
Contains vertex and primitive information sufficient to describe blend-weight skinning.
</p>


			

			

			

			
				
				<h3 id="NewControllerSkin">func <a href="/target/controller.gt.go?s=1657:1702#L39">NewControllerSkin</a></h3>
				<pre>func NewControllerSkin() (me *ControllerSkin)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="Document">type <a href="/target/doc.go?s=4822:5662#L68">Document</a></h2>
			<pre>type Document struct {
    HasAsset
    HasExtras
    Scene *Scene
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Extra">type <a href="/target/common.go?s=5845:6142#L146">Extra</a></h2>
			<pre>type Extra struct {
    <span class="comment">//	Unique identifier</span>
    HasId
    <span class="comment">//	Pretty-print name/title</span>
    HasName
    <span class="comment">//	Resource-specific asset-management meta-data</span>
    HasAsset
    <span class="comment">//	Custom-technique/foreign-profile data.</span>
    HasTechniques
    <span class="comment">//	A hint as to the type of information that this particular Extra represents.</span>
    Type string
}</pre>
			<p>
Provides arbitrary additional information about or related to its parent resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2">type <a href="/target/types.go?s=250:272#L7">Float2</a></h2>
			<pre>type Float2 [2]float64</pre>
			<p>
Contains two float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2x2">type <a href="/target/types.go?s=307:331#L10">Float2x2</a></h2>
			<pre>type Float2x2 [4]float64</pre>
			<p>
Contains four float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2x3">type <a href="/target/types.go?s=365:389#L13">Float2x3</a></h2>
			<pre>type Float2x3 [6]float64</pre>
			<p>
Contains six float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float2x4">type <a href="/target/types.go?s=425:449#L16">Float2x4</a></h2>
			<pre>type Float2x4 [8]float64</pre>
			<p>
Contains eight float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float3">type <a href="/target/types.go?s=485:507#L19">Float3</a></h2>
			<pre>type Float3 [3]float64</pre>
			<p>
Contains three float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float3x2">type <a href="/target/types.go?s=541:565#L22">Float3x2</a></h2>
			<pre>type Float3x2 [6]float64</pre>
			<p>
Contains six float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float3x3">type <a href="/target/types.go?s=600:624#L25">Float3x3</a></h2>
			<pre>type Float3x3 [9]float64</pre>
			<p>
Contains nine float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float3x4">type <a href="/target/types.go?s=661:686#L28">Float3x4</a></h2>
			<pre>type Float3x4 [12]float64</pre>
			<p>
Contains twelve float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float4">type <a href="/target/types.go?s=721:743#L31">Float4</a></h2>
			<pre>type Float4 [4]float64</pre>
			<p>
Contains four float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float4x2">type <a href="/target/types.go?s=779:803#L34">Float4x2</a></h2>
			<pre>type Float4x2 [8]float64</pre>
			<p>
Contains eight float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float4x3">type <a href="/target/types.go?s=840:865#L37">Float4x3</a></h2>
			<pre>type Float4x3 [12]float64</pre>
			<p>
Contains twelve float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float4x4">type <a href="/target/types.go?s=903:928#L40">Float4x4</a></h2>
			<pre>type Float4x4 [16]float64</pre>
			<p>
Contains sixteen float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Float7">type <a href="/target/types.go?s=964:986#L43">Float7</a></h2>
			<pre>type Float7 [7]float64</pre>
			<p>
Contains seven float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Formula">type <a href="/target/formula.gt.go?s=133:251#L1">Formula</a></h2>
			<pre>type Formula struct {
    <span class="comment">//	If set, Inst must be nil.</span>
    Def *FormulaDef
    <span class="comment">//	If set, Def must be nil.</span>
    Inst *FormulaInst
}</pre>
			<p>
Represents either a formula definition or a formula instance.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FormulaDef">type <a href="/target/formula.gt.go?s=371:771#L6">FormulaDef</a></h2>
			<pre>type FormulaDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Formula parameter definitions</span>
    HasParamDefs
    <span class="comment">//	Custom-profile/foreign-technique support</span>
    HasTechniques
    <span class="comment">//	A parameter that specifies the result variable of the formula.</span>
    Target ParamFloat
    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	Any valid MathML (content) XML defining this formula.</span>
        MathML []*xmlx.Node
    }
}</pre>
			<p>
There are many ways to describe a formula. Like COLLADA, the *assets* package uses MathML as its common technique.
</p>


			

			

			

			

			
				
				<h3 id="FormulaDef.Init">func (*FormulaDef) <a href="/target/formula.gt.go?s=791:819#L25">Init</a></h3>
				<pre>func (me *FormulaDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FormulaInst">type <a href="/target/formula.gt.go?s=889:1077#L30">FormulaInst</a></h2>
			<pre>type FormulaInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	Specifies the source (for arguments) or the destination (for the result) of the instantiated formula.</span>
    HasParamInsts
}</pre>
			<p>
Instantiates a formula resource.
</p>


			

			

			

			

			
				
				<h3 id="FormulaInst.Init">func (*FormulaInst) <a href="/target/formula.gt.go?s=1097:1126#L38">Init</a></h3>
				<pre>func (me *FormulaInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxAnnotation">type <a href="/target/fxeffect.gt.go?s=1133:1208#L15">FxAnnotation</a></h2>
			<pre>type FxAnnotation struct {
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Value</span>
    Value interface{}
}</pre>
			<p>
Annotations communicate metadata from the Effect Runtime to the application only and are not otherwise interpreted within the *assets* package.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxBinding">type <a href="/target/fxmaterial.gt.go?s=119:287#L1">FxBinding</a></h2>
			<pre>type FxBinding struct {
    <span class="comment">//	Which effect parameter to bind.</span>
    Semantic string
    <span class="comment">//	A reference to the Sid of the value to bind to the specified semantic.</span>
    Target string
}</pre>
			<p>
Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxColorOrTexture">type <a href="/target/fxeffect.gt.go?s=1298:1816#L23">FxColorOrTexture</a></h2>
			<pre>type FxColorOrTexture struct {
    <span class="comment">//	Specifies from which channel to take transparency information. Can be any of the FX_COLOR_TEXTURE_OPAQUE_* enumerated constants.</span>
    Opaque int
    <span class="comment">//	If set, describes he literal color of this value.</span>
    Color *ugfx.Rgba32
    <span class="comment">//	If set, refers to a previously-defined parameter in the current scope that provides 4 float values definining the literal color of this value.</span>
    ParamRef string
    <span class="comment">//	If set, refers to a previously-defined FxSampler with type FX_SAMPLER_TYPE_2D.</span>
    Texture *FxTexture
}</pre>
			<p>
Describes color attributes of fixed-function shaders inside FxProfileCommon effects.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate">type <a href="/target/fximage.gt.go?s=2817:3072#L41">FxCreate</a></h2>
			<pre>type FxCreate struct {
    <span class="comment">//	Specifies the length of the 2D array, 3D array or cube-map array.</span>
    ArrayLength uint64
    <span class="comment">//	Specifies an image’s pixel or compression format. If not present, the format is assumed to be R8G8B8A8 linear.</span>
    Format *FxCreateFormat
}</pre>
			<p>
Fields shared by FxCreate2D, FxCreate3D and FxCreateCube
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2D">type <a href="/target/fximage.gt.go?s=3134:3741#L49">FxCreate2D</a></h2>
			<pre>type FxCreate2D struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate
    <span class="comment">//	Either Exact or Ratio, but not both, must be present.</span>
    Size struct {
        <span class="comment">//	Specifies that the surface should be sized to these exact dimensions.</span>
        Exact *FxCreate2DSizeExact
        <span class="comment">//	Specifies that the image size should be relative to the size of the viewport.</span>
        Ratio *FxCreate2DSizeRatio
    }
    <span class="comment">//	MIP information. Ignored if Unnormalized is true.</span>
    Mips *FxCreateMips
    <span class="comment">//	Unnormalized addressing of texels. (0-W, 0-H).</span>
    Unnormalized bool
    <span class="comment">//	Specifies which 2D image to initialize and which MIP level to initialize.</span>
    InitFrom []*FxCreateInitFrom
}</pre>
			<p>
Assists in the manual creation of a 2D FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2DSizeExact">type <a href="/target/fximage.gt.go?s=3816:3921#L68">FxCreate2DSizeExact</a></h2>
			<pre>type FxCreate2DSizeExact struct {
    <span class="comment">//	width in pixels</span>
    Width uint64
    <span class="comment">//	height in pixels</span>
    Height uint64
}</pre>
			<p>
Specifies that the surface should be sized to these exact dimensions.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate2DSizeRatio">type <a href="/target/fximage.gt.go?s=4136:4316#L77">FxCreate2DSizeRatio</a></h2>
			<pre>type FxCreate2DSizeRatio struct {
    <span class="comment">//	Relative width where 1.0 represents viewport width.</span>
    Width float64
    <span class="comment">//	Relative height where 1.0 represents viewport height.</span>
    Height float64
}</pre>
			<p>
Specifies that the image size should be relative to the size of the viewport.
For example, 1,1 is the same size as the viewport; 0.5,0.5 is 1/4 the size of the viewport and half as long in either direction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate3D">type <a href="/target/fximage.gt.go?s=4378:4856#L85">FxCreate3D</a></h2>
			<pre>type FxCreate3D struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate
    <span class="comment">//	Specifies that the surface should be sized to these exact dimensions.</span>
    Size struct {
        <span class="comment">//	Width in pixels for this 3D texture.</span>
        Width uint64
        <span class="comment">//	Height in pixels for this 3D texture.</span>
        Height uint64
        <span class="comment">//	Depth in pixels for this 3D texture.</span>
        Depth uint64
    }
    <span class="comment">//	MIP information.</span>
    Mips FxCreateMips
    <span class="comment">//	Specifies which 3D image to initialize and which MIP level to initialize.</span>
    InitFrom []*FxCreate3DInitFrom
}</pre>
			<p>
Assists in the manual creation of a 3D FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreate3DInitFrom">type <a href="/target/fximage.gt.go?s=4956:5145#L104">FxCreate3DInitFrom</a></h2>
			<pre>type FxCreate3DInitFrom struct {
    <span class="comment">//	Raw or RefUrl, ArrayIndex and MipIndex</span>
    FxCreateInitFrom
    <span class="comment">//	Specifies the slice (depth level) within the MIP that is to be initialized.</span>
    Depth uint64
}</pre>
			<p>
Initializes an entire 3D texture or portions of a 3D texture from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateCube">type <a href="/target/fximage.gt.go?s=5213:5672#L112">FxCreateCube</a></h2>
			<pre>type FxCreateCube struct {
    <span class="comment">//	ArrayLength and Format</span>
    FxCreate
    <span class="comment">//	Specifies that the cube surfaces should be sized to these exact dimensions.</span>
    Size struct {
        <span class="comment">//	Width and height are identical across all faces in a cube-map.</span>
        Width uint64
    }
    <span class="comment">//	MIP information.</span>
    Mips FxCreateMips
    <span class="comment">//	Specifies which cube image to initialize, which MIP level to initialize, and which cube face within the MIP that is to be initialized.</span>
    InitFrom []*FxCreateCubeInitFrom
}</pre>
			<p>
Assists in the manual creation of a cube-map FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateCubeInitFrom">type <a href="/target/fximage.gt.go?s=5768:6005#L127">FxCreateCubeInitFrom</a></h2>
			<pre>type FxCreateCubeInitFrom struct {
    <span class="comment">//	Raw or RefUrl, ArrayIndex and MipIndex</span>
    FxCreateInitFrom
    <span class="comment">//	Specifies the cube-map face within the MIP that is to be initialized. Must be one of the FX_CUBE_FACE_* enumerated constants.</span>
    Face int
}</pre>
			<p>
Initializes an entire cube-map or portions of a cube-map from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateFormat">type <a href="/target/fximage.gt.go?s=6085:6531#L135">FxCreateFormat</a></h2>
			<pre>type FxCreateFormat struct {
    <span class="comment">//	Contains a string representing the profile- and platform-specific texel format that the author would like this surface to use. If this element is not specified, or if it is specified but the application cannot process the specified format, then the application uses the Hint.</span>
    Exact string
    <span class="comment">//	If this is not set, then use a common format R8G8B8A8 with linear color gradient, not sRGB.</span>
    Hint *FxCreateFormatHint
}</pre>
			<p>
Describes the formatting or memory layout expected of an FxImageDef asset.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateFormatHint">type <a href="/target/fximage.gt.go?s=6627:7352#L143">FxCreateFormatHint</a></h2>
			<pre>type FxCreateFormatHint struct {
    <span class="comment">//	Describes the per-texel layout of the format. Can be any of the FX_CREATE_FORMAT_HINT_CHANNELS_* enumerated constants.</span>
    Channels int
    <span class="comment">//	Describes the range of texel channel values. Each channel represents a range of values. Some example ranges are signed or unsigned integers, or are within a clamped range such as 0.0f to 1.0f, or are a high dynamic range via floating point. Can be any of the FX_CREATE_FORMAT_HINT_RANGE_* enumerated constants.</span>
    Range int
    <span class="comment">//	Identifies the precision of the texel channel value. Can be any of the FX_CREATE_FORMAT_HINT_PRECISION_* enumerated constants.</span>
    Precision int
    <span class="comment">//	Optional custom / application-specific color-space information.</span>
    Space string
}</pre>
			<p>
Describes features and characteristics to select an appropriate format for image creation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateInitFrom">type <a href="/target/fximage.gt.go?s=7443:7669#L155">FxCreateInitFrom</a></h2>
			<pre>type FxCreateInitFrom struct {
    <span class="comment">//	Raw and RefUrl</span>
    FxInitFrom
    <span class="comment">//	Specifies which array element in the image to initialize (fill).</span>
    ArrayIndex uint64
    <span class="comment">//	Specifies which MIP level in the image to initialize.</span>
    MipIndex uint64
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxCreateMips">type <a href="/target/fximage.gt.go?s=7690:7981#L165">FxCreateMips</a></h2>
			<pre>type FxCreateMips struct {
    <span class="comment">//	Desired number of MIP levels. Special values: 1 is &#34;no MIP levels&#34;, 0 is &#34;all MIP levels&#34;.</span>
    Levels uint64
    <span class="comment">//	If false, initializes higher MIP levels if data does not exist in a file. If true, no MIP levels are ever automatically initialized.</span>
    NoAutoGen bool
}</pre>
			<p>
MIP information
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxEffectDef">type <a href="/target/fxeffect.gt.go?s=13538:13748#L341">FxEffectDef</a></h2>
			<pre>type FxEffectDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	NewParams</span>
    HasFxParamDefs
    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation
    <span class="comment">//	Rendering pipeline(s).</span>
    Profiles []*FxProfile
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry and/or screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="FxEffectDef.Init">func (*FxEffectDef) <a href="/target/fxeffect.gt.go?s=13768:13797#L353">Init</a></h3>
				<pre>func (me *FxEffectDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxEffectInst">type <a href="/target/fxeffect.gt.go?s=13869:14082#L358">FxEffectInst</a></h2>
			<pre>type FxEffectInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	Platform-specific hints of which techniques to use in this effect.</span>
    TechniqueHints []*FxEffectInstTechniqueHint
}</pre>
			<p>
Instantiates an effect resource.
</p>


			

			

			

			

			
				
				<h3 id="FxEffectInst.Init">func (*FxEffectInst) <a href="/target/fxeffect.gt.go?s=14102:14132#L368">Init</a></h3>
				<pre>func (me *FxEffectInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxEffectInstTechniqueHint">type <a href="/target/fxeffect.gt.go?s=14210:14634#L372">FxEffectInstTechniqueHint</a></h2>
			<pre>type FxEffectInstTechniqueHint struct {
    <span class="comment">//	Defines a string that specifies for which platform this hint is intended. Optional.</span>
    Platform string
    <span class="comment">//	A reference to the name of the platform. Required.</span>
    Ref string
    <span class="comment">//	A string that specifies for which API profile this hint is intended. It is the name of the profile within the effect that contains the technique. Optional. If set, can be &#34;COMMON&#34; or &#34;GLSL&#34;.</span>
    Profile string
}</pre>
			<p>
Adds a hint for a platform of which technique to use in this effect.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxImageDef">type <a href="/target/fximage.gt.go?s=9289:10438#L201">FxImageDef</a></h2>
			<pre>type FxImageDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Indicates whether this image represents a render target.</span>
    Renderable struct {
        <span class="comment">//	If true, defines the image as a render target, meaning the image can be rendered to.</span>
        Is bool
        <span class="comment">//	Indicates whether, when instantiated, the render target is to be shared among all instances instead of being cloned.</span>
        Shared bool
    }
    <span class="comment">//	If set, initializes a custom 2D image by specifying its size, viewport ratio, MIP levels, normalization, pixel format, and data sources. It also supports arrays of 2D images.</span>
    Create2D *FxCreate2D
    <span class="comment">//	If set, initializes a custom 3D image (a volumetric image) by specifying its size, MIP level, pixel format, and data sources. It also supports arrays of 3D images.</span>
    Create3D *FxCreate3D
    <span class="comment">//	If set, initializes the six faces of a cube by specifying its size, MIP level, pixel format, and data sources. It also supports arrays of images on each of the cube faces. It also supports arrays of cube images.</span>
    CreateCube *FxCreateCube
    <span class="comment">//	If set, initializes the image from a URL (for example, a file) or binary image data.</span>
    InitFrom *FxImageInitFrom
}</pre>
			<p>
Declares the storage for the graphical representation of an object.
</p>


			

			

			

			

			
				
				<h3 id="FxImageDef.Init">func (*FxImageDef) <a href="/target/fximage.gt.go?s=10458:10486#L224">Init</a></h3>
				<pre>func (me *FxImageDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxImageInitFrom">type <a href="/target/fximage.gt.go?s=8072:8287#L173">FxImageInitFrom</a></h2>
			<pre>type FxImageInitFrom struct {
    <span class="comment">//	Raw and RefUrl</span>
    FxInitFrom
    <span class="comment">//	If false, initializes higher MIP levels if data does not exist in a file. If true, no MIP levels are ever automatically initialized.</span>
    NoAutoMip bool
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			
				
				<h3 id="NewFxImageInitFrom">func <a href="/target/fximage.gt.go?s=8304:8364#L181">NewFxImageInitFrom</a></h3>
				<pre>func NewFxImageInitFrom(refUrl string) (me *FxImageInitFrom)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxImageInst">type <a href="/target/fximage.gt.go?s=10527:10594#L228">FxImageInst</a></h2>
			<pre>type FxImageInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates an image resource.
</p>


			

			

			

			

			
				
				<h3 id="FxImageInst.Init">func (*FxImageInst) <a href="/target/fximage.gt.go?s=10614:10643#L234">Init</a></h3>
				<pre>func (me *FxImageInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxInitFrom">type <a href="/target/fximage.gt.go?s=8512:9216#L188">FxInitFrom</a></h2>
			<pre>type FxInitFrom struct {
    <span class="comment">//	Embedded binary image data; used if RefUrl is empty and Raw.Data is not.</span>
    Raw struct {
        <span class="comment">//	Contains the embedded binary image data as a sequence of bytes. The data typically contains all the necessary information including header info such as data width and height.</span>
        Data []byte
        <span class="comment">//	Specifies which codec decodes the image’s descriptions and data. This is usually its typical file extension, such as &#34;BMP&#34;, &#34;JPG&#34;, &#34;DDS&#34;, &#34;TGA&#34;.</span>
        Format string
    }
    <span class="comment">//	Contains the URL of a file from which to take initialization data. Assumes the characteristics of the file. If it is a complex format such as DDS, this might include cube maps, volumes, MIPs, and so on.</span>
    RefUrl string
}</pre>
			<p>
Initializes an entire image or portions of an image from referenced or embedded data.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxMaterialDef">type <a href="/target/fxmaterial.gt.go?s=677:855#L12">FxMaterialDef</a></h2>
			<pre>type FxMaterialDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	The parameterized effect instantiation that fully describes and defines this material.</span>
    Effect FxEffectInst
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry and screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="FxMaterialDef.Init">func (*FxMaterialDef) <a href="/target/fxmaterial.gt.go?s=875:906#L20">Init</a></h3>
				<pre>func (me *FxMaterialDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxMaterialInst">type <a href="/target/fxmaterial.gt.go?s=949:1345#L24">FxMaterialInst</a></h2>
			<pre>type FxMaterialInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	Which symbol defined from within the geometry this material binds to.</span>
    Symbol string
    <span class="comment">//	Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.</span>
    Bindings []*FxBinding
    <span class="comment">//	Binds vertex inputs to effect parameters upon instantiation.</span>
    VertexInputBindings []*FxVertexInputBinding
}</pre>
			<p>
Instantiates a material resource.
</p>


			

			

			

			

			
				
				<h3 id="FxMaterialInst.Init">func (*FxMaterialInst) <a href="/target/fxmaterial.gt.go?s=1365:1397#L36">Init</a></h3>
				<pre>func (me *FxMaterialInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="FxParamDef">type <a href="/target/fxeffect.gt.go?s=1915:2203#L35">FxParamDef</a></h2>
			<pre>type FxParamDef struct {
    <span class="comment">//	Sid and Value</span>
    ParamDef
    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation
    <span class="comment">//	Specifies constant, external, or uniform parameters.</span>
    Modifier string
    <span class="comment">//	Provides metadata that describes the purpose of a parameter declaration.</span>
    Semantic string
}</pre>
			<p>
Declares a new parameter for its parent FX-related resource, and assigns it an initial value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxParamDefs">type <a href="/target/fxeffect.gt.go?s=2284:2323#L47">FxParamDefs</a></h2>
			<pre>type FxParamDefs map[string]*FxParamDef</pre>
			<p>
A hash-table containing parameter declarations of this FX-related resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPass">type <a href="/target/fxeffect.gt.go?s=2434:2880#L50">FxPass</a></h2>
			<pre>type FxPass struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Custom-profile/foreign-technique meta-data</span>
    HasExtras
    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation
    <span class="comment">//	Contains all rendering states to set up for this pass.</span>
    States map[string]*FxPassState
    <span class="comment">//	Links multiple shaders together to produce a pipeline for geometry processing.</span>
    Program *FxPassProgram
    <span class="comment">//	Contains evaluation elements for this rendering pass.</span>
    Evaluate *FxPassEvaluation
}</pre>
			<p>
Provides a static declaration of all the render states, shaders, and settings for one rendering pipeline.
</p>


			

			

			

			
				
				<h3 id="NewFxPass">func <a href="/target/fxeffect.gt.go?s=2897:2926#L66">NewFxPass</a></h3>
				<pre>func NewFxPass() (me *FxPass)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxPassEvaluation">type <a href="/target/fxeffect.gt.go?s=3043:4091#L72">FxPassEvaluation</a></h2>
			<pre>type FxPassEvaluation struct {
    <span class="comment">//	Instructs the FX Runtime what kind of geometry to submit.</span>
    Draw string
    <span class="comment">//	Color-information render target</span>
    Color struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearColor
        <span class="comment">//	Specifies which FxImageDef will receive the color information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
    <span class="comment">//	Depth-information render target</span>
    Depth struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearDepth
        <span class="comment">//	Specifies which FxImageDef will receive the depth information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
    <span class="comment">//	Stencil-information render target</span>
    Stencil struct {
        <span class="comment">//	Specifies whether this render target image is to be cleared, and which value to use.</span>
        Clear *FxPassEvaluationClearStencil
        <span class="comment">//	Specifies which FxImageDef will receive the stencil information from the output of this pass.</span>
        Target *FxPassEvaluationTarget
    }
}</pre>
			<p>
Contains evaluation elements for a rendering pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearColor">type <a href="/target/fxeffect.gt.go?s=4196:4368#L99">FxPassEvaluationClearColor</a></h2>
			<pre>type FxPassEvaluationClearColor struct {
    <span class="comment">//	Default clear-color value</span>
    ugfx.Rgba32
    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a color-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearDepth">type <a href="/target/fxeffect.gt.go?s=4473:4643#L107">FxPassEvaluationClearDepth</a></h2>
			<pre>type FxPassEvaluationClearDepth struct {
    <span class="comment">//	Default clear-depth value</span>
    F float64
    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a depth-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationClearStencil">type <a href="/target/fxeffect.gt.go?s=4750:4921#L115">FxPassEvaluationClearStencil</a></h2>
			<pre>type FxPassEvaluationClearStencil struct {
    <span class="comment">//	Default clear-stencil value</span>
    B byte
    <span class="comment">//	Which of the multiple render targets is being set. The default is 0.</span>
    Index uint64
}</pre>
			<p>
Specifies whether a stencil-information render target image is to be cleared, and which value to use.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassEvaluationTarget">type <a href="/target/fxeffect.gt.go?s=5009:5674#L123">FxPassEvaluationTarget</a></h2>
			<pre>type FxPassEvaluationTarget struct {
    <span class="comment">//	Indexes one of the Multiple Render Targets.</span>
    Index uint64
    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a layer of a 3D texture.</span>
    Slice uint64
    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a single MIP-map level.</span>
    Mip uint64
    <span class="comment">//	Indexes a sub-image inside a target surface, specifically: a unique cube face. Can be any of the FX_CUBE_FACE_* enumerated constants.</span>
    CubeFace int
    <span class="comment">//	If set, this render target references a sampler parameter to determine which image to use.</span>
    SamplerParamRef string
    <span class="comment">//	If set, this render target directly instantiates a renderable image.</span>
    Image *FxImageInst
}</pre>
			<p>
Specifies which FxImageDef will receive the information from the output of a pass.
</p>


			

			

			

			
				
				<h3 id="NewFxPassEvaluationTarget">func <a href="/target/fxeffect.gt.go?s=5691:5752#L139">NewFxPassEvaluationTarget</a></h3>
				<pre>func NewFxPassEvaluationTarget() (me *FxPassEvaluationTarget)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxPassProgram">type <a href="/target/fxeffect.gt.go?s=5888:6255#L145">FxPassProgram</a></h2>
			<pre>type FxPassProgram struct {
    <span class="comment">//	Information for binding the shader variables to effect parameters.</span>
    BindAttributes []*FxPassProgramBindAttribute
    <span class="comment">//	Binds a uniform shader variable to a parameter or a value.</span>
    BindUniforms []*FxPassProgramBindUniform
    <span class="comment">//	Setup and compilation information for shaders such as vertex and pixel shaders.</span>
    Shaders []*FxPassProgramShader
}</pre>
			<p>
Links multiple shaders together to produce a pipeline for geometry processing.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramBindAttribute">type <a href="/target/fxeffect.gt.go?s=6316:6612#L155">FxPassProgramBindAttribute</a></h2>
			<pre>type FxPassProgramBindAttribute struct {
    <span class="comment">//	The identifier for a vertex attribute variable in the shader (a formal function parameter or in-scope global).</span>
    Symbol string
    <span class="comment">//	Contains an alternative name to the attribute variable for semantic binding to geometry vertex inputs.</span>
    Semantic string
}</pre>
			<p>
Binds semantics to vertex attribute inputs of a shader.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramBindUniform">type <a href="/target/fxeffect.gt.go?s=6717:7101#L163">FxPassProgramBindUniform</a></h2>
			<pre>type FxPassProgramBindUniform struct {
    <span class="comment">//	The identifier for a uniform input parameter to the shader (a formal function parameter or in-scope global) that will be bound to an external resource.</span>
    Symbol string
    <span class="comment">//	If set, refers to a previously defined parameter providing the uniform value to be bound.</span>
    ParamRef string
    <span class="comment">//	If set, the uniform value to be bound.</span>
    Value interface{}
}</pre>
			<p>
Binds values to uniform inputs of a shader or binds values to effect parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramShader">type <a href="/target/fxeffect.gt.go?s=7188:7552#L173">FxPassProgramShader</a></h2>
			<pre>type FxPassProgramShader struct {
    <span class="comment">//	Custom-profile/foreign-technique meta-data</span>
    HasExtras
    <span class="comment">//	In which pipeline stage this programmable shader is designed to execute. Can be any of the FX_PASS_PROGRAM_SHADER_STAGE_* enumerated constants.</span>
    Stage int
    <span class="comment">//	Concatenates the source code for the shader from one or more sources.</span>
    Sources []FxPassProgramShaderSources
}</pre>
			<p>
Declares and prepares a shader for execution in the rendering pipeline of a pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassProgramShaderSources">type <a href="/target/fxeffect.gt.go?s=7602:7767#L183">FxPassProgramShaderSources</a></h2>
			<pre>type FxPassProgramShaderSources struct {
    <span class="comment">//	The code or import reference.</span>
    S string
    <span class="comment">//	If true, S is an import reference; otherwise, S is code.</span>
    IsImportRef bool
}</pre>
			<p>
Contains either code or an import reference.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxPassState">type <a href="/target/fxeffect.gt.go?s=7813:8078#L191">FxPassState</a></h2>
			<pre>type FxPassState struct {
    <span class="comment">//	If set, the value for this rendering state.</span>
    Value string
    <span class="comment">//	If set, refers to a previously defined parameter providing the value for this rendering state.</span>
    ParamRef string
    <span class="comment">//	State-specific optional index attribute.</span>
    Index float64
}</pre>
			<p>
Represents a rendering state for a pass.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxProfile">type <a href="/target/fxeffect.gt.go?s=8143:8608#L201">FxProfile</a></h2>
			<pre>type FxProfile struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Resource-specific asset-management information and meta-data.</span>
    HasAsset
    <span class="comment">//	Custom-profile/foreign-technique meta-data</span>
    HasExtras
    <span class="comment">//	A hash-table containing parameter declarations of this profile.</span>
    HasFxParamDefs
    <span class="comment">//	If set, this FxProfile represents a common, fixed-function shader pipeline.</span>
    Common *FxProfileCommon
    <span class="comment">//	If set, this FxProfile represents an OpenGL Shading Language (GLSL) pipeline.</span>
    GlSl *FxProfileGlSl
}</pre>
			<p>
An FX profile represents a shader-based rendering pipeline.
</p>


			

			

			

			
				
				<h3 id="NewProfile">func <a href="/target/fxeffect.gt.go?s=8610:8643#L216">NewProfile</a></h3>
				<pre>func NewProfile() (me *FxProfile)</pre>
				
				
			

			
		
			
			
			<h2 id="FxProfileCommon">type <a href="/target/fxeffect.gt.go?s=8807:8916#L223">FxProfileCommon</a></h2>
			<pre>type FxProfileCommon struct {
    <span class="comment">//	Declares the only technique for this effect.</span>
    Technique FxTechniqueCommon
}</pre>
			<p>
This FX profile provides platform-independent declarations for the common, fixed-function shader.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxProfileGlSl">type <a href="/target/fxeffect.gt.go?s=9010:9352#L229">FxProfileGlSl</a></h2>
			<pre>type FxProfileGlSl struct {
    <span class="comment">//	The type of platform. This is a vendor-defined character string that indicates the platform or capability target for the technique. Defaults to &#34;PC&#34;.</span>
    Platform string
    <span class="comment">//	GLSL shader sources</span>
    CodesIncludes []FxProfileGlSlCodeInclude
    <span class="comment">//	Declares the techniques for this effect.</span>
    Techniques []*FxTechniqueGlsl
}</pre>
			<p>
This FX profile provides platform-specific declarations for the OpenGL Shading Language.
</p>


			

			

			

			
				
				<h3 id="NewFxProfileGlSl">func <a href="/target/fxeffect.gt.go?s=9369:9412#L239">NewFxProfileGlSl</a></h3>
				<pre>func NewFxProfileGlSl() (me *FxProfileGlSl)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxProfileGlSlCodeInclude">type <a href="/target/fxeffect.gt.go?s=9486:9682#L245">FxProfileGlSlCodeInclude</a></h2>
			<pre>type FxProfileGlSlCodeInclude struct {
    <span class="comment">//	Source code or include reference</span>
    ScopedString
    <span class="comment">//	Indicates whether ScopedString is an import reference (true) or source code (false).</span>
    IsInclude bool
}</pre>
			<p>
GLSL shader sources
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxSampler">type <a href="/target/fxsampler.go?s=2740:3047#L50">FxSampler</a></h2>
			<pre>type FxSampler struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Filtering and Wrapping</span>
    FxSamplerStates
    <span class="comment">//	If set, instantiates a default image from which the sampler is to consume.</span>
    Image *FxImageInst
    <span class="comment">//	Indicates the type of this texture sampler. Must be one of the FX_SAMPLER_TYPE_* enumerated constants.</span>
    Type int
}</pre>
			<p>
Declares a texture sampler.
</p>


			

			

			

			
				
				<h3 id="NewFxSampler">func <a href="/target/fxsampler.go?s=3064:3099#L62">NewFxSampler</a></h3>
				<pre>func NewFxSampler() (me *FxSampler)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxSamplerFiltering">type <a href="/target/fxsampler.go?s=3434:4163#L76">FxSamplerFiltering</a></h2>
			<pre>type FxSamplerFiltering struct {
    <span class="comment">//	Magnification filter. Must be one of the FX_SAMPLER_FILTER_* enumerated constants.</span>
    FilterMag int
    <span class="comment">//	Minification filter. Must be one of the FX_SAMPLER_FILTER_* enumerated constants.</span>
    FilterMin int
    <span class="comment">//	Mip-mapping filter. Must be one of the FX_SAMPLER_FILTER_* enumerated constants.</span>
    FilterMip int
    <span class="comment">//	The number of samples that can be used durring anisotropic filtering.</span>
    MaxAnisotropy uint32
    <span class="comment">//	The maximum number of progressive levels that the sampler will evaluate.</span>
    MipMaxLevel uint8
    <span class="comment">//	The minimum progressive levels to begin to evaluate.</span>
    MipMinLevel uint8
    <span class="comment">//	Biases the gamma (level of detail parameter) that is used by the sampler to evaluate the MIPmap chain.</span>
    MipBias float64
}</pre>
			<p>
Controls texture minification, magnification and MIP-mapping.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxSamplerImage">type <a href="/target/fxsampler.go?s=3294:3367#L70">FxSamplerImage</a></h2>
			<pre>type FxSamplerImage struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    FxImageInst
}</pre>
			<p>
Instantiates an image targeted for samplers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxSamplerStates">type <a href="/target/fxsampler.go?s=4236:4460#L94">FxSamplerStates</a></h2>
			<pre>type FxSamplerStates struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Controls texture minification, magnification and MIP-mapping.</span>
    Filtering *FxSamplerFiltering
    <span class="comment">//	Controls texture repeating and clamping.</span>
    Wrapping *FxSamplerWrapping
}</pre>
			<p>
Allows users to modify an effect’s sampler state from a material.
</p>


			

			

			

			
				
				<h3 id="NewFxSamplerStates">func <a href="/target/fxsampler.go?s=4477:4524#L104">NewFxSamplerStates</a></h3>
				<pre>func NewFxSamplerStates() (me *FxSamplerStates)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="FxSamplerWrapping">type <a href="/target/fxsampler.go?s=4679:5267#L110">FxSamplerWrapping</a></h2>
			<pre>type FxSamplerWrapping struct {
    <span class="comment">//	When reading past the edge of the texture address space based on the wrap modes involving clamps, this color takes over.</span>
    BorderColor ugfx.Rgba32
    <span class="comment">//	Controls texture repeating and clamping of the S coordinate. Must be one of the FX_SAMPLER_WRAP_* enumerated constants.</span>
    WrapS int
    <span class="comment">//	Controls texture repeating and clamping of the T coordinate. Must be one of the FX_SAMPLER_WRAP_* enumerated constants.</span>
    WrapT int
    <span class="comment">//	Controls texture repeating and clamping of the P coordinate. Must be one of the FX_SAMPLER_WRAP_* enumerated constants.</span>
    WrapP int
}</pre>
			<p>
Controls texture repeating and clamping.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechnique">type <a href="/target/fxeffect.gt.go?s=9820:9919#L253">FxTechnique</a></h2>
			<pre>type FxTechnique struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Asset</span>
    HasAsset
    <span class="comment">//	Extras</span>
    HasExtras
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes necessary for rendering this effect using one method.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommon">type <a href="/target/fxeffect.gt.go?s=10066:10594#L265">FxTechniqueCommon</a></h2>
			<pre>type FxTechniqueCommon struct {
    <span class="comment">//	Id, Sid, Asset, Extras</span>
    FxTechnique
    <span class="comment">//	Produces a shaded surface with a Blinn BRDF approximation.</span>
    Blinn *FxTechniqueCommonBlinn
    <span class="comment">//	Produces a constantly shaded surface that is independent of lighting.</span>
    Constant *FxTechniqueCommonConstant
    <span class="comment">//	Produces a constantly shaded surface that is independent of lighting.</span>
    Lambert *FxTechniqueCommonLambert
    <span class="comment">//	Produces a shaded surface where the specular reflection is shaded according the Phong BRDF approximation.</span>
    Phong *FxTechniqueCommonPhong
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes necessary for rendering this effect within an FxProfileCommon.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommonBlinn">type <a href="/target/fxeffect.gt.go?s=10658:11043#L279">FxTechniqueCommonBlinn</a></h2>
			<pre>type FxTechniqueCommonBlinn struct {
    <span class="comment">//	Ambient, Diffuse, Emission, Reflective, Reflectivity, Transparent, Transparency, IndexOfRefraction</span>
    FxTechniqueCommonLambert
    <span class="comment">//	Declares the color of light specularly reflected from the surface of this object.</span>
    Specular *FxColorOrTexture
    <span class="comment">//	Declares the specularity or roughness of the specular reflection lobe.</span>
    Shininess *ParamScopedFloat
}</pre>
			<p>
Produces a shaded surface with a Blinn BRDF approximation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommonConstant">type <a href="/target/fxeffect.gt.go?s=11118:11864#L289">FxTechniqueCommonConstant</a></h2>
			<pre>type FxTechniqueCommonConstant struct {
    <span class="comment">//	Declares the amount of light emitted from the surface of this object</span>
    Emission *FxColorOrTexture
    <span class="comment">//	Declares the color of a perfect mirror reflection.</span>
    Reflective *FxColorOrTexture
    <span class="comment">//	Declares the amount of perfect mirror reflection to be added to the reflected light as a value between 0.0 and 1.0.</span>
    Reflectivity *ParamScopedFloat
    <span class="comment">//	Declares the color of perfectly refracted light.</span>
    Transparent *FxColorOrTexture
    <span class="comment">//	Declares the amount of perfectly refracted light added to the reflected color as a scalar value between 0.0 and 1.0.</span>
    Transparency *ParamScopedFloat
    <span class="comment">//	Declares the index of refraction for perfectly refracted light as a single scalar index.</span>
    IndexOfRefraction *ParamScopedFloat
}</pre>
			<p>
Produces a constantly shaded surface that is independent of lighting.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommonLambert">type <a href="/target/fxeffect.gt.go?s=11939:12315#L305">FxTechniqueCommonLambert</a></h2>
			<pre>type FxTechniqueCommonLambert struct {
    <span class="comment">//	Emission, Reflective, Reflectivity, Transparent, Transparency, IndexOfRefraction</span>
    FxTechniqueCommonConstant
    <span class="comment">//	Declares the amount of ambient light reflected from the surface of this object.</span>
    Ambient *FxColorOrTexture
    <span class="comment">//	Declares the amount of light diffusely reflected from the surface of this object.</span>
    Diffuse *FxColorOrTexture
}</pre>
			<p>
Produces a constantly shaded surface that is independent of lighting.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueCommonPhong">type <a href="/target/fxeffect.gt.go?s=12426:12612#L315">FxTechniqueCommonPhong</a></h2>
			<pre>type FxTechniqueCommonPhong struct {
    <span class="comment">//	Specular, Shininess, Ambient, Diffuse, Emission, Reflective, Reflectivity, Transparent, Transparency, IndexOfRefraction</span>
    FxTechniqueCommonBlinn
}</pre>
			<p>
Produces a shaded surface where the specular reflection is shaded according the Phong BRDF approximation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTechniqueGlsl">type <a href="/target/fxeffect.gt.go?s=12757:13012#L321">FxTechniqueGlsl</a></h2>
			<pre>type FxTechniqueGlsl struct {
    <span class="comment">//	Id, Sid, Asset, Extras</span>
    FxTechnique
    <span class="comment">//	Application-specific FX metadata</span>
    Annotations []*FxAnnotation
    <span class="comment">//	Static declarations of all the render states, shaders, and settings for the rendering pipeline.</span>
    Passes []*FxPass
}</pre>
			<p>
Holds a description of the textures, samplers, shaders, parameters, and passes necessary for rendering this effect within an FxProfileGlsl.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxTexture">type <a href="/target/fxeffect.gt.go?s=13116:13425#L331">FxTexture</a></h2>
			<pre>type FxTexture struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	References a previously defined FxSampler of type FX_SAMPLER_TYPE_2D.</span>
    Sampler2D string
    <span class="comment">//	A semantic token, which will be referenced within FxMaterialBinding to bind an array of texture-coordinates from a geometry instance to the sampler.</span>
    TexCoord string
}</pre>
			<p>
Used in FxColorOrTexture instances that refer to a texture image instead of a literal color value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxVertexInputBinding">type <a href="/target/fxmaterial.gt.go?s=365:567#L2">FxVertexInputBinding</a></h2>
			<pre>type FxVertexInputBinding struct {
    <span class="comment">//	Which effect parameter to bind.</span>
    Semantic string
    <span class="comment">//	Which input semantic to bind.</span>
    InputSemantic string
    <span class="comment">//	Which input set to bind. Optional.</span>
    InputSet *uint64
}</pre>
			<p>
Binds geometry vertex inputs to effect vertex inputs upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="GeometryBrep">type <a href="/target/geometrybrep.go?s=68:473#L1">GeometryBrep</a></h2>
			<pre>type GeometryBrep struct {
    HasExtras
    HasSources
    Vertices      GeometryVertices
    Curves        *GeometryBrepCurves
    SurfaceCurves *GeometryBrepSurfaceCurves
    Surfaces      *GeometryBrepSurfaces
    Edges         *GeometryBrepEdges
    Wires         *GeometryBrepWires
    Faces         *GeometryBrepFaces
    Pcurves       *GeometryBrepPcurves
    Shells        *GeometryBrepShells
    Solids        *GeometryBrepSolids
}</pre>
			

			

			

			

			
				
				<h3 id="NewGeometryBrep">func <a href="/target/geometrybrep.go?s=475:516#L12">NewGeometryBrep</a></h3>
				<pre>func NewGeometryBrep() (me *GeometryBrep)</pre>
				
				
			

			
		
			
			
			<h2 id="GeometryBrepBox">type <a href="/target/geometrybrep.go?s=576:638#L18">GeometryBrepBox</a></h2>
			<pre>type GeometryBrepBox struct {
    HasExtras
    HalfExtents Float3
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCapsule">type <a href="/target/geometrybrep.go?s=640:717#L23">GeometryBrepCapsule</a></h2>
			<pre>type GeometryBrepCapsule struct {
    HasExtras
    Height float64
    Radius Float3
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCircle">type <a href="/target/geometrybrep.go?s=719:780#L29">GeometryBrepCircle</a></h2>
			<pre>type GeometryBrepCircle struct {
    HasExtras
    Radius float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCone">type <a href="/target/geometrybrep.go?s=782:857#L34">GeometryBrepCone</a></h2>
			<pre>type GeometryBrepCone struct {
    HasExtras
    Angle  float64
    Radius float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCurve">type <a href="/target/geometrybrep.go?s=859:1196#L40">GeometryBrepCurve</a></h2>
			<pre>type GeometryBrepCurve struct {
    HasSid
    HasName
    Orientations []*GeometryBrepOrientation
    Origin       *unum.Vec3
    Element      struct {
        Line      *GeometryBrepLine
        Circle    *GeometryBrepCircle
        Ellipse   *GeometryBrepEllipse
        Parabola  *GeometryBrepParabola
        Hyperbola *GeometryBrepHyperbola
        Nurbs     *GeometryBrepNurbs
    }
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCurves">type <a href="/target/geometrybrep.go?s=1198:1272#L55">GeometryBrepCurves</a></h2>
			<pre>type GeometryBrepCurves struct {
    HasExtras
    Curves []*GeometryBrepCurve
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepCylinder">type <a href="/target/geometrybrep.go?s=1274:1336#L60">GeometryBrepCylinder</a></h2>
			<pre>type GeometryBrepCylinder struct {
    HasExtras
    Radius Float2
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepEdges">type <a href="/target/geometrybrep.go?s=1338:1413#L65">GeometryBrepEdges</a></h2>
			<pre>type GeometryBrepEdges struct {
    HasId
    HasName
    HasExtras
    IndexedInputs
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepEllipse">type <a href="/target/geometrybrep.go?s=1415:1476#L72">GeometryBrepEllipse</a></h2>
			<pre>type GeometryBrepEllipse struct {
    HasExtras
    Radius Float2
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepFaces">type <a href="/target/geometrybrep.go?s=1478:1553#L77">GeometryBrepFaces</a></h2>
			<pre>type GeometryBrepFaces struct {
    HasId
    HasName
    HasExtras
    IndexedInputs
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepHyperbola">type <a href="/target/geometrybrep.go?s=1555:1618#L84">GeometryBrepHyperbola</a></h2>
			<pre>type GeometryBrepHyperbola struct {
    HasExtras
    Radius Float2
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepLine">type <a href="/target/geometrybrep.go?s=1620:1705#L89">GeometryBrepLine</a></h2>
			<pre>type GeometryBrepLine struct {
    HasExtras
    Origin    unum.Vec3
    Direction unum.Vec3
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepNurbs">type <a href="/target/geometrybrep.go?s=1707:1850#L95">GeometryBrepNurbs</a></h2>
			<pre>type GeometryBrepNurbs struct {
    HasExtras
    HasSources
    Degree          uint64
    Closed          bool
    ControlVertices GeometryControlVertices
}</pre>
			

			

			

			

			
				
				<h3 id="NewGeometryBrepNurbs">func <a href="/target/geometrybrep.go?s=1852:1903#L103">NewGeometryBrepNurbs</a></h3>
				<pre>func NewGeometryBrepNurbs() (me *GeometryBrepNurbs)</pre>
				
				
			

			
		
			
			
			<h2 id="GeometryBrepNurbsSurface">type <a href="/target/geometrybrep.go?s=1968:2120#L109">GeometryBrepNurbsSurface</a></h2>
			<pre>type GeometryBrepNurbsSurface struct {
    HasExtras
    HasSources
    U, V struct {
        Degree uint64
        Closed bool
    }
    ControlVertices GeometryControlVertices
}</pre>
			

			

			

			

			
				
				<h3 id="NewGeometryBrepNurbsSurface">func <a href="/target/geometrybrep.go?s=2122:2187#L119">NewGeometryBrepNurbsSurface</a></h3>
				<pre>func NewGeometryBrepNurbsSurface() (me *GeometryBrepNurbsSurface)</pre>
				
				
			

			
		
			
			
			<h2 id="GeometryBrepOrientation">type <a href="/target/geometrybrep.go?s=2259:2330#L125">GeometryBrepOrientation</a></h2>
			<pre>type GeometryBrepOrientation struct {
    Axis  unum.Vec3
    Angle float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepParabola">type <a href="/target/geometrybrep.go?s=2332:2400#L130">GeometryBrepParabola</a></h2>
			<pre>type GeometryBrepParabola struct {
    HasExtras
    FocalLength float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepPcurves">type <a href="/target/geometrybrep.go?s=2402:2479#L135">GeometryBrepPcurves</a></h2>
			<pre>type GeometryBrepPcurves struct {
    HasId
    HasName
    HasExtras
    IndexedInputs
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepPlane">type <a href="/target/geometrybrep.go?s=2481:2542#L142">GeometryBrepPlane</a></h2>
			<pre>type GeometryBrepPlane struct {
    HasExtras
    Equation Float4
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepShells">type <a href="/target/geometrybrep.go?s=2544:2620#L147">GeometryBrepShells</a></h2>
			<pre>type GeometryBrepShells struct {
    HasId
    HasName
    HasExtras
    IndexedInputs
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSolids">type <a href="/target/geometrybrep.go?s=2622:2698#L154">GeometryBrepSolids</a></h2>
			<pre>type GeometryBrepSolids struct {
    HasId
    HasName
    HasExtras
    IndexedInputs
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSphere">type <a href="/target/geometrybrep.go?s=2700:2761#L161">GeometryBrepSphere</a></h2>
			<pre>type GeometryBrepSphere struct {
    HasExtras
    Radius float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurface">type <a href="/target/geometrybrep.go?s=2763:3162#L166">GeometryBrepSurface</a></h2>
			<pre>type GeometryBrepSurface struct {
    HasSid
    HasName
    Orientations []*GeometryBrepOrientation
    Origin       *unum.Vec3
    Element      struct {
        Cone         *GeometryBrepCone
        Plane        *GeometryBrepPlane
        Cylinder     *GeometryBrepCylinder
        NurbsSurface *GeometryBrepNurbsSurface
        Sphere       *GeometryBrepSphere
        Torus        *GeometryBrepTorus
        SweptSurface *GeometryBrepSweptSurface
    }
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurfaceCurves">type <a href="/target/geometrybrep.go?s=3164:3245#L182">GeometryBrepSurfaceCurves</a></h2>
			<pre>type GeometryBrepSurfaceCurves struct {
    HasExtras
    Curves []*GeometryBrepCurve
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSurfaces">type <a href="/target/geometrybrep.go?s=3247:3327#L187">GeometryBrepSurfaces</a></h2>
			<pre>type GeometryBrepSurfaces struct {
    HasExtras
    Surfaces []*GeometryBrepSurface
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepSweptSurface">type <a href="/target/geometrybrep.go?s=3329:3522#L192">GeometryBrepSweptSurface</a></h2>
			<pre>type GeometryBrepSweptSurface struct {
    HasExtras
    Curve              *GeometryBrepCurve
    ExtrusionDirection *unum.Vec3
    Revolution         struct {
        Origin *unum.Vec3
        Axis   *unum.Vec3
    }
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepTorus">type <a href="/target/geometrybrep.go?s=3524:3583#L202">GeometryBrepTorus</a></h2>
			<pre>type GeometryBrepTorus struct {
    HasExtras
    Radius Float2
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrepWires">type <a href="/target/geometrybrep.go?s=3585:3660#L207">GeometryBrepWires</a></h2>
			<pre>type GeometryBrepWires struct {
    HasId
    HasName
    HasExtras
    IndexedInputs
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryControlVertices">type <a href="/target/geometry.gt.go?s=339:400#L3">GeometryControlVertices</a></h2>
			<pre>type GeometryControlVertices struct {
    HasExtras
    HasInputs
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryDef">type <a href="/target/geometry.gt.go?s=1155:1259#L56">GeometryDef</a></h2>
			<pre>type GeometryDef struct {
    BaseDef
    Brep   *GeometryBrep
    Mesh   *GeometryMesh
    Spline *GeometrySpline
}</pre>
			

			

			

			

			

			
				
				<h3 id="GeometryDef.Init">func (*GeometryDef) <a href="/target/geometry.gt.go?s=1261:1290#L63">Init</a></h3>
				<pre>func (me *GeometryDef) Init()</pre>
				
				
				
			
		
			
			
			<h2 id="GeometryInst">type <a href="/target/geometry.gt.go?s=1296:1365#L66">GeometryInst</a></h2>
			<pre>type GeometryInst struct {
    BaseInst
    BindMaterial *MaterialBinding
}</pre>
			

			

			

			

			

			
				
				<h3 id="GeometryInst.Init">func (*GeometryInst) <a href="/target/geometry.gt.go?s=1367:1397#L71">Init</a></h3>
				<pre>func (me *GeometryInst) Init()</pre>
				
				
				
			
		
			
			
			<h2 id="GeometryMesh">type <a href="/target/geometry.gt.go?s=402:542#L8">GeometryMesh</a></h2>
			<pre>type GeometryMesh struct {
    HasExtras
    HasSources
    ConvexHullOf string
    Vertices     *GeometryVertices
    Primitives   []*GeometryPrimitives
}</pre>
			

			

			

			

			
				
				<h3 id="NewGeometryMesh">func <a href="/target/geometry.gt.go?s=544:585#L16">NewGeometryMesh</a></h3>
				<pre>func NewGeometryMesh() (me *GeometryMesh)</pre>
				
				
			

			
		
			
			
			<h2 id="GeometryPolygonHole">type <a href="/target/geometry.gt.go?s=783:856#L31">GeometryPolygonHole</a></h2>
			<pre>type GeometryPolygonHole struct {
    Indices []uint64
    Holes   [][]uint64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryPrimitives">type <a href="/target/geometry.gt.go?s=645:781#L22">GeometryPrimitives</a></h2>
			<pre>type GeometryPrimitives struct {
    HasExtras
    HasName
    IndexedInputs
    Material  string
    Type      int
    PolyHoles []*GeometryPolygonHole
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometrySpline">type <a href="/target/geometry.gt.go?s=858:974#L36">GeometrySpline</a></h2>
			<pre>type GeometrySpline struct {
    HasExtras
    HasSources
    Closed          bool
    ControlVertices GeometryControlVertices
}</pre>
			

			

			

			

			
				
				<h3 id="NewGeometrySpline">func <a href="/target/geometry.gt.go?s=976:1021#L43">NewGeometrySpline</a></h3>
				<pre>func NewGeometrySpline() (me *GeometrySpline)</pre>
				
				
			

			
		
			
			
			<h2 id="GeometryVertices">type <a href="/target/geometry.gt.go?s=1083:1153#L49">GeometryVertices</a></h2>
			<pre>type GeometryVertices struct {
    HasId
    HasName
    HasExtras
    HasInputs
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasAsset">type <a href="/target/common.go?s=836:940#L13">HasAsset</a></h2>
			<pre>type HasAsset struct {
    <span class="comment">//	Resource-specific asset-management information and meta-data.</span>
    Asset *Asset
}</pre>
			<p>
Used in all resources that require asset-management information.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasExtras">type <a href="/target/common.go?s=1018:1108#L19">HasExtras</a></h2>
			<pre>type HasExtras struct {
    <span class="comment">//	Custom-technique/foreign-profile meta-data.</span>
    Extras []*Extra
}</pre>
			<p>
Used in all resources that support custom techniques / foreign profiles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasFxParamDefs">type <a href="/target/common.go?s=1173:1299#L25">HasFxParamDefs</a></h2>
			<pre>type HasFxParamDefs struct {
    <span class="comment">//	A hash-table containing all parameter declarations of this resource.</span>
    NewParams FxParamDefs
}</pre>
			<p>
Used in all FX resources that declare their own parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasId">type <a href="/target/common.go?s=1368:1444#L31">HasId</a></h2>
			<pre>type HasId struct {
    <span class="comment">//	The unique identifier of this resource.</span>
    Id string
}</pre>
			<p>
Used in all resources that declare their own unique identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasInputs">type <a href="/target/common.go?s=1527:1659#L37">HasInputs</a></h2>
			<pre>type HasInputs struct {
    <span class="comment">//	Declares the input semantics of a data Source and connects a consumer to that Source.</span>
    Inputs []*Input
}</pre>
			<p>
Used in all data consumers that require input connections into a data Source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasName">type <a href="/target/common.go?s=1736:1845#L43">HasName</a></h2>
			<pre>type HasName struct {
    <span class="comment">//	The optional pretty-print name/title of this *Def*, *Inst* or *Lib*.</span>
    Name string
}</pre>
			<p>
Used in all resources that support arbitrary pretty-print names/titles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasParamDefs">type <a href="/target/common.go?s=1907:2029#L49">HasParamDefs</a></h2>
			<pre>type HasParamDefs struct {
    <span class="comment">//	A hash-table containing all parameter declarations of this resource.</span>
    NewParams ParamDefs
}</pre>
			<p>
Used in all resources that declare their own parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasParamInsts">type <a href="/target/common.go?s=2096:2201#L55">HasParamInsts</a></h2>
			<pre>type HasParamInsts struct {
    <span class="comment">//	All parameter values assigned by this resource.</span>
    SetParams []*ParamInst
}</pre>
			<p>
Used in all resources that assign values to other parameters.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasSid">type <a href="/target/common.go?s=2270:2348#L61">HasSid</a></h2>
			<pre>type HasSid struct {
    <span class="comment">//	The Scoped identifier of this resource.</span>
    Sid string
}</pre>
			<p>
Used in all resources that declare their own scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasSources">type <a href="/target/common.go?s=2401:2491#L67">HasSources</a></h2>
			<pre>type HasSources struct {
    <span class="comment">//	Provides the bulk of this resource&#39;s data.</span>
    Sources Sources
}</pre>
			<p>
Used in all resources that provide data arrays.
</p>


			

			

			

			

			
		
			
			
			<h2 id="HasTechniques">type <a href="/target/common.go?s=2569:2677#L73">HasTechniques</a></h2>
			<pre>type HasTechniques struct {
    <span class="comment">//	Custom-technique/foreign-profile content or data.</span>
    Techniques []*Technique
}</pre>
			<p>
Used in all resources that support custom techniques / foreign profiles.
</p>


			

			

			

			

			
		
			
			
			<h2 id="IndexedInputs">type <a href="/target/common.go?s=6204:6561#L160">IndexedInputs</a></h2>
			<pre>type IndexedInputs struct {
    <span class="comment">//	Number of primitives</span>
    Count uint64
    <span class="comment">//	Inputs specify how to read data from Sources.</span>
    Inputs []*InputShared
    <span class="comment">//	Indices that describe the attributes for a number of primitives. The indices reference into the Sources that are referenced by the Inputs.</span>
    Indices []uint64
    <span class="comment">//	Number of sub-primitives, if used.</span>
    Vcount []int64
}</pre>
			<p>
Used in various geometry primitives and b-rep resources.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Input">type <a href="/target/common.go?s=6657:6801#L172">Input</a></h2>
			<pre>type Input struct {
    <span class="comment">//	The user-defined meaning of the input connection.</span>
    Semantic string
    <span class="comment">//	The location of the data source.</span>
    Source string
}</pre>
			<p>
Declares unshared input semantics of a data source and connects a consumer to that source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="InputShared">type <a href="/target/common.go?s=6895:7128#L180">InputShared</a></h2>
			<pre>type InputShared struct {
    <span class="comment">//	Semantic and Source</span>
    Input
    <span class="comment">//	The offset into the list of indices.</span>
    Offset uint64
    <span class="comment">//	Which inputs to group as a single set. This is helpful when multiple inputs share the same semantics.</span>
    Set *uint64
}</pre>
			<p>
Declares shared input semantics of a data source and connects a consumer to that source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int2">type <a href="/target/types.go?s=1018:1036#L46">Int2</a></h2>
			<pre>type Int2 [2]int64</pre>
			<p>
Contains two int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int2x2">type <a href="/target/types.go?s=1069:1089#L49">Int2x2</a></h2>
			<pre>type Int2x2 [4]int64</pre>
			<p>
Contains four int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int3">type <a href="/target/types.go?s=1123:1141#L52">Int3</a></h2>
			<pre>type Int3 [3]int64</pre>
			<p>
Contains three int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int3x3">type <a href="/target/types.go?s=1174:1194#L55">Int3x3</a></h2>
			<pre>type Int3x3 [9]int64</pre>
			<p>
Contains nine int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int4">type <a href="/target/types.go?s=1227:1245#L58">Int4</a></h2>
			<pre>type Int4 [4]int64</pre>
			<p>
Contains four int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Int4x4">type <a href="/target/types.go?s=1281:1302#L61">Int4x4</a></h2>
			<pre>type Int4x4 [16]int64</pre>
			<p>
Contains sixteen int64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxArticulatedSystemAxisIndex">type <a href="/target/kxarticulatedsystem.gt.go?s=840:920#L14">KxArticulatedSystemAxisIndex</a></h2>
			<pre>type KxArticulatedSystemAxisIndex struct {
    Semantic string
    I        ParamInt
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="KxArticulatedSystemAxisLimits">type <a href="/target/kxarticulatedsystem.gt.go?s=922:999#L19">KxArticulatedSystemAxisLimits</a></h2>
			<pre>type KxArticulatedSystemAxisLimits struct {
    Min ParamFloat
    Max ParamFloat
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="KxArticulatedSystemDef">type <a href="/target/kxarticulatedsystem.gt.go?s=3125:3460#L116">KxArticulatedSystemDef</a></h2>
			<pre>type KxArticulatedSystemDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	If set, Motion must be nil, and this articulated system describes a kinematics system.</span>
    Kinematics *KxArticulatedSystemKinematics
    <span class="comment">//	If set, Kinematics must be nil, and this articulated system describes a motion system.</span>
    Motion *KxArticulatedSystemMotion
}</pre>
			<p>
Categorizes the declaration of generic control information for kinematics systems.
</p>


			

			

			

			

			
				
				<h3 id="KxArticulatedSystemDef.Init">func (*KxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=3480:3520#L126">Init</a></h3>
				<pre>func (me *KxArticulatedSystemDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxArticulatedSystemEffector">type <a href="/target/kxarticulatedsystem.gt.go?s=1001:1225#L24">KxArticulatedSystemEffector</a></h2>
			<pre>type KxArticulatedSystemEffector struct {
    HasSid
    HasName
    HasParamDefs
    HasParamInsts
    Bindings     []*KxBinding
    Speed        *ParamFloat2
    Acceleration *ParamFloat2
    Deceleration *ParamFloat2
    Jerk         *ParamFloat2
}</pre>
			

			

			

			

			
				
				<h3 id="NewKxArticulatedSystemEffector">func <a href="/target/kxarticulatedsystem.gt.go?s=1227:1298#L36">NewKxArticulatedSystemEffector</a></h3>
				<pre>func NewKxArticulatedSystemEffector() (me *KxArticulatedSystemEffector)</pre>
				
				
			

			
		
			
			
			<h2 id="KxArticulatedSystemInst">type <a href="/target/kxarticulatedsystem.gt.go?s=3584:3792#L130">KxArticulatedSystemInst</a></h2>
			<pre>type KxArticulatedSystemInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding
}</pre>
			<p>
Instantiates a kinematics articulated system resource.
</p>


			

			

			

			

			
				
				<h3 id="KxArticulatedSystemInst.Init">func (*KxArticulatedSystemInst) <a href="/target/kxarticulatedsystem.gt.go?s=3812:3853#L142">Init</a></h3>
				<pre>func (me *KxArticulatedSystemInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxArticulatedSystemKinematics">type <a href="/target/kxarticulatedsystem.gt.go?s=1377:1776#L42">KxArticulatedSystemKinematics</a></h2>
			<pre>type KxArticulatedSystemKinematics struct {
    <span class="comment">//	Techniques</span>
    HasTechniques
    Models []*KxModelInst
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        AxisInfos []*KxArticulatedSystemKinematicsAxis
        Frame     struct {
            Origin KxArticulatedSystemKinematicsFrame
            Tip    KxArticulatedSystemKinematicsFrame
            Tcp    *KxArticulatedSystemKinematicsFrame
            Object *KxArticulatedSystemKinematicsFrame
        }
    }
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="KxArticulatedSystemKinematicsAxis">type <a href="/target/kxarticulatedsystem.gt.go?s=1778:2071#L58">KxArticulatedSystemKinematicsAxis</a></h2>
			<pre>type KxArticulatedSystemKinematicsAxis struct {
    HasSid
    HasName
    HasParamDefs
    JointAxis string
    Active    ParamBool
    Indices   []*KxArticulatedSystemAxisIndex
    Locked    ParamBool
    Limits    *KxArticulatedSystemAxisLimits
    Formulas  struct {
        Defs  []*FormulaDef
        Insts []*FormulaInst
    }
}</pre>
			

			

			

			

			
				
				<h3 id="NewKxArticulatedSystemKinematicsAxis">func <a href="/target/kxarticulatedsystem.gt.go?s=2073:2156#L73">NewKxArticulatedSystemKinematicsAxis</a></h3>
				<pre>func NewKxArticulatedSystemKinematicsAxis() (me *KxArticulatedSystemKinematicsAxis)</pre>
				
				
			

			
		
			
			
			<h2 id="KxArticulatedSystemKinematicsFrame">type <a href="/target/kxarticulatedsystem.gt.go?s=2268:2378#L79">KxArticulatedSystemKinematicsFrame</a></h2>
			<pre>type KxArticulatedSystemKinematicsFrame struct {
    Link       string
    Type       int
    Transforms []*Transform
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="KxArticulatedSystemMotion">type <a href="/target/kxarticulatedsystem.gt.go?s=2380:2636#L85">KxArticulatedSystemMotion</a></h2>
			<pre>type KxArticulatedSystemMotion struct {
    <span class="comment">//	Techniques</span>
    HasTechniques
    ArticulatedSystem *KxArticulatedSystemInst
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        AxisInfos     []*KxArticulatedSystemMotionAxis
        EffectorInfos []*KxArticulatedSystemEffector
    }
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="KxArticulatedSystemMotionAxis">type <a href="/target/kxarticulatedsystem.gt.go?s=2638:2881#L96">KxArticulatedSystemMotionAxis</a></h2>
			<pre>type KxArticulatedSystemMotionAxis struct {
    HasSid
    HasName
    HasParamDefs
    HasParamInsts
    Axis         string
    Bindings     []*KxBinding
    Speed        *ParamFloat
    Acceleration *ParamFloat
    Deceleration *ParamFloat
    Jerk         *ParamFloat
}</pre>
			

			

			

			

			
				
				<h3 id="NewKxArticulatedSystemMotionAxis">func <a href="/target/kxarticulatedsystem.gt.go?s=2883:2958#L109">NewKxArticulatedSystemMotionAxis</a></h3>
				<pre>func NewKxArticulatedSystemMotionAxis() (me *KxArticulatedSystemMotionAxis)</pre>
				
				
			

			
		
			
			
			<h2 id="KxAttachment">type <a href="/target/kxmodel.gt.go?s=368:798#L3">KxAttachment</a></h2>
			<pre>type KxAttachment struct {
    <span class="comment">//	Must be one of the KX_ATTACHMENT_TYPE_* enumerated constants.</span>
    Type int
    <span class="comment">//	The reference to the joint that connects the parent with the child link. Required.</span>
    Joint string
    <span class="comment">//	Zero or more TRANSFORM_TYPE_ROTATE and/or TRANSFORM_TYPE_TRANSLATE transformations.</span>
    Transforms []*Transform
    <span class="comment">//	If Type is KX_ATTACHMENT_TYPE_FULL, specifies the child link in this parent-child dependency.</span>
    Link *KxLink
}</pre>
			<p>
Connects links or define ends of closed loops.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxBinding">type <a href="/target/kxarticulatedsystem.gt.go?s=616:838#L5">KxBinding</a></h2>
			<pre>type KxBinding struct {
    <span class="comment">//	The identifier of the parameter to bind to the new symbol name. Required.</span>
    Symbol string
    <span class="comment">//	If set, Value is ignored.</span>
    ParamRef RefParam
    <span class="comment">//	Only used if ParamRef is empty.</span>
    Value interface{}
}</pre>
			<p>
Binds inputs to kinematics parameters upon instantiation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJoint">type <a href="/target/kxjoint.gt.go?s=431:732#L1">KxJoint</a></h2>
			<pre>type KxJoint struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Must be one of the KX_JOINT_TYPE_* enumerated constants.</span>
    Type int
    <span class="comment">//	Specifies the axis of the degree of freedom.</span>
    Axis struct {
        <span class="comment">//	Name</span>
        HasName
        <span class="comment">//	Sid, V</span>
        ScopedVec3
    }
    <span class="comment">//	If set, these specified limits are physical limits.</span>
    Limits *KxJointLimits
}</pre>
			<p>
Primitive (simple) joints are joints with one degree of freedom (one given axis) and are used to construct more complex joint types (compound joints) that consist of multiple primitives, each representing an axis.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJointAxisBinding">type <a href="/target/kxscene.gt.go?s=861:1127#L7">KxJointAxisBinding</a></h2>
			<pre>type KxJointAxisBinding struct {
    <span class="comment">//	A reference to a transformation of a node.</span>
    Target RefSid
    <span class="comment">//	If set, Value is ignored. Specifies an axis of a kinematics model.</span>
    Axis ParamSidRef
    <span class="comment">//	Only used if Axis is empty. Specifies a value of the axis.</span>
    Value ParamFloat
}</pre>
			<p>
Binds a joint axis of a kinematics model to a single transformation of a node. By binding a joint axis to a transformation of a node, it is possible to synchronize a kinematics scene with a visual scene.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxJointDef">type <a href="/target/kxjoint.gt.go?s=1187:1500#L26">KxJointDef</a></h2>
			<pre>type KxJointDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Primitive (simple) joints are joints with one degree of freedom (one given axis) and are used to construct more complex joint types (compound joints) that consist of multiple primitives, each representing an axis.</span>
    All []*KxJoint
}</pre>
			<p>
Defines a single complex/compound joint with one or more degrees of freedom.
</p>


			

			

			

			

			
				
				<h3 id="KxJointDef.Init">func (*KxJointDef) <a href="/target/kxjoint.gt.go?s=1520:1548#L36">Init</a></h3>
				<pre>func (me *KxJointDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxJointInst">type <a href="/target/kxjoint.gt.go?s=1599:1666#L40">KxJointInst</a></h2>
			<pre>type KxJointInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates a kinematics joint resource.
</p>


			

			

			

			

			
				
				<h3 id="KxJointInst.Init">func (*KxJointInst) <a href="/target/kxjoint.gt.go?s=1686:1715#L46">Init</a></h3>
				<pre>func (me *KxJointInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxJointLimits">type <a href="/target/kxjoint.gt.go?s=920:1105#L18">KxJointLimits</a></h2>
			<pre>type KxJointLimits struct {
    <span class="comment">//	If set, the &#34;minimum&#34; portion of this joint limitation.</span>
    Min *ScopedFloat
    <span class="comment">//	If set, the &#34;maximum&#34; portion of this joint limitation.</span>
    Max *ScopedFloat
}</pre>
			<p>
Declares a primitive/simple joint as fully limited (if Min and Max are both set), partially limited (if either Min or Max is nil, but not both) or unlimited (if Min and Max are nil).
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxLink">type <a href="/target/kxmodel.gt.go?s=905:1147#L15">KxLink</a></h2>
			<pre>type KxLink struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Zero or more TRANSFORM_TYPE_ROTATE and/or TRANSFORM_TYPE_TRANSLATE transformations.</span>
    Transforms []*Transform
    <span class="comment">//	The attachments that make up this link.</span>
    Attachments []*KxAttachment
}</pre>
			<p>
Represents a rigid kinematical object without mass whose motion is constrained by one or more joints.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxModelBinding">type <a href="/target/kxscene.gt.go?s=193:652#L1">KxModelBinding</a></h2>
			<pre>type KxModelBinding struct {
    <span class="comment">//	A reference to a node.</span>
    Node RefId
    <span class="comment">//	Refers to the kinematics model being bound. Only either SidRef or ParamRef, but not both, must be specified.</span>
    Model struct {
        <span class="comment">//	If set, ParamRef must be empty. The Sid path to the kinematics model to bind to the node.</span>
        SidRef RefSid
        <span class="comment">//	If set, SidRef must be empty. The parameter of the kinematics model that is defined in the instantiated kinematics scene.</span>
        ParamRef RefParam
    }
}</pre>
			<p>
Binds a kinematics model to a node. The description of a kinematics model is completely independent of any visual information, but for calculation the position is important.
</p>


			

			

			

			

			
		
			
			
			<h2 id="KxModelDef">type <a href="/target/kxmodel.gt.go?s=1405:1685#L28">KxModelDef</a></h2>
			<pre>type KxModelDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	NewParams</span>
        HasParamDefs
        <span class="comment">//	The kinematics chain.</span>
        Links []*KxLink
        <span class="comment">//	Specifies dependencies among the joints.</span>
        Formulas []Formula
    }
}</pre>
			<p>
Categorizes the declaration of kinematical information, containing declarations of joints, links, and attachment points.
A kinematics model is focused on strict kinematics description &#34;in zero position&#34;, without any additional physical descriptions.
</p>


			

			

			

			

			
				
				<h3 id="KxModelDef.Init">func (*KxModelDef) <a href="/target/kxmodel.gt.go?s=1705:1733#L45">Init</a></h3>
				<pre>func (me *KxModelDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxModelInst">type <a href="/target/kxmodel.gt.go?s=1815:2011#L50">KxModelInst</a></h2>
			<pre>type KxModelInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	Bindings of inputs to kinematics parameters.</span>
    Bindings []*KxBinding
}</pre>
			<p>
Instantiates a kinematics model resource.
</p>


			

			

			

			

			
				
				<h3 id="KxModelInst.Init">func (*KxModelInst) <a href="/target/kxmodel.gt.go?s=2031:2060#L62">Init</a></h3>
				<pre>func (me *KxModelInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxSceneDef">type <a href="/target/kxscene.gt.go?s=1239:1524#L17">KxSceneDef</a></h2>
			<pre>type KxSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Zero or more kinematics models participating in this kinematics scene.</span>
    Models []*KxModelInst
    <span class="comment">//	Zero or more articulated systems participating in this kinematics scene.</span>
    ArticulatedSystems []*KxArticulatedSystemInst
}</pre>
			<p>
Embodies the entire set of kinematics information that can be articulated from the contents of a resource.
</p>


			

			

			

			

			
				
				<h3 id="KxSceneDef.Init">func (*KxSceneDef) <a href="/target/kxscene.gt.go?s=1544:1572#L27">Init</a></h3>
				<pre>func (me *KxSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="KxSceneInst">type <a href="/target/kxscene.gt.go?s=1623:1969#L31">KxSceneInst</a></h2>
			<pre>type KxSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	NewParams</span>
    HasParamDefs
    <span class="comment">//	SetParams</span>
    HasParamInsts
    <span class="comment">//	Zero or more bindings of kinematics models to nodes.</span>
    ModelBindings []*KxModelBinding
    <span class="comment">//	Zero or more bindings of kinematics models&#39; joint axes to single node transformations.</span>
    JointAxisBindings []*KxJointAxisBinding
}</pre>
			<p>
Instantiates a kinematics scene resource.
</p>


			

			

			

			

			
				
				<h3 id="KxSceneInst.Init">func (*KxSceneInst) <a href="/target/kxscene.gt.go?s=1989:2018#L45">Init</a></h3>
				<pre>func (me *KxSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="Layers">type <a href="/target/common.go?s=7198:7225#L190">Layers</a></h2>
			<pre>type Layers map[string]bool</pre>
			<p>
Allows simple association of resources with custom named layers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LibAnimationClipDefs">type <a href="/target/animationclip.gt.go?s=2394:2674#L73">LibAnimationClipDefs</a></h2>
			<pre>type LibAnimationClipDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*AnimationClipDef
}</pre>
			<p>
A library that contains *AnimationClipDef*s associated by their *Id*. To create a new *LibAnimationClipDefs* library, ONLY
use the *LibsAnimationClipDef.New()* or *LibsAnimationClipDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibAnimationClipDefs.Add">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=3070:3148#L89">Add</a></h3>
				<pre>func (me *LibAnimationClipDefs) Add(d *AnimationClipDef) (n *AnimationClipDef)</pre>
				<p>
Adds the specified *AnimationClipDef* definition to this *LibAnimationClipDefs*, and returns it.
</p>
<p>
If this *LibAnimationClipDefs* already contains a *AnimationClipDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.AddNew">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=3500:3567#L100">AddNew</a></h3>
				<pre>func (me *LibAnimationClipDefs) AddNew(id string) *AnimationClipDef</pre>
				<p>
Creates a new *AnimationClipDef* definition with the specified *Id*, adds it to this *LibAnimationClipDefs*, and returns it.
</p>
<p>
If this *LibAnimationClipDefs* already contains a *AnimationClipDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.Len">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=3628:3669#L103">Len</a></h3>
				<pre>func (me *LibAnimationClipDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.New">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=3831:3901#L106">New</a></h3>
				<pre>func (me *LibAnimationClipDefs) New(id string) (def *AnimationClipDef)</pre>
				<p>
Creates a new *AnimationClipDef* definition with the specified *Id* and returns it, but does not add it to this *LibAnimationClipDefs*.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.Remove">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=4037:4086#L109">Remove</a></h3>
				<pre>func (me *LibAnimationClipDefs) Remove(id string)</pre>
				<p>
Removes the *AnimationClipDef* with the specified *Id* from this *LibAnimationClipDefs*.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.SyncChanges">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=4444:4489#L114">SyncChanges</a></h3>
				<pre>func (me *LibAnimationClipDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibAnimationClipDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibAnimationClipDefs* library or its *AnimationClipDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibAnimationDefs">type <a href="/target/animation.gt.go?s=3955:4227#L131">LibAnimationDefs</a></h2>
			<pre>type LibAnimationDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*AnimationDef
}</pre>
			<p>
A library that contains *AnimationDef*s associated by their *Id*. To create a new *LibAnimationDefs* library, ONLY
use the *LibsAnimationDef.New()* or *LibsAnimationDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibAnimationDefs.Add">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=4591:4657#L147">Add</a></h3>
				<pre>func (me *LibAnimationDefs) Add(d *AnimationDef) (n *AnimationDef)</pre>
				<p>
Adds the specified *AnimationDef* definition to this *LibAnimationDefs*, and returns it.
</p>
<p>
If this *LibAnimationDefs* already contains a *AnimationDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.AddNew">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=4993:5052#L158">AddNew</a></h3>
				<pre>func (me *LibAnimationDefs) AddNew(id string) *AnimationDef</pre>
				<p>
Creates a new *AnimationDef* definition with the specified *Id*, adds it to this *LibAnimationDefs*, and returns it.
</p>
<p>
If this *LibAnimationDefs* already contains a *AnimationDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.Len">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=5113:5150#L161">Len</a></h3>
				<pre>func (me *LibAnimationDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.New">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=5304:5366#L164">New</a></h3>
				<pre>func (me *LibAnimationDefs) New(id string) (def *AnimationDef)</pre>
				<p>
Creates a new *AnimationDef* definition with the specified *Id* and returns it, but does not add it to this *LibAnimationDefs*.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.Remove">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=5490:5535#L167">Remove</a></h3>
				<pre>func (me *LibAnimationDefs) Remove(id string)</pre>
				<p>
Removes the *AnimationDef* with the specified *Id* from this *LibAnimationDefs*.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.SyncChanges">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=5881:5922#L172">SyncChanges</a></h3>
				<pre>func (me *LibAnimationDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibAnimationDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibAnimationDefs* library or its *AnimationDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibCameraDefs">type <a href="/target/camera.gt.go?s=3473:3739#L120">LibCameraDefs</a></h2>
			<pre>type LibCameraDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*CameraDef
}</pre>
			<p>
A library that contains *CameraDef*s associated by their *Id*. To create a new *LibCameraDefs* library, ONLY
use the *LibsCameraDef.New()* or *LibsCameraDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibCameraDefs.Add">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4079:4136#L136">Add</a></h3>
				<pre>func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</pre>
				<p>
Adds the specified *CameraDef* definition to this *LibCameraDefs*, and returns it.
</p>
<p>
If this *LibCameraDefs* already contains a *CameraDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.AddNew">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4460:4513#L147">AddNew</a></h3>
				<pre>func (me *LibCameraDefs) AddNew(id string) *CameraDef</pre>
				<p>
Creates a new *CameraDef* definition with the specified *Id*, adds it to this *LibCameraDefs*, and returns it.
</p>
<p>
If this *LibCameraDefs* already contains a *CameraDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Len">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4574:4608#L150">Len</a></h3>
				<pre>func (me *LibCameraDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibCameraDefs.New">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4756:4812#L153">New</a></h3>
				<pre>func (me *LibCameraDefs) New(id string) (def *CameraDef)</pre>
				<p>
Creates a new *CameraDef* definition with the specified *Id* and returns it, but does not add it to this *LibCameraDefs*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Remove">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4927:4969#L156">Remove</a></h3>
				<pre>func (me *LibCameraDefs) Remove(id string)</pre>
				<p>
Removes the *CameraDef* with the specified *Id* from this *LibCameraDefs*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.SyncChanges">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5306:5344#L161">SyncChanges</a></h3>
				<pre>func (me *LibCameraDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibCameraDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibCameraDefs* library or its *CameraDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibControllerDefs">type <a href="/target/controller.gt.go?s=4411:4685#L132">LibControllerDefs</a></h2>
			<pre>type LibControllerDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*ControllerDef
}</pre>
			<p>
A library that contains *ControllerDef*s associated by their *Id*. To create a new *LibControllerDefs* library, ONLY
use the *LibsControllerDef.New()* or *LibsControllerDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibControllerDefs.Add">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=5057:5126#L148">Add</a></h3>
				<pre>func (me *LibControllerDefs) Add(d *ControllerDef) (n *ControllerDef)</pre>
				<p>
Adds the specified *ControllerDef* definition to this *LibControllerDefs*, and returns it.
</p>
<p>
If this *LibControllerDefs* already contains a *ControllerDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.AddNew">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=5466:5527#L159">AddNew</a></h3>
				<pre>func (me *LibControllerDefs) AddNew(id string) *ControllerDef</pre>
				<p>
Creates a new *ControllerDef* definition with the specified *Id*, adds it to this *LibControllerDefs*, and returns it.
</p>
<p>
If this *LibControllerDefs* already contains a *ControllerDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.Len">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=5588:5626#L162">Len</a></h3>
				<pre>func (me *LibControllerDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibControllerDefs.New">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=5782:5846#L165">New</a></h3>
				<pre>func (me *LibControllerDefs) New(id string) (def *ControllerDef)</pre>
				<p>
Creates a new *ControllerDef* definition with the specified *Id* and returns it, but does not add it to this *LibControllerDefs*.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.Remove">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=5973:6019#L168">Remove</a></h3>
				<pre>func (me *LibControllerDefs) Remove(id string)</pre>
				<p>
Removes the *ControllerDef* with the specified *Id* from this *LibControllerDefs*.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.SyncChanges">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=6368:6410#L173">SyncChanges</a></h3>
				<pre>func (me *LibControllerDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibControllerDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibControllerDefs* library or its *ControllerDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibFormulaDefs">type <a href="/target/formula.gt.go?s=2770:3038#L99">LibFormulaDefs</a></h2>
			<pre>type LibFormulaDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*FormulaDef
}</pre>
			<p>
A library that contains *FormulaDef*s associated by their *Id*. To create a new *LibFormulaDefs* library, ONLY
use the *LibsFormulaDef.New()* or *LibsFormulaDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFormulaDefs.Add">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=3386:3446#L115">Add</a></h3>
				<pre>func (me *LibFormulaDefs) Add(d *FormulaDef) (n *FormulaDef)</pre>
				<p>
Adds the specified *FormulaDef* definition to this *LibFormulaDefs*, and returns it.
</p>
<p>
If this *LibFormulaDefs* already contains a *FormulaDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.AddNew">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=3774:3829#L126">AddNew</a></h3>
				<pre>func (me *LibFormulaDefs) AddNew(id string) *FormulaDef</pre>
				<p>
Creates a new *FormulaDef* definition with the specified *Id*, adds it to this *LibFormulaDefs*, and returns it.
</p>
<p>
If this *LibFormulaDefs* already contains a *FormulaDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.Len">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=3890:3925#L129">Len</a></h3>
				<pre>func (me *LibFormulaDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.New">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4075:4133#L132">New</a></h3>
				<pre>func (me *LibFormulaDefs) New(id string) (def *FormulaDef)</pre>
				<p>
Creates a new *FormulaDef* definition with the specified *Id* and returns it, but does not add it to this *LibFormulaDefs*.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.Remove">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4251:4294#L135">Remove</a></h3>
				<pre>func (me *LibFormulaDefs) Remove(id string)</pre>
				<p>
Removes the *FormulaDef* with the specified *Id* from this *LibFormulaDefs*.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.SyncChanges">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=4634:4673#L140">SyncChanges</a></h3>
				<pre>func (me *LibFormulaDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibFormulaDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibFormulaDefs* library or its *FormulaDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxEffectDefs">type <a href="/target/fxeffect.gt.go?s=16308:16578#L439">LibFxEffectDefs</a></h2>
			<pre>type LibFxEffectDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxEffectDef
}</pre>
			<p>
A library that contains *FxEffectDef*s associated by their *Id*. To create a new *LibFxEffectDefs* library, ONLY
use the *LibsFxEffectDef.New()* or *LibsFxEffectDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxEffectDefs.Add">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=16934:16997#L455">Add</a></h3>
				<pre>func (me *LibFxEffectDefs) Add(d *FxEffectDef) (n *FxEffectDef)</pre>
				<p>
Adds the specified *FxEffectDef* definition to this *LibFxEffectDefs*, and returns it.
</p>
<p>
If this *LibFxEffectDefs* already contains a *FxEffectDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.AddNew">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=17329:17386#L466">AddNew</a></h3>
				<pre>func (me *LibFxEffectDefs) AddNew(id string) *FxEffectDef</pre>
				<p>
Creates a new *FxEffectDef* definition with the specified *Id*, adds it to this *LibFxEffectDefs*, and returns it.
</p>
<p>
If this *LibFxEffectDefs* already contains a *FxEffectDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.Len">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=17447:17483#L469">Len</a></h3>
				<pre>func (me *LibFxEffectDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.New">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=17635:17695#L472">New</a></h3>
				<pre>func (me *LibFxEffectDefs) New(id string) (def *FxEffectDef)</pre>
				<p>
Creates a new *FxEffectDef* definition with the specified *Id* and returns it, but does not add it to this *LibFxEffectDefs*.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.Remove">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=17816:17860#L475">Remove</a></h3>
				<pre>func (me *LibFxEffectDefs) Remove(id string)</pre>
				<p>
Removes the *FxEffectDef* with the specified *Id* from this *LibFxEffectDefs*.
</p>

				
				
			
				
				<h3 id="LibFxEffectDefs.SyncChanges">func (*LibFxEffectDefs) <a href="/target/fxeffect.gt.go?s=18203:18243#L480">SyncChanges</a></h3>
				<pre>func (me *LibFxEffectDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibFxEffectDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibFxEffectDefs* library or its *FxEffectDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxImageDefs">type <a href="/target/fximage.gt.go?s=12585:12853#L302">LibFxImageDefs</a></h2>
			<pre>type LibFxImageDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxImageDef
}</pre>
			<p>
A library that contains *FxImageDef*s associated by their *Id*. To create a new *LibFxImageDefs* library, ONLY
use the *LibsFxImageDef.New()* or *LibsFxImageDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxImageDefs.Add">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=13201:13261#L318">Add</a></h3>
				<pre>func (me *LibFxImageDefs) Add(d *FxImageDef) (n *FxImageDef)</pre>
				<p>
Adds the specified *FxImageDef* definition to this *LibFxImageDefs*, and returns it.
</p>
<p>
If this *LibFxImageDefs* already contains a *FxImageDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.AddFromRefUrls">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=10772:10841#L238">AddFromRefUrls</a></h3>
				<pre>func (me *LibFxImageDefs) AddFromRefUrls(idRefUrls map[string]string)</pre>
				<p>
Adds multiple FxImageDefs to this library, with each one&#39;s Id and InitFrom.RefUrl set from the specified idRefUrls map.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.AddNew">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=13589:13644#L329">AddNew</a></h3>
				<pre>func (me *LibFxImageDefs) AddNew(id string) *FxImageDef</pre>
				<p>
Creates a new *FxImageDef* definition with the specified *Id*, adds it to this *LibFxImageDefs*, and returns it.
</p>
<p>
If this *LibFxImageDefs* already contains a *FxImageDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.Len">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=13705:13740#L332">Len</a></h3>
				<pre>func (me *LibFxImageDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.New">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=13890:13948#L335">New</a></h3>
				<pre>func (me *LibFxImageDefs) New(id string) (def *FxImageDef)</pre>
				<p>
Creates a new *FxImageDef* definition with the specified *Id* and returns it, but does not add it to this *LibFxImageDefs*.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.Remove">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14066:14109#L338">Remove</a></h3>
				<pre>func (me *LibFxImageDefs) Remove(id string)</pre>
				<p>
Removes the *FxImageDef* with the specified *Id* from this *LibFxImageDefs*.
</p>

				
				
			
				
				<h3 id="LibFxImageDefs.SyncChanges">func (*LibFxImageDefs) <a href="/target/fximage.gt.go?s=14449:14488#L343">SyncChanges</a></h3>
				<pre>func (me *LibFxImageDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibFxImageDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibFxImageDefs* library or its *FxImageDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibFxMaterialDefs">type <a href="/target/fxmaterial.gt.go?s=3143:3417#L97">LibFxMaterialDefs</a></h2>
			<pre>type LibFxMaterialDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*FxMaterialDef
}</pre>
			<p>
A library that contains *FxMaterialDef*s associated by their *Id*. To create a new *LibFxMaterialDefs* library, ONLY
use the *LibsFxMaterialDef.New()* or *LibsFxMaterialDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFxMaterialDefs.Add">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=3789:3858#L113">Add</a></h3>
				<pre>func (me *LibFxMaterialDefs) Add(d *FxMaterialDef) (n *FxMaterialDef)</pre>
				<p>
Adds the specified *FxMaterialDef* definition to this *LibFxMaterialDefs*, and returns it.
</p>
<p>
If this *LibFxMaterialDefs* already contains a *FxMaterialDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.AddNew">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=4198:4259#L124">AddNew</a></h3>
				<pre>func (me *LibFxMaterialDefs) AddNew(id string) *FxMaterialDef</pre>
				<p>
Creates a new *FxMaterialDef* definition with the specified *Id*, adds it to this *LibFxMaterialDefs*, and returns it.
</p>
<p>
If this *LibFxMaterialDefs* already contains a *FxMaterialDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.Len">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=4320:4358#L127">Len</a></h3>
				<pre>func (me *LibFxMaterialDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.New">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=4514:4578#L130">New</a></h3>
				<pre>func (me *LibFxMaterialDefs) New(id string) (def *FxMaterialDef)</pre>
				<p>
Creates a new *FxMaterialDef* definition with the specified *Id* and returns it, but does not add it to this *LibFxMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.Remove">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=4705:4751#L133">Remove</a></h3>
				<pre>func (me *LibFxMaterialDefs) Remove(id string)</pre>
				<p>
Removes the *FxMaterialDef* with the specified *Id* from this *LibFxMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibFxMaterialDefs.SyncChanges">func (*LibFxMaterialDefs) <a href="/target/fxmaterial.gt.go?s=5100:5142#L138">SyncChanges</a></h3>
				<pre>func (me *LibFxMaterialDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibFxMaterialDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibFxMaterialDefs* library or its *FxMaterialDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibGeometryDefs">type <a href="/target/geometry.gt.go?s=3075:3345#L132">LibGeometryDefs</a></h2>
			<pre>type LibGeometryDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*GeometryDef
}</pre>
			<p>
A library that contains *GeometryDef*s associated by their *Id*. To create a new *LibGeometryDefs* library, ONLY
use the *LibsGeometryDef.New()* or *LibsGeometryDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibGeometryDefs.Add">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=3701:3764#L148">Add</a></h3>
				<pre>func (me *LibGeometryDefs) Add(d *GeometryDef) (n *GeometryDef)</pre>
				<p>
Adds the specified *GeometryDef* definition to this *LibGeometryDefs*, and returns it.
</p>
<p>
If this *LibGeometryDefs* already contains a *GeometryDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.AddNew">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=4096:4153#L159">AddNew</a></h3>
				<pre>func (me *LibGeometryDefs) AddNew(id string) *GeometryDef</pre>
				<p>
Creates a new *GeometryDef* definition with the specified *Id*, adds it to this *LibGeometryDefs*, and returns it.
</p>
<p>
If this *LibGeometryDefs* already contains a *GeometryDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.Len">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=4214:4250#L162">Len</a></h3>
				<pre>func (me *LibGeometryDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.New">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=4402:4462#L165">New</a></h3>
				<pre>func (me *LibGeometryDefs) New(id string) (def *GeometryDef)</pre>
				<p>
Creates a new *GeometryDef* definition with the specified *Id* and returns it, but does not add it to this *LibGeometryDefs*.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.Remove">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=4583:4627#L168">Remove</a></h3>
				<pre>func (me *LibGeometryDefs) Remove(id string)</pre>
				<p>
Removes the *GeometryDef* with the specified *Id* from this *LibGeometryDefs*.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.SyncChanges">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=4970:5010#L173">SyncChanges</a></h3>
				<pre>func (me *LibGeometryDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibGeometryDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibGeometryDefs* library or its *GeometryDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxArticulatedSystemDefs">type <a href="/target/kxarticulatedsystem.gt.go?s=5933:6225#L204">LibKxArticulatedSystemDefs</a></h2>
			<pre>type LibKxArticulatedSystemDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxArticulatedSystemDef
}</pre>
			<p>
A library that contains *KxArticulatedSystemDef*s associated by their *Id*. To create a new *LibKxArticulatedSystemDefs* library, ONLY
use the *LibsKxArticulatedSystemDef.New()* or *LibsKxArticulatedSystemDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxArticulatedSystemDefs.Add">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=6669:6765#L220">Add</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Add(d *KxArticulatedSystemDef) (n *KxArticulatedSystemDef)</pre>
				<p>
Adds the specified *KxArticulatedSystemDef* definition to this *LibKxArticulatedSystemDefs*, and returns it.
</p>
<p>
If this *LibKxArticulatedSystemDefs* already contains a *KxArticulatedSystemDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.AddNew">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=7141:7220#L231">AddNew</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) AddNew(id string) *KxArticulatedSystemDef</pre>
				<p>
Creates a new *KxArticulatedSystemDef* definition with the specified *Id*, adds it to this *LibKxArticulatedSystemDefs*, and returns it.
</p>
<p>
If this *LibKxArticulatedSystemDefs* already contains a *KxArticulatedSystemDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.Len">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=7281:7328#L234">Len</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.New">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=7502:7584#L237">New</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) New(id string) (def *KxArticulatedSystemDef)</pre>
				<p>
Creates a new *KxArticulatedSystemDef* definition with the specified *Id* and returns it, but does not add it to this *LibKxArticulatedSystemDefs*.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.Remove">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=7738:7793#L240">Remove</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) Remove(id string)</pre>
				<p>
Removes the *KxArticulatedSystemDef* with the specified *Id* from this *LibKxArticulatedSystemDefs*.
</p>

				
				
			
				
				<h3 id="LibKxArticulatedSystemDefs.SyncChanges">func (*LibKxArticulatedSystemDefs) <a href="/target/kxarticulatedsystem.gt.go?s=8169:8220#L245">SyncChanges</a></h3>
				<pre>func (me *LibKxArticulatedSystemDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibKxArticulatedSystemDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibKxArticulatedSystemDefs* library or its *KxArticulatedSystemDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxJointDefs">type <a href="/target/kxjoint.gt.go?s=3359:3627#L107">LibKxJointDefs</a></h2>
			<pre>type LibKxJointDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxJointDef
}</pre>
			<p>
A library that contains *KxJointDef*s associated by their *Id*. To create a new *LibKxJointDefs* library, ONLY
use the *LibsKxJointDef.New()* or *LibsKxJointDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxJointDefs.Add">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=3975:4035#L123">Add</a></h3>
				<pre>func (me *LibKxJointDefs) Add(d *KxJointDef) (n *KxJointDef)</pre>
				<p>
Adds the specified *KxJointDef* definition to this *LibKxJointDefs*, and returns it.
</p>
<p>
If this *LibKxJointDefs* already contains a *KxJointDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.AddNew">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=4363:4418#L134">AddNew</a></h3>
				<pre>func (me *LibKxJointDefs) AddNew(id string) *KxJointDef</pre>
				<p>
Creates a new *KxJointDef* definition with the specified *Id*, adds it to this *LibKxJointDefs*, and returns it.
</p>
<p>
If this *LibKxJointDefs* already contains a *KxJointDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.Len">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=4479:4514#L137">Len</a></h3>
				<pre>func (me *LibKxJointDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.New">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=4664:4722#L140">New</a></h3>
				<pre>func (me *LibKxJointDefs) New(id string) (def *KxJointDef)</pre>
				<p>
Creates a new *KxJointDef* definition with the specified *Id* and returns it, but does not add it to this *LibKxJointDefs*.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.Remove">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=4840:4883#L143">Remove</a></h3>
				<pre>func (me *LibKxJointDefs) Remove(id string)</pre>
				<p>
Removes the *KxJointDef* with the specified *Id* from this *LibKxJointDefs*.
</p>

				
				
			
				
				<h3 id="LibKxJointDefs.SyncChanges">func (*LibKxJointDefs) <a href="/target/kxjoint.gt.go?s=5223:5262#L148">SyncChanges</a></h3>
				<pre>func (me *LibKxJointDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibKxJointDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibKxJointDefs* library or its *KxJointDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxModelDefs">type <a href="/target/kxmodel.gt.go?s=3732:4000#L124">LibKxModelDefs</a></h2>
			<pre>type LibKxModelDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxModelDef
}</pre>
			<p>
A library that contains *KxModelDef*s associated by their *Id*. To create a new *LibKxModelDefs* library, ONLY
use the *LibsKxModelDef.New()* or *LibsKxModelDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxModelDefs.Add">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=4348:4408#L140">Add</a></h3>
				<pre>func (me *LibKxModelDefs) Add(d *KxModelDef) (n *KxModelDef)</pre>
				<p>
Adds the specified *KxModelDef* definition to this *LibKxModelDefs*, and returns it.
</p>
<p>
If this *LibKxModelDefs* already contains a *KxModelDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.AddNew">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=4736:4791#L151">AddNew</a></h3>
				<pre>func (me *LibKxModelDefs) AddNew(id string) *KxModelDef</pre>
				<p>
Creates a new *KxModelDef* definition with the specified *Id*, adds it to this *LibKxModelDefs*, and returns it.
</p>
<p>
If this *LibKxModelDefs* already contains a *KxModelDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.Len">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=4852:4887#L154">Len</a></h3>
				<pre>func (me *LibKxModelDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.New">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5037:5095#L157">New</a></h3>
				<pre>func (me *LibKxModelDefs) New(id string) (def *KxModelDef)</pre>
				<p>
Creates a new *KxModelDef* definition with the specified *Id* and returns it, but does not add it to this *LibKxModelDefs*.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.Remove">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5213:5256#L160">Remove</a></h3>
				<pre>func (me *LibKxModelDefs) Remove(id string)</pre>
				<p>
Removes the *KxModelDef* with the specified *Id* from this *LibKxModelDefs*.
</p>

				
				
			
				
				<h3 id="LibKxModelDefs.SyncChanges">func (*LibKxModelDefs) <a href="/target/kxmodel.gt.go?s=5596:5635#L165">SyncChanges</a></h3>
				<pre>func (me *LibKxModelDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibKxModelDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibKxModelDefs* library or its *KxModelDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibKxSceneDefs">type <a href="/target/kxscene.gt.go?s=3690:3958#L107">LibKxSceneDefs</a></h2>
			<pre>type LibKxSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*KxSceneDef
}</pre>
			<p>
A library that contains *KxSceneDef*s associated by their *Id*. To create a new *LibKxSceneDefs* library, ONLY
use the *LibsKxSceneDef.New()* or *LibsKxSceneDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibKxSceneDefs.Add">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=4306:4366#L123">Add</a></h3>
				<pre>func (me *LibKxSceneDefs) Add(d *KxSceneDef) (n *KxSceneDef)</pre>
				<p>
Adds the specified *KxSceneDef* definition to this *LibKxSceneDefs*, and returns it.
</p>
<p>
If this *LibKxSceneDefs* already contains a *KxSceneDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.AddNew">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=4694:4749#L134">AddNew</a></h3>
				<pre>func (me *LibKxSceneDefs) AddNew(id string) *KxSceneDef</pre>
				<p>
Creates a new *KxSceneDef* definition with the specified *Id*, adds it to this *LibKxSceneDefs*, and returns it.
</p>
<p>
If this *LibKxSceneDefs* already contains a *KxSceneDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.Len">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=4810:4845#L137">Len</a></h3>
				<pre>func (me *LibKxSceneDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.New">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=4995:5053#L140">New</a></h3>
				<pre>func (me *LibKxSceneDefs) New(id string) (def *KxSceneDef)</pre>
				<p>
Creates a new *KxSceneDef* definition with the specified *Id* and returns it, but does not add it to this *LibKxSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.Remove">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=5171:5214#L143">Remove</a></h3>
				<pre>func (me *LibKxSceneDefs) Remove(id string)</pre>
				<p>
Removes the *KxSceneDef* with the specified *Id* from this *LibKxSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibKxSceneDefs.SyncChanges">func (*LibKxSceneDefs) <a href="/target/kxscene.gt.go?s=5554:5593#L148">SyncChanges</a></h3>
				<pre>func (me *LibKxSceneDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibKxSceneDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibKxSceneDefs* library or its *KxSceneDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibLightDefs">type <a href="/target/light.gt.go?s=4956:5220#L158">LibLightDefs</a></h2>
			<pre>type LibLightDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*LightDef
}</pre>
			<p>
A library that contains *LightDef*s associated by their *Id*. To create a new *LibLightDefs* library, ONLY
use the *LibsLightDef.New()* or *LibsLightDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibLightDefs.Add">func (*LibLightDefs) <a href="/target/light.gt.go?s=5552:5606#L174">Add</a></h3>
				<pre>func (me *LibLightDefs) Add(d *LightDef) (n *LightDef)</pre>
				<p>
Adds the specified *LightDef* definition to this *LibLightDefs*, and returns it.
</p>
<p>
If this *LibLightDefs* already contains a *LightDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibLightDefs.AddNew">func (*LibLightDefs) <a href="/target/light.gt.go?s=5926:5977#L185">AddNew</a></h3>
				<pre>func (me *LibLightDefs) AddNew(id string) *LightDef</pre>
				<p>
Creates a new *LightDef* definition with the specified *Id*, adds it to this *LibLightDefs*, and returns it.
</p>
<p>
If this *LibLightDefs* already contains a *LightDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibLightDefs.Len">func (*LibLightDefs) <a href="/target/light.gt.go?s=6038:6071#L188">Len</a></h3>
				<pre>func (me *LibLightDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibLightDefs.New">func (*LibLightDefs) <a href="/target/light.gt.go?s=6217:6271#L191">New</a></h3>
				<pre>func (me *LibLightDefs) New(id string) (def *LightDef)</pre>
				<p>
Creates a new *LightDef* definition with the specified *Id* and returns it, but does not add it to this *LibLightDefs*.
</p>

				
				
			
				
				<h3 id="LibLightDefs.Remove">func (*LibLightDefs) <a href="/target/light.gt.go?s=6383:6424#L194">Remove</a></h3>
				<pre>func (me *LibLightDefs) Remove(id string)</pre>
				<p>
Removes the *LightDef* with the specified *Id* from this *LibLightDefs*.
</p>

				
				
			
				
				<h3 id="LibLightDefs.SyncChanges">func (*LibLightDefs) <a href="/target/light.gt.go?s=6758:6795#L199">SyncChanges</a></h3>
				<pre>func (me *LibLightDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibLightDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibLightDefs* library or its *LightDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibNodeDefs">type <a href="/target/node.gt.go?s=2943:3205#L103">LibNodeDefs</a></h2>
			<pre>type LibNodeDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*NodeDef
}</pre>
			<p>
A library that contains *NodeDef*s associated by their *Id*. To create a new *LibNodeDefs* library, ONLY
use the *LibsNodeDef.New()* or *LibsNodeDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibNodeDefs.Add">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3529:3580#L119">Add</a></h3>
				<pre>func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</pre>
				<p>
Adds the specified *NodeDef* definition to this *LibNodeDefs*, and returns it.
</p>
<p>
If this *LibNodeDefs* already contains a *NodeDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.AddNew">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3896:3945#L130">AddNew</a></h3>
				<pre>func (me *LibNodeDefs) AddNew(id string) *NodeDef</pre>
				<p>
Creates a new *NodeDef* definition with the specified *Id*, adds it to this *LibNodeDefs*, and returns it.
</p>
<p>
If this *LibNodeDefs* already contains a *NodeDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Len">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4006:4038#L133">Len</a></h3>
				<pre>func (me *LibNodeDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibNodeDefs.New">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4182:4234#L136">New</a></h3>
				<pre>func (me *LibNodeDefs) New(id string) (def *NodeDef)</pre>
				<p>
Creates a new *NodeDef* definition with the specified *Id* and returns it, but does not add it to this *LibNodeDefs*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Remove">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4343:4383#L139">Remove</a></h3>
				<pre>func (me *LibNodeDefs) Remove(id string)</pre>
				<p>
Removes the *NodeDef* with the specified *Id* from this *LibNodeDefs*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.SyncChanges">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4714:4750#L144">SyncChanges</a></h3>
				<pre>func (me *LibNodeDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibNodeDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibNodeDefs* library or its *NodeDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxForceFieldDefs">type <a href="/target/pxforcefield.gt.go?s=2341:2619#L74">LibPxForceFieldDefs</a></h2>
			<pre>type LibPxForceFieldDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxForceFieldDef
}</pre>
			<p>
A library that contains *PxForceFieldDef*s associated by their *Id*. To create a new *LibPxForceFieldDefs* library, ONLY
use the *LibsPxForceFieldDef.New()* or *LibsPxForceFieldDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxForceFieldDefs.Add">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=3007:3082#L90">Add</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Add(d *PxForceFieldDef) (n *PxForceFieldDef)</pre>
				<p>
Adds the specified *PxForceFieldDef* definition to this *LibPxForceFieldDefs*, and returns it.
</p>
<p>
If this *LibPxForceFieldDefs* already contains a *PxForceFieldDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.AddNew">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=3430:3495#L101">AddNew</a></h3>
				<pre>func (me *LibPxForceFieldDefs) AddNew(id string) *PxForceFieldDef</pre>
				<p>
Creates a new *PxForceFieldDef* definition with the specified *Id*, adds it to this *LibPxForceFieldDefs*, and returns it.
</p>
<p>
If this *LibPxForceFieldDefs* already contains a *PxForceFieldDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.Len">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=3556:3596#L104">Len</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.New">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=3756:3824#L107">New</a></h3>
				<pre>func (me *LibPxForceFieldDefs) New(id string) (def *PxForceFieldDef)</pre>
				<p>
Creates a new *PxForceFieldDef* definition with the specified *Id* and returns it, but does not add it to this *LibPxForceFieldDefs*.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.Remove">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=3957:4005#L110">Remove</a></h3>
				<pre>func (me *LibPxForceFieldDefs) Remove(id string)</pre>
				<p>
Removes the *PxForceFieldDef* with the specified *Id* from this *LibPxForceFieldDefs*.
</p>

				
				
			
				
				<h3 id="LibPxForceFieldDefs.SyncChanges">func (*LibPxForceFieldDefs) <a href="/target/pxforcefield.gt.go?s=4360:4404#L115">SyncChanges</a></h3>
				<pre>func (me *LibPxForceFieldDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibPxForceFieldDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibPxForceFieldDefs* library or its *PxForceFieldDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxMaterialDefs">type <a href="/target/pxmaterial.gt.go?s=2539:2813#L82">LibPxMaterialDefs</a></h2>
			<pre>type LibPxMaterialDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxMaterialDef
}</pre>
			<p>
A library that contains *PxMaterialDef*s associated by their *Id*. To create a new *LibPxMaterialDefs* library, ONLY
use the *LibsPxMaterialDef.New()* or *LibsPxMaterialDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxMaterialDefs.Add">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=3185:3254#L98">Add</a></h3>
				<pre>func (me *LibPxMaterialDefs) Add(d *PxMaterialDef) (n *PxMaterialDef)</pre>
				<p>
Adds the specified *PxMaterialDef* definition to this *LibPxMaterialDefs*, and returns it.
</p>
<p>
If this *LibPxMaterialDefs* already contains a *PxMaterialDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.AddNew">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=3594:3655#L109">AddNew</a></h3>
				<pre>func (me *LibPxMaterialDefs) AddNew(id string) *PxMaterialDef</pre>
				<p>
Creates a new *PxMaterialDef* definition with the specified *Id*, adds it to this *LibPxMaterialDefs*, and returns it.
</p>
<p>
If this *LibPxMaterialDefs* already contains a *PxMaterialDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.Len">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=3716:3754#L112">Len</a></h3>
				<pre>func (me *LibPxMaterialDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.New">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=3910:3974#L115">New</a></h3>
				<pre>func (me *LibPxMaterialDefs) New(id string) (def *PxMaterialDef)</pre>
				<p>
Creates a new *PxMaterialDef* definition with the specified *Id* and returns it, but does not add it to this *LibPxMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.Remove">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=4101:4147#L118">Remove</a></h3>
				<pre>func (me *LibPxMaterialDefs) Remove(id string)</pre>
				<p>
Removes the *PxMaterialDef* with the specified *Id* from this *LibPxMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibPxMaterialDefs.SyncChanges">func (*LibPxMaterialDefs) <a href="/target/pxmaterial.gt.go?s=4496:4538#L123">SyncChanges</a></h3>
				<pre>func (me *LibPxMaterialDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibPxMaterialDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibPxMaterialDefs* library or its *PxMaterialDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxModelDefs">type <a href="/target/pxmodel.gt.go?s=3457:3725#L86">LibPxModelDefs</a></h2>
			<pre>type LibPxModelDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxModelDef
}</pre>
			<p>
A library that contains *PxModelDef*s associated by their *Id*. To create a new *LibPxModelDefs* library, ONLY
use the *LibsPxModelDef.New()* or *LibsPxModelDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxModelDefs.Add">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=4073:4133#L102">Add</a></h3>
				<pre>func (me *LibPxModelDefs) Add(d *PxModelDef) (n *PxModelDef)</pre>
				<p>
Adds the specified *PxModelDef* definition to this *LibPxModelDefs*, and returns it.
</p>
<p>
If this *LibPxModelDefs* already contains a *PxModelDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.AddNew">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=4461:4516#L113">AddNew</a></h3>
				<pre>func (me *LibPxModelDefs) AddNew(id string) *PxModelDef</pre>
				<p>
Creates a new *PxModelDef* definition with the specified *Id*, adds it to this *LibPxModelDefs*, and returns it.
</p>
<p>
If this *LibPxModelDefs* already contains a *PxModelDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.Len">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=4577:4612#L116">Len</a></h3>
				<pre>func (me *LibPxModelDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.New">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=4762:4820#L119">New</a></h3>
				<pre>func (me *LibPxModelDefs) New(id string) (def *PxModelDef)</pre>
				<p>
Creates a new *PxModelDef* definition with the specified *Id* and returns it, but does not add it to this *LibPxModelDefs*.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.Remove">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=4938:4981#L122">Remove</a></h3>
				<pre>func (me *LibPxModelDefs) Remove(id string)</pre>
				<p>
Removes the *PxModelDef* with the specified *Id* from this *LibPxModelDefs*.
</p>

				
				
			
				
				<h3 id="LibPxModelDefs.SyncChanges">func (*LibPxModelDefs) <a href="/target/pxmodel.gt.go?s=5321:5360#L127">SyncChanges</a></h3>
				<pre>func (me *LibPxModelDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibPxModelDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibPxModelDefs* library or its *PxModelDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibPxSceneDefs">type <a href="/target/pxscene.gt.go?s=2735:3003#L84">LibPxSceneDefs</a></h2>
			<pre>type LibPxSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*PxSceneDef
}</pre>
			<p>
A library that contains *PxSceneDef*s associated by their *Id*. To create a new *LibPxSceneDefs* library, ONLY
use the *LibsPxSceneDef.New()* or *LibsPxSceneDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibPxSceneDefs.Add">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=3351:3411#L100">Add</a></h3>
				<pre>func (me *LibPxSceneDefs) Add(d *PxSceneDef) (n *PxSceneDef)</pre>
				<p>
Adds the specified *PxSceneDef* definition to this *LibPxSceneDefs*, and returns it.
</p>
<p>
If this *LibPxSceneDefs* already contains a *PxSceneDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.AddNew">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=3739:3794#L111">AddNew</a></h3>
				<pre>func (me *LibPxSceneDefs) AddNew(id string) *PxSceneDef</pre>
				<p>
Creates a new *PxSceneDef* definition with the specified *Id*, adds it to this *LibPxSceneDefs*, and returns it.
</p>
<p>
If this *LibPxSceneDefs* already contains a *PxSceneDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.Len">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=3855:3890#L114">Len</a></h3>
				<pre>func (me *LibPxSceneDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.New">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4040:4098#L117">New</a></h3>
				<pre>func (me *LibPxSceneDefs) New(id string) (def *PxSceneDef)</pre>
				<p>
Creates a new *PxSceneDef* definition with the specified *Id* and returns it, but does not add it to this *LibPxSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.Remove">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4216:4259#L120">Remove</a></h3>
				<pre>func (me *LibPxSceneDefs) Remove(id string)</pre>
				<p>
Removes the *PxSceneDef* with the specified *Id* from this *LibPxSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibPxSceneDefs.SyncChanges">func (*LibPxSceneDefs) <a href="/target/pxscene.gt.go?s=4599:4638#L125">SyncChanges</a></h3>
				<pre>func (me *LibPxSceneDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibPxSceneDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibPxSceneDefs* library or its *PxSceneDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibVisualSceneDefs">type <a href="/target/visualscene.gt.go?s=3952:4228#L124">LibVisualSceneDefs</a></h2>
			<pre>type LibVisualSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*VisualSceneDef
}</pre>
			<p>
A library that contains *VisualSceneDef*s associated by their *Id*. To create a new *LibVisualSceneDefs* library, ONLY
use the *LibsVisualSceneDef.New()* or *LibsVisualSceneDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibVisualSceneDefs.Add">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=4608:4680#L140">Add</a></h3>
				<pre>func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</pre>
				<p>
Adds the specified *VisualSceneDef* definition to this *LibVisualSceneDefs*, and returns it.
</p>
<p>
If this *LibVisualSceneDefs* already contains a *VisualSceneDef* definition with the same *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.AddNew">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=5024:5087#L151">AddNew</a></h3>
				<pre>func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</pre>
				<p>
Creates a new *VisualSceneDef* definition with the specified *Id*, adds it to this *LibVisualSceneDefs*, and returns it.
</p>
<p>
If this *LibVisualSceneDefs* already contains a *VisualSceneDef* definition with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Len">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=5148:5187#L154">Len</a></h3>
				<pre>func (me *LibVisualSceneDefs) Len() int</pre>
				<p>
Short-hand for len(lib.M)
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.New">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=5345:5411#L157">New</a></h3>
				<pre>func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</pre>
				<p>
Creates a new *VisualSceneDef* definition with the specified *Id* and returns it, but does not add it to this *LibVisualSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Remove">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=5541:5588#L160">Remove</a></h3>
				<pre>func (me *LibVisualSceneDefs) Remove(id string)</pre>
				<p>
Removes the *VisualSceneDef* with the specified *Id* from this *LibVisualSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.SyncChanges">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=5940:5983#L165">SyncChanges</a></h3>
				<pre>func (me *LibVisualSceneDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibVisualSceneDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibVisualSceneDefs* library or its *VisualSceneDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibsAnimationClipDef">type <a href="/target/animationclip.gt.go?s=1574:1632#L52">LibsAnimationClipDef</a></h2>
			<pre>type LibsAnimationClipDef map[string]*LibAnimationClipDefs</pre>
			<p>
The underlying type of the global *AllAnimationClipDefLibs* variable: a *map* collection that contains
*LibAnimationClipDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsAnimationClipDef.AddNew">func (LibsAnimationClipDef) <a href="/target/animationclip.gt.go?s=1908:1984#L57">AddNew</a></h3>
				<pre>func (me LibsAnimationClipDef) AddNew(id string) (lib *LibAnimationClipDefs)</pre>
				<p>
Creates a new *LibAnimationClipDefs* library with the specified *Id*, adds it to this *LibsAnimationClipDef*, and returns it.
</p>
<p>
If this *LibsAnimationClipDef* already contains a *LibAnimationClipDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsAnimationDef">type <a href="/target/animation.gt.go?s=3195:3245#L110">LibsAnimationDef</a></h2>
			<pre>type LibsAnimationDef map[string]*LibAnimationDefs</pre>
			<p>
The underlying type of the global *AllAnimationDefLibs* variable: a *map* collection that contains
*LibAnimationDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsAnimationDef.AddNew">func (LibsAnimationDef) <a href="/target/animation.gt.go?s=3505:3573#L115">AddNew</a></h3>
				<pre>func (me LibsAnimationDef) AddNew(id string) (lib *LibAnimationDefs)</pre>
				<p>
Creates a new *LibAnimationDefs* library with the specified *Id*, adds it to this *LibsAnimationDef*, and returns it.
</p>
<p>
If this *LibsAnimationDef* already contains a *LibAnimationDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsCameraDef">type <a href="/target/camera.gt.go?s=2758:2802#L99">LibsCameraDef</a></h2>
			<pre>type LibsCameraDef map[string]*LibCameraDefs</pre>
			<p>
The underlying type of the global *AllCameraDefLibs* variable: a *map* collection that contains
*LibCameraDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsCameraDef.AddNew">func (LibsCameraDef) <a href="/target/camera.gt.go?s=3050:3112#L104">AddNew</a></h3>
				<pre>func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</pre>
				<p>
Creates a new *LibCameraDefs* library with the specified *Id*, adds it to this *LibsCameraDef*, and returns it.
</p>
<p>
If this *LibsCameraDef* already contains a *LibCameraDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsControllerDef">type <a href="/target/controller.gt.go?s=3636:3688#L111">LibsControllerDef</a></h2>
			<pre>type LibsControllerDef map[string]*LibControllerDefs</pre>
			<p>
The underlying type of the global *AllControllerDefLibs* variable: a *map* collection that contains
*LibControllerDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsControllerDef.AddNew">func (LibsControllerDef) <a href="/target/controller.gt.go?s=3952:4022#L116">AddNew</a></h3>
				<pre>func (me LibsControllerDef) AddNew(id string) (lib *LibControllerDefs)</pre>
				<p>
Creates a new *LibControllerDefs* library with the specified *Id*, adds it to this *LibsControllerDef*, and returns it.
</p>
<p>
If this *LibsControllerDef* already contains a *LibControllerDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsFormulaDef">type <a href="/target/formula.gt.go?s=2040:2086#L78">LibsFormulaDef</a></h2>
			<pre>type LibsFormulaDef map[string]*LibFormulaDefs</pre>
			<p>
The underlying type of the global *AllFormulaDefLibs* variable: a *map* collection that contains
*LibFormulaDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsFormulaDef.AddNew">func (LibsFormulaDef) <a href="/target/formula.gt.go?s=2338:2402#L83">AddNew</a></h3>
				<pre>func (me LibsFormulaDef) AddNew(id string) (lib *LibFormulaDefs)</pre>
				<p>
Creates a new *LibFormulaDefs* library with the specified *Id*, adds it to this *LibsFormulaDef*, and returns it.
</p>
<p>
If this *LibsFormulaDef* already contains a *LibFormulaDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxEffectDef">type <a href="/target/fxeffect.gt.go?s=15563:15611#L418">LibsFxEffectDef</a></h2>
			<pre>type LibsFxEffectDef map[string]*LibFxEffectDefs</pre>
			<p>
The underlying type of the global *AllFxEffectDefLibs* variable: a *map* collection that contains
*LibFxEffectDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxEffectDef.AddNew">func (LibsFxEffectDef) <a href="/target/fxeffect.gt.go?s=15867:15933#L423">AddNew</a></h3>
				<pre>func (me LibsFxEffectDef) AddNew(id string) (lib *LibFxEffectDefs)</pre>
				<p>
Creates a new *LibFxEffectDefs* library with the specified *Id*, adds it to this *LibsFxEffectDef*, and returns it.
</p>
<p>
If this *LibsFxEffectDef* already contains a *LibFxEffectDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxImageDef">type <a href="/target/fximage.gt.go?s=11855:11901#L281">LibsFxImageDef</a></h2>
			<pre>type LibsFxImageDef map[string]*LibFxImageDefs</pre>
			<p>
The underlying type of the global *AllFxImageDefLibs* variable: a *map* collection that contains
*LibFxImageDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxImageDef.AddNew">func (LibsFxImageDef) <a href="/target/fximage.gt.go?s=12153:12217#L286">AddNew</a></h3>
				<pre>func (me LibsFxImageDef) AddNew(id string) (lib *LibFxImageDefs)</pre>
				<p>
Creates a new *LibFxImageDefs* library with the specified *Id*, adds it to this *LibsFxImageDef*, and returns it.
</p>
<p>
If this *LibsFxImageDef* already contains a *LibFxImageDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsFxMaterialDef">type <a href="/target/fxmaterial.gt.go?s=2368:2420#L76">LibsFxMaterialDef</a></h2>
			<pre>type LibsFxMaterialDef map[string]*LibFxMaterialDefs</pre>
			<p>
The underlying type of the global *AllFxMaterialDefLibs* variable: a *map* collection that contains
*LibFxMaterialDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsFxMaterialDef.AddNew">func (LibsFxMaterialDef) <a href="/target/fxmaterial.gt.go?s=2684:2754#L81">AddNew</a></h3>
				<pre>func (me LibsFxMaterialDef) AddNew(id string) (lib *LibFxMaterialDefs)</pre>
				<p>
Creates a new *LibFxMaterialDefs* library with the specified *Id*, adds it to this *LibsFxMaterialDef*, and returns it.
</p>
<p>
If this *LibsFxMaterialDef* already contains a *LibFxMaterialDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsGeometryDef">type <a href="/target/geometry.gt.go?s=2330:2378#L111">LibsGeometryDef</a></h2>
			<pre>type LibsGeometryDef map[string]*LibGeometryDefs</pre>
			<p>
The underlying type of the global *AllGeometryDefLibs* variable: a *map* collection that contains
*LibGeometryDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsGeometryDef.AddNew">func (LibsGeometryDef) <a href="/target/geometry.gt.go?s=2634:2700#L116">AddNew</a></h3>
				<pre>func (me LibsGeometryDef) AddNew(id string) (lib *LibGeometryDefs)</pre>
				<p>
Creates a new *LibGeometryDefs* library with the specified *Id*, adds it to this *LibsGeometryDef*, and returns it.
</p>
<p>
If this *LibsGeometryDef* already contains a *LibGeometryDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxArticulatedSystemDef">type <a href="/target/kxarticulatedsystem.gt.go?s=5023:5093#L183">LibsKxArticulatedSystemDef</a></h2>
			<pre>type LibsKxArticulatedSystemDef map[string]*LibKxArticulatedSystemDefs</pre>
			<p>
The underlying type of the global *AllKxArticulatedSystemDefLibs* variable: a *map* collection that contains
*LibKxArticulatedSystemDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxArticulatedSystemDef.AddNew">func (LibsKxArticulatedSystemDef) <a href="/target/kxarticulatedsystem.gt.go?s=5393:5481#L188">AddNew</a></h3>
				<pre>func (me LibsKxArticulatedSystemDef) AddNew(id string) (lib *LibKxArticulatedSystemDefs)</pre>
				<p>
Creates a new *LibKxArticulatedSystemDefs* library with the specified *Id*, adds it to this *LibsKxArticulatedSystemDef*, and returns it.
</p>
<p>
If this *LibsKxArticulatedSystemDef* already contains a *LibKxArticulatedSystemDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxJointDef">type <a href="/target/kxjoint.gt.go?s=2629:2675#L86">LibsKxJointDef</a></h2>
			<pre>type LibsKxJointDef map[string]*LibKxJointDefs</pre>
			<p>
The underlying type of the global *AllKxJointDefLibs* variable: a *map* collection that contains
*LibKxJointDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxJointDef.AddNew">func (LibsKxJointDef) <a href="/target/kxjoint.gt.go?s=2927:2991#L91">AddNew</a></h3>
				<pre>func (me LibsKxJointDef) AddNew(id string) (lib *LibKxJointDefs)</pre>
				<p>
Creates a new *LibKxJointDefs* library with the specified *Id*, adds it to this *LibsKxJointDef*, and returns it.
</p>
<p>
If this *LibsKxJointDef* already contains a *LibKxJointDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxModelDef">type <a href="/target/kxmodel.gt.go?s=3002:3048#L103">LibsKxModelDef</a></h2>
			<pre>type LibsKxModelDef map[string]*LibKxModelDefs</pre>
			<p>
The underlying type of the global *AllKxModelDefLibs* variable: a *map* collection that contains
*LibKxModelDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxModelDef.AddNew">func (LibsKxModelDef) <a href="/target/kxmodel.gt.go?s=3300:3364#L108">AddNew</a></h3>
				<pre>func (me LibsKxModelDef) AddNew(id string) (lib *LibKxModelDefs)</pre>
				<p>
Creates a new *LibKxModelDefs* library with the specified *Id*, adds it to this *LibsKxModelDef*, and returns it.
</p>
<p>
If this *LibsKxModelDef* already contains a *LibKxModelDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsKxSceneDef">type <a href="/target/kxscene.gt.go?s=2960:3006#L86">LibsKxSceneDef</a></h2>
			<pre>type LibsKxSceneDef map[string]*LibKxSceneDefs</pre>
			<p>
The underlying type of the global *AllKxSceneDefLibs* variable: a *map* collection that contains
*LibKxSceneDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsKxSceneDef.AddNew">func (LibsKxSceneDef) <a href="/target/kxscene.gt.go?s=3258:3322#L91">AddNew</a></h3>
				<pre>func (me LibsKxSceneDef) AddNew(id string) (lib *LibKxSceneDefs)</pre>
				<p>
Creates a new *LibKxSceneDefs* library with the specified *Id*, adds it to this *LibsKxSceneDef*, and returns it.
</p>
<p>
If this *LibsKxSceneDef* already contains a *LibKxSceneDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsLightDef">type <a href="/target/light.gt.go?s=4256:4298#L137">LibsLightDef</a></h2>
			<pre>type LibsLightDef map[string]*LibLightDefs</pre>
			<p>
The underlying type of the global *AllLightDefLibs* variable: a *map* collection that contains
*LibLightDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsLightDef.AddNew">func (LibsLightDef) <a href="/target/light.gt.go?s=4542:4602#L142">AddNew</a></h3>
				<pre>func (me LibsLightDef) AddNew(id string) (lib *LibLightDefs)</pre>
				<p>
Creates a new *LibLightDefs* library with the specified *Id*, adds it to this *LibsLightDef*, and returns it.
</p>
<p>
If this *LibsLightDef* already contains a *LibLightDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsNodeDef">type <a href="/target/node.gt.go?s=2258:2298#L82">LibsNodeDef</a></h2>
			<pre>type LibsNodeDef map[string]*LibNodeDefs</pre>
			<p>
The underlying type of the global *AllNodeDefLibs* variable: a *map* collection that contains
*LibNodeDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsNodeDef.AddNew">func (LibsNodeDef) <a href="/target/node.gt.go?s=2538:2596#L87">AddNew</a></h3>
				<pre>func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</pre>
				<p>
Creates a new *LibNodeDefs* library with the specified *Id*, adds it to this *LibsNodeDef*, and returns it.
</p>
<p>
If this *LibsNodeDef* already contains a *LibNodeDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxForceFieldDef">type <a href="/target/pxforcefield.gt.go?s=1536:1592#L53">LibsPxForceFieldDef</a></h2>
			<pre>type LibsPxForceFieldDef map[string]*LibPxForceFieldDefs</pre>
			<p>
The underlying type of the global *AllPxForceFieldDefLibs* variable: a *map* collection that contains
*LibPxForceFieldDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxForceFieldDef.AddNew">func (LibsPxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=1864:1938#L58">AddNew</a></h3>
				<pre>func (me LibsPxForceFieldDef) AddNew(id string) (lib *LibPxForceFieldDefs)</pre>
				<p>
Creates a new *LibPxForceFieldDefs* library with the specified *Id*, adds it to this *LibsPxForceFieldDef*, and returns it.
</p>
<p>
If this *LibsPxForceFieldDef* already contains a *LibPxForceFieldDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxMaterialDef">type <a href="/target/pxmaterial.gt.go?s=1764:1816#L61">LibsPxMaterialDef</a></h2>
			<pre>type LibsPxMaterialDef map[string]*LibPxMaterialDefs</pre>
			<p>
The underlying type of the global *AllPxMaterialDefLibs* variable: a *map* collection that contains
*LibPxMaterialDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxMaterialDef.AddNew">func (LibsPxMaterialDef) <a href="/target/pxmaterial.gt.go?s=2080:2150#L66">AddNew</a></h3>
				<pre>func (me LibsPxMaterialDef) AddNew(id string) (lib *LibPxMaterialDefs)</pre>
				<p>
Creates a new *LibPxMaterialDefs* library with the specified *Id*, adds it to this *LibsPxMaterialDef*, and returns it.
</p>
<p>
If this *LibsPxMaterialDef* already contains a *LibPxMaterialDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxModelDef">type <a href="/target/pxmodel.gt.go?s=2727:2773#L65">LibsPxModelDef</a></h2>
			<pre>type LibsPxModelDef map[string]*LibPxModelDefs</pre>
			<p>
The underlying type of the global *AllPxModelDefLibs* variable: a *map* collection that contains
*LibPxModelDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxModelDef.AddNew">func (LibsPxModelDef) <a href="/target/pxmodel.gt.go?s=3025:3089#L70">AddNew</a></h3>
				<pre>func (me LibsPxModelDef) AddNew(id string) (lib *LibPxModelDefs)</pre>
				<p>
Creates a new *LibPxModelDefs* library with the specified *Id*, adds it to this *LibsPxModelDef*, and returns it.
</p>
<p>
If this *LibsPxModelDef* already contains a *LibPxModelDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsPxSceneDef">type <a href="/target/pxscene.gt.go?s=2005:2051#L63">LibsPxSceneDef</a></h2>
			<pre>type LibsPxSceneDef map[string]*LibPxSceneDefs</pre>
			<p>
The underlying type of the global *AllPxSceneDefLibs* variable: a *map* collection that contains
*LibPxSceneDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsPxSceneDef.AddNew">func (LibsPxSceneDef) <a href="/target/pxscene.gt.go?s=2303:2367#L68">AddNew</a></h3>
				<pre>func (me LibsPxSceneDef) AddNew(id string) (lib *LibPxSceneDefs)</pre>
				<p>
Creates a new *LibPxSceneDefs* library with the specified *Id*, adds it to this *LibsPxSceneDef*, and returns it.
</p>
<p>
If this *LibsPxSceneDef* already contains a *LibPxSceneDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsVisualSceneDef">type <a href="/target/visualscene.gt.go?s=3162:3216#L103">LibsVisualSceneDef</a></h2>
			<pre>type LibsVisualSceneDef map[string]*LibVisualSceneDefs</pre>
			<p>
The underlying type of the global *AllVisualSceneDefLibs* variable: a *map* collection that contains
*LibVisualSceneDefs* libraries associated by their *Id*.
</p>


			

			

			

			

			
				
				<h3 id="LibsVisualSceneDef.AddNew">func (LibsVisualSceneDef) <a href="/target/visualscene.gt.go?s=3484:3556#L108">AddNew</a></h3>
				<pre>func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</pre>
				<p>
Creates a new *LibVisualSceneDefs* library with the specified *Id*, adds it to this *LibsVisualSceneDef*, and returns it.
</p>
<p>
If this *LibsVisualSceneDef* already contains a *LibVisualSceneDefs* library with the specified *Id*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LightAmbient">type <a href="/target/light.gt.go?s=148:197#L1">LightAmbient</a></h2>
			<pre>type LightAmbient struct {
    <span class="comment">//	Color</span>
    LightBase
}</pre>
			<p>
Describes an ambient light source. An ambient light is one that lights everything evenly, regardless of location or orientation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightAttenuation">type <a href="/target/light.gt.go?s=263:470#L1">LightAttenuation</a></h2>
			<pre>type LightAttenuation struct {
    <span class="comment">//	Constant light attenuation. Defaults to 1.</span>
    Constant ScopedFloat
    <span class="comment">//	Linear light attenuation.</span>
    Linear ScopedFloat
    <span class="comment">//	Quadratic light attenuation.</span>
    Quadratic ScopedFloat
}</pre>
			<p>
Describes how the intensity of a light source is attenuated.
</p>


			

			

			

			
				
				<h3 id="NewLightAttenuation">func <a href="/target/light.gt.go?s=487:536#L10">NewLightAttenuation</a></h3>
				<pre>func NewLightAttenuation() (me *LightAttenuation)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="LightBase">type <a href="/target/light.gt.go?s=669:777#L17">LightBase</a></h2>
			<pre>type LightBase struct {
    <span class="comment">//	Three floating-point numbers specifying the color of this light.</span>
    Color Float3
}</pre>
			<p>
Contains three floating-point numbers specifying the color of a light.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightDef">type <a href="/target/light.gt.go?s=2692:3182#L68">LightDef</a></h2>
			<pre>type LightDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile. At least and at most one of its fields should ever be set.</span>
    TC struct {
        <span class="comment">//	If set, this light declares an ambient light.</span>
        Ambient *LightAmbient
        <span class="comment">//	If set, this light declares a directional light.</span>
        Directional *LightDirectional
        <span class="comment">//	If set, this light declares a point light.</span>
        Point *LightPoint
        <span class="comment">//	If set, this light declares a spot light.</span>
        Spot *LightSpot
    }
}</pre>
			<p>
Declares a light source that illuminates a scene.
</p>


			

			

			

			

			
				
				<h3 id="LightDef.Init">func (*LightDef) <a href="/target/light.gt.go?s=3202:3228#L87">Init</a></h3>
				<pre>func (me *LightDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="LightDirectional">type <a href="/target/light.gt.go?s=1137:1190#L24">LightDirectional</a></h2>
			<pre>type LightDirectional struct {
    <span class="comment">//	Color</span>
    LightBase
}</pre>
			<p>
Describes a directional light source. A directional light is one that lights everything from the same direction, regardless of location.
The light’s default direction vector in local coordinates is [0,0,-1], pointing down the negative z axis. The actual direction of the light is defined by the transform of the node where the light is instantiated.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LightInst">type <a href="/target/light.gt.go?s=3268:3333#L91">LightInst</a></h2>
			<pre>type LightInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates a light resource.
</p>


			

			

			

			

			
				
				<h3 id="LightInst.Init">func (*LightInst) <a href="/target/light.gt.go?s=3353:3380#L97">Init</a></h3>
				<pre>func (me *LightInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="LightPoint">type <a href="/target/light.gt.go?s=1408:1588#L30">LightPoint</a></h2>
			<pre>type LightPoint struct {
    <span class="comment">//	Color</span>
    LightBase
    <span class="comment">//	The intensity of a point light source is attenuated as the distance to the light source increases.</span>
    Attenuation LightAttenuation
}</pre>
			<p>
Describes a point light source. A point light source radiates light in all directions from a known location in space. The position of the light is defined by the transform of the node in which it is instantiated.
</p>


			

			

			

			
				
				<h3 id="NewLightPoint">func <a href="/target/light.gt.go?s=1605:1642#L38">NewLightPoint</a></h3>
				<pre>func NewLightPoint() (me *LightPoint)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="LightSpot">type <a href="/target/light.gt.go?s=2059:2497#L45">LightSpot</a></h2>
			<pre>type LightSpot struct {
    <span class="comment">//	Color</span>
    LightBase
    <span class="comment">//	 The intensity of a spot light source is also attenuated as the distance to the light source increases.</span>
    Attenuation LightAttenuation
    <span class="comment">//	The intensity of the light is also attenuated as the radiation angle increases away from the direction of the light source.</span>
    Falloff struct {
        <span class="comment">//	Fall-off angle. Defaults to 180.</span>
        Angle ScopedFloat
        <span class="comment">//	Fall-off exponent.</span>
        Exponent ScopedFloat
    }
}</pre>
			<p>
Describes a spot light source. A spot light source radiates light in one direction in a cone shape from a known location in space. The light’s default direction vector in local coordinates is [0,0,-1], pointing down the negative z axis. The actual direction of the light is defined by the transform of the node in which the light is instantiated.
</p>


			

			

			

			
				
				<h3 id="NewLightSpot">func <a href="/target/light.gt.go?s=2514:2549#L60">NewLightSpot</a></h3>
				<pre>func NewLightSpot() (me *LightSpot)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="MaterialBinding">type <a href="/target/common.go?s=7337:7672#L193">MaterialBinding</a></h2>
			<pre>type MaterialBinding struct {
    <span class="comment">//	Custom-technique/foreign-profile meta-data.</span>
    HasExtras
    <span class="comment">//	Custom-technique/foreign-profile data.</span>
    HasTechniques
    <span class="comment">//	Targets for animation</span>
    Params []*Param
    <span class="comment">//	Common-technique profile.</span>
    TC struct {
        <span class="comment">//	References to the materials included in this material binding.</span>
        Materials []*FxMaterialInst
    }
}</pre>
			<p>
Binds a specific material to a piece of geometry, binding varying and uniform parameters at the same time.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshData">type <a href="/target/meshdata.go?s=1164:1387#L40">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">//	Vertex positions</span>
    Positions []MeshVertAtt3
    <span class="comment">//	Vertex texture coordinates</span>
    TexCoords []MeshVertAtt2
    <span class="comment">//	Vertex normals</span>
    Normals []MeshVertAtt3
    <span class="comment">//	Indexed triangle definitions</span>
    Faces []MeshFace3
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="NewMeshData">func <a href="/target/meshdata.go?s=1443:1476#L52">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
				
				<h3 id="MeshData.AddFaces">func (*MeshData) <a href="/target/meshdata.go?s=1554:1602#L58">AddFaces</a></h3>
				<pre>func (me *MeshData) AddFaces(faces ...MeshFace3)</pre>
				<p>
Adds all specified Faces to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddNormals">func (*MeshData) <a href="/target/meshdata.go?s=1865:1920#L68">AddNormals</a></h3>
				<pre>func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</pre>
				<p>
Adds all the specified Normals to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddPositions">func (*MeshData) <a href="/target/meshdata.go?s=1697:1756#L63">AddPositions</a></h3>
				<pre>func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</pre>
				<p>
Adds all specified Positions to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddTexCoords">func (*MeshData) <a href="/target/meshdata.go?s=2025:2084#L73">AddTexCoords</a></h3>
				<pre>func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</pre>
				<p>
Adds all the specified TexCoords to this MeshData.
</p>

				
				
			
		
			
			
			<h2 id="MeshFace3">type <a href="/target/meshdata.go?s=140:166#L1">MeshFace3</a></h2>
			<pre>type MeshFace3 [3]MeshVert</pre>
			<p>
Represents an indexed triangle.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/meshdata.go?s=41:103#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Temporary concoction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRaw">type <a href="/target/meshdata.go?s=255:400#L1">MeshRaw</a></h2>
			<pre>type MeshRaw struct {
    <span class="comment">//	Raw vertices</span>
    MeshVerts []float32
    <span class="comment">//	Vertex indices</span>
    Indices []uint32
    <span class="comment">//	Raw face definitions</span>
    Faces []*MeshRawFace
}</pre>
			<p>
Represents semi-processed loaded mesh data &#34;almost ready&#34; to core.Mesh.GpuUpload().
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRawFace">type <a href="/target/meshdata.go?s=450:532#L10">MeshRawFace</a></h2>
			<pre>type MeshRawFace struct {
    <span class="comment">//	Indices of the triangle corners</span>
    Entries [3]uint32
}</pre>
			<p>
Represents a triangle face inside a MeshRaw.
</p>


			

			

			

			
				
				<h3 id="NewMeshRawFace">func <a href="/target/meshdata.go?s=591:630#L16">NewMeshRawFace</a></h3>
				<pre>func NewMeshRawFace() (me *MeshRawFace)</pre>
				<p>
Initializes and returns a new *MeshRawFace* instance.
</p>

				
			

			
		
			
			
			<h2 id="MeshVert">type <a href="/target/meshdata.go?s=698:885#L22">MeshVert</a></h2>
			<pre>type MeshVert struct {
    <span class="comment">//	Index of the vertex position</span>
    PosIndex uint32

    <span class="comment">//	Index of the texture-coordinate.</span>
    TexCoordIndex uint32

    <span class="comment">//	Index of the vertex normal.</span>
    NormalIndex uint32
}</pre>
			<p>
Represents an indexed vertex.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt2">type <a href="/target/meshdata.go?s=974:1002#L34">MeshVertAtt2</a></h2>
			<pre>type MeshVertAtt2 [2]float32</pre>
			<p>
Represents a 2-component vertex attribute (such as for example texture-coordinates)
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt3">type <a href="/target/meshdata.go?s=1086:1114#L37">MeshVertAtt3</a></h2>
			<pre>type MeshVertAtt3 [3]float32</pre>
			<p>
Represents a 3-component vertex attribute (such as for example vertex-normals)
</p>


			

			

			

			

			
		
			
			
			<h2 id="NodeDef">type <a href="/target/node.gt.go?s=295:1027#L2">NodeDef</a></h2>
			<pre>type NodeDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Indicates whether this node is a joint for a skin controller.</span>
    IsSkinJoint bool
    <span class="comment">//	The names of the layers to which this node belongs.</span>
    Layers Layers
    <span class="comment">//	Any combination of zero or more transformations of any type.</span>
    Transforms []*Transform
    <span class="comment">//	Content resources participating in this node.</span>
    Insts struct {
        <span class="comment">//	Cameras participating in this node.</span>
        Camera []*CameraInst
        <span class="comment">//	Controllers participating in this node.</span>
        Controller []*ControllerInst
        <span class="comment">//	Geometries participating in this node.</span>
        Geometry []*GeometryInst
        <span class="comment">//	Lights participating in this node.</span>
        Light []*LightInst
    }
    <span class="comment">//	Child nodes to recursively define a hierarchy.</span>
    Nodes []ChildNode
}</pre>
			<p>
Declares a point of interest in a scene.
</p>


			

			

			

			

			
				
				<h3 id="NodeDef.Init">func (*NodeDef) <a href="/target/node.gt.go?s=1047:1072#L29">Init</a></h3>
				<pre>func (me *NodeDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="NodeInst">type <a href="/target/node.gt.go?s=1133:1355#L34">NodeInst</a></h2>
			<pre>type NodeInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	Optional. The mechanism and use of this attribute is application-defined. For example, it can be used for bounding boxes or level of detail.</span>
    Proxy RefId
}</pre>
			<p>
Instantiates a node resource.
</p>


			

			

			

			

			
				
				<h3 id="NodeInst.Init">func (*NodeInst) <a href="/target/node.gt.go?s=1375:1401#L42">Init</a></h3>
				<pre>func (me *NodeInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="Param">type <a href="/target/common.go?s=7734:7987#L208">Param</a></h2>
			<pre>type Param struct {
    <span class="comment">//	Pretty-print name/title</span>
    HasName
    <span class="comment">//	Scoped identifier</span>
    HasSid
    <span class="comment">//	The user-defined meaning of the parameter.</span>
    Semantic string
    <span class="comment">//	The type of the value data. This text string must be understood by the application.</span>
    Type string
}</pre>
			<p>
Declares parametric information for its parent resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamBool">type <a href="/target/types.go?s=1330:1491#L64">ParamBool</a></h2>
			<pre>type ParamBool struct {
    <span class="comment">//	The value provided if Ref is empty.</span>
    B bool
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Ref RefParam
}</pre>
			<p>
Provides a bool value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamDef">type <a href="/target/common.go?s=8075:8185#L220">ParamDef</a></h2>
			<pre>type ParamDef struct {
    <span class="comment">//	Scoped identifier</span>
    HasSid
    <span class="comment">//	Initial value for this parameter</span>
    Value interface{}
}</pre>
			<p>
Declares a new parameter for its parent resource, and assigns it an initial value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamDefs">type <a href="/target/common.go?s=8255:8290#L228">ParamDefs</a></h2>
			<pre>type ParamDefs map[string]*ParamDef</pre>
			<p>
A hash-table containing parameter declarations of this resource.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamFloat">type <a href="/target/types.go?s=1522:1687#L72">ParamFloat</a></h2>
			<pre>type ParamFloat struct {
    <span class="comment">//	The value provided if Ref is empty.</span>
    F float64
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Ref RefParam
}</pre>
			<p>
Provides a float64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamFloat2">type <a href="/target/types.go?s=1721:1888#L80">ParamFloat2</a></h2>
			<pre>type ParamFloat2 struct {
    <span class="comment">//	The values provided if Ref is empty.</span>
    F Float2
    <span class="comment">//	If set, refers to a previously defined parameter providing the values.</span>
    Ref RefParam
}</pre>
			<p>
Provides two float64 values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamInst">type <a href="/target/common.go?s=8350:8670#L231">ParamInst</a></h2>
			<pre>type ParamInst struct {
    <span class="comment">//	References the identifier of the pre-defined parameter (ParamDef) that will have its value set.</span>
    Ref string
    <span class="comment">//	Indicates if the Value is a string referencing the identifier of a connected parameter.</span>
    IsConnectParamRef bool
    <span class="comment">//	The new value for the referenced parameter.</span>
    Value interface{}
}</pre>
			<p>
Assigns a new value to a previously defined parameter.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamInt">type <a href="/target/types.go?s=1917:2078#L88">ParamInt</a></h2>
			<pre>type ParamInt struct {
    <span class="comment">//	The value provided if Ref is empty.</span>
    I int64
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Ref RefParam
}</pre>
			<p>
Provides a int64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamScopedFloat">type <a href="/target/types.go?s=2116:2291#L96">ParamScopedFloat</a></h2>
			<pre>type ParamScopedFloat struct {
    <span class="comment">//	The value provided if Ref is empty.</span>
    F ScopedFloat
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Ref RefParam
}</pre>
			<p>
Provides a scoped float64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamSidRef">type <a href="/target/types.go?s=2321:2487#L104">ParamSidRef</a></h2>
			<pre>type ParamSidRef struct {
    <span class="comment">//	The value provided if Ref is empty.</span>
    Sr RefSid
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Ref RefParam
}</pre>
			<p>
Provides a RefSid value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ParamUint">type <a href="/target/types.go?s=2517:2680#L112">ParamUint</a></h2>
			<pre>type ParamUint struct {
    <span class="comment">//	The value provided if Ref is empty.</span>
    U uint64
    <span class="comment">//	If set, refers to a previously defined parameter providing the value.</span>
    Ref RefParam
}</pre>
			<p>
Provides a uint64 value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxCylinder">type <a href="/target/pxrigidbody.go?s=178:358#L1">PxCylinder</a></h2>
			<pre>type PxCylinder struct {
    <span class="comment">//	Radius, Extras</span>
    GeometryBrepCylinder
    <span class="comment">//	Contains a floating-point value that represents the length of the cylinder along the y axis.</span>
    Height float64
}</pre>
			<p>
Declares a cylinder primitive that is centered around its local origin and aligned along its local y axis.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxForceFieldDef">type <a href="/target/pxforcefield.gt.go?s=204:302#L1">PxForceFieldDef</a></h2>
			<pre>type PxForceFieldDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
}</pre>
			<p>
Provides a general container for force fields.
Force fields affect physical objects, such as rigid bodies, and may be instantiated under a physics scene or a physics model instance.
</p>


			

			

			

			

			
				
				<h3 id="PxForceFieldDef.Init">func (*PxForceFieldDef) <a href="/target/pxforcefield.gt.go?s=322:355#L3">Init</a></h3>
				<pre>func (me *PxForceFieldDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxForceFieldInst">type <a href="/target/pxforcefield.gt.go?s=401:473#L7">PxForceFieldInst</a></h2>
			<pre>type PxForceFieldInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates a force field resource.
</p>


			

			

			

			

			
				
				<h3 id="PxForceFieldInst.Init">func (*PxForceFieldInst) <a href="/target/pxforcefield.gt.go?s=493:527#L13">Init</a></h3>
				<pre>func (me *PxForceFieldInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxMaterial">type <a href="/target/pxrigidbody.go?s=512:683#L7">PxMaterial</a></h2>
			<pre>type PxMaterial struct {
    <span class="comment">//	An inline physics material definition.</span>
    Def *PxMaterialDef
    <span class="comment">//	Instantiation of a previously defined physics material.</span>
    Inst *PxMaterialInst
}</pre>
			<p>
Describes the physical surface properties for a rigid body or one of its shapes.
Either Def or Inst (or none), but not both, should be specified.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxMaterialDef">type <a href="/target/pxmaterial.gt.go?s=65:522#L1">PxMaterialDef</a></h2>
			<pre>type PxMaterialDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	The dynamic friction coefficient.</span>
        DynamicFriction ScopedFloat
        <span class="comment">//	The proportion of the kinetic energy preserved in the impact (typically ranges from 0.0 to 1.0). Also known as “bounciness” or “elasticity.”</span>
        Restitution ScopedFloat
        <span class="comment">//	The static friction coefficient.</span>
        StaticFriction ScopedFloat
    }
}</pre>
			<p>
Defines the physical properties of an object.
</p>


			

			

			

			

			
				
				<h3 id="PxMaterialDef.Init">func (*PxMaterialDef) <a href="/target/pxmaterial.gt.go?s=542:573#L11">Init</a></h3>
				<pre>func (me *PxMaterialDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxMaterialInst">type <a href="/target/pxmaterial.gt.go?s=671:741#L15">PxMaterialInst</a></h2>
			<pre>type PxMaterialInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Lets a shape specify its surface properties using a previously defined physics material.
</p>


			

			

			

			

			
				
				<h3 id="PxMaterialInst.Init">func (*PxMaterialInst) <a href="/target/pxmaterial.gt.go?s=761:793#L21">Init</a></h3>
				<pre>func (me *PxMaterialInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxModelDef">type <a href="/target/pxmodel.gt.go?s=133:544#L1">PxModelDef</a></h2>
			<pre>type PxModelDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Contains zero or more rigid bodies participating in this physics model.</span>
    RigidBodies []*PxRigidBodyDef
    <span class="comment">//	Contains zero or more rigid constraints participating in this physics model.</span>
    RigidConstraints []*PxRigidConstraintDef
    <span class="comment">//	Child physics models participating in this physics model, with optional property overrides.</span>
    Insts []*PxModelInst
}</pre>
			<p>
Allows for building complex combinations of rigid bodies and constraints that may be instantiated multiple times.
</p>


			

			

			

			

			
				
				<h3 id="PxModelDef.Init">func (*PxModelDef) <a href="/target/pxmodel.gt.go?s=564:592#L6">Init</a></h3>
				<pre>func (me *PxModelDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxModelInst">type <a href="/target/pxmodel.gt.go?s=709:1764#L10">PxModelInst</a></h2>
			<pre>type PxModelInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	Points to the Id of a node in the visual scene. This allows a physics model to be instantiated under a specific transform node, which will dictate the initial position and orientation, and could be animated to influence kinematic rigid bodies. Optional.</span>
    <span class="comment">//	By default, the physics model is instantiated under the world, rather than a specific transform node. This parameter is only meaningful when the parent element of the current physics model is a physics scene.</span>
    Parent RefId
    <span class="comment">//	Zero or more force fields influencing this physics model.</span>
    ForceFields []*PxForceFieldInst
    <span class="comment">//	Contains instances of those rigid bodies included in the instantiated physics model that should have some properties overridden, or should be linked with transform nodes in the visual scene.</span>
    RigidBodies []*PxRigidBodyInst
    <span class="comment">//	Contains instances of those rigid constraints included in the instantiated physics model that should have some properties overridden.</span>
    RigidConstraints []*PxRigidConstraintInst
}</pre>
			<p>
Embeds a physics model inside another physics model or instantiates a physics model within a physics scene.
</p>


			

			

			

			

			
				
				<h3 id="PxModelInst.Init">func (*PxModelInst) <a href="/target/pxmodel.gt.go?s=1784:1813#L25">Init</a></h3>
				<pre>func (me *PxModelInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidBodyCommon">type <a href="/target/pxrigidbody.go?s=1896:2786#L46">PxRigidBodyCommon</a></h2>
			<pre>type PxRigidBodyCommon struct {
    <span class="comment">//	Specifies whether this rigid body is movable. Defaults to true.</span>
    Dynamic ScopedBool
    <span class="comment">//	If set, specifies the total mass of this rigid body.</span>
    Mass *ScopedFloat
    <span class="comment">//	Zero or more TRANSFORM_TYPE_TRANSLATE and/or TRANSFORM_TYPE_ROTATE transformations defining the center and orientation of mass of the rigid-body relative to the local origin of the “root” shape.</span>
    <span class="comment">//	This makes the off-diagonal elements of the inertia tensor (products of inertia) all 0 and allows us to just store the diagonal elements (moments of inertia).</span>
    MassFrame []*Transform
    <span class="comment">//	The diagonal elements of the inertia tensor (moments of inertia), represented in the local frame of the center of mass.</span>
    Inertia *ScopedFloat3
    <span class="comment">//	Describes the physical surface properties for this rigid body.</span>
    Material PxMaterial
    <span class="comment">//	Zero or more shapes for collision detection.</span>
    Shapes []*PxShape
}</pre>
			<p>
Common-technique profile for rigid body definitions and instances.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidBodyDef">type <a href="/target/pxrigidbody.go?s=2788:3005#L62">PxRigidBodyDef</a></h2>
			<pre>type PxRigidBodyDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Common-technique profile: Dynamic, Mass, MassFrame, Inertia, Material, Shapes</span>
    TC PxRigidBodyCommon
}</pre>
			

			

			

			

			

			
				
				<h3 id="PxRigidBodyDef.Init">func (*PxRigidBodyDef) <a href="/target/pxrigidbody.go?s=3025:3057#L74">Init</a></h3>
				<pre>func (me *PxRigidBodyDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidBodyInst">type <a href="/target/pxrigidbody.go?s=3126:3663#L79">PxRigidBodyInst</a></h2>
			<pre>type PxRigidBodyInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Refers to the NodeDef influenced by this rigid body instance.</span>
    TargetNode RefId
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Dynamic, Mass, MassFrame, Inertia, Material, Shapes</span>
        PxRigidBodyCommon
        <span class="comment">//	Initial spin or angular velocity, also known as the axis of rotation, with a magnitude equal to the rate of rotation in radians per second.</span>
        AngularVelocity unum.Vec3
        <span class="comment">//	Initial linear velocity.</span>
        LinearVelocity unum.Vec3
    }
}</pre>
			<p>
Instantiates a rigid-body resource.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidBodyInst.Init">func (*PxRigidBodyInst) <a href="/target/pxrigidbody.go?s=3683:3716#L98">Init</a></h3>
				<pre>func (me *PxRigidBodyInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintAttachment">type <a href="/target/pxrigidconstraint.go?s=137:594#L1">PxRigidConstraintAttachment</a></h2>
			<pre>type PxRigidConstraintAttachment struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Refers to a RigidBodyDef or NodeDef.</span>
    RigidBody RefSid
    <span class="comment">//	Zero or more translation and/or rotation transformations:</span>
    <span class="comment">//	The position of a TRANSFORM_TYPE_TRANSLATE Transform indicates the attachment point on the corresponding RigidBodyDef.</span>
    <span class="comment">//	The orientation of a TRANSFORM_TYPE_ROTATE Transform indicates the alignment of the joint frame for that RigidBodyDef.</span>
    Transforms []*Transform
}</pre>
			<p>
Defines an attachment frame (or attachment frame of reference), to a rigid body or a node, within a rigid constraint.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidConstraintDef">type <a href="/target/pxrigidconstraint.go?s=1371:2530#L31">PxRigidConstraintDef</a></h2>
			<pre>type PxRigidConstraintDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Defines the attachment frame of reference (to a rigid_body or a node) within this rigid constraint.</span>
    RefAttachment PxRigidConstraintAttachment
    <span class="comment">//	Defines an attachment frame (to a rigid body or a node) within this rigid constraint.</span>
    Attachment PxRigidConstraintAttachment
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Defaults to true. If false, this rigid constraint doesn’t exert any force or influence on the rigid bodies.</span>
        Enabled ScopedBool
        <span class="comment">//	If true, the attached rigid bodies may interpenetrate.</span>
        Interpenetrate ScopedBool
        <span class="comment">//	Degrees of freedom and ranges.</span>
        Limits struct {
            <span class="comment">//	Describes the angular limits along each rotation axis in degrees.</span>
            Angular *PxRigidConstraintLimit
            <span class="comment">//	Describes linear (translational) limits along each axis.</span>
            Linear *PxRigidConstraintLimit
        }
        <span class="comment">//	Spring is based based on either distance (Linear) or angle (Angular), or both.</span>
        Spring struct {
            <span class="comment">//	Angle-based spring.</span>
            Angular *PxRigidConstraintSpring
            <span class="comment">//	Distance-based spring.</span>
            Linear *PxRigidConstraintSpring
        }
    }
}</pre>
			<p>
Constrains rigid bodies to each other or to the world.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidConstraintDef.Init">func (*PxRigidConstraintDef) <a href="/target/pxrigidconstraint.go?s=2550:2588#L66">Init</a></h3>
				<pre>func (me *PxRigidConstraintDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintInst">type <a href="/target/pxrigidconstraint.go?s=2663:2740#L71">PxRigidConstraintInst</a></h2>
			<pre>type PxRigidConstraintInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates a rigid constraint resource.
</p>


			

			

			

			

			
				
				<h3 id="PxRigidConstraintInst.Init">func (*PxRigidConstraintInst) <a href="/target/pxrigidconstraint.go?s=2760:2799#L77">Init</a></h3>
				<pre>func (me *PxRigidConstraintInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxRigidConstraintLimit">type <a href="/target/pxrigidconstraint.go?s=630:802#L6">PxRigidConstraintLimit</a></h2>
			<pre>type PxRigidConstraintLimit struct {
    <span class="comment">//	Lower bounds for this limit across all 3 axes.</span>
    Min ScopedVec3
    <span class="comment">//	Upper bounds for this limit across all 3 axes.</span>
    Max ScopedVec3
}</pre>
			<p>
Degrees of freedom and ranges.
</p>


			

			

			

			

			
		
			
			
			<h2 id="PxRigidConstraintSpring">type <a href="/target/pxrigidconstraint.go?s=886:1166#L14">PxRigidConstraintSpring</a></h2>
			<pre>type PxRigidConstraintSpring struct {
    <span class="comment">//	Also called spring coefficient. Has units of force/distance (for Linear) or force/angle (for Angular).</span>
    Stiffness ScopedFloat
    <span class="comment">//	How this spring is damped.</span>
    Damping ScopedFloat
    <span class="comment">//	Target value for this spring.</span>
    TargetValue ScopedFloat
}</pre>
			<p>
Spring is based based on either distance (Linear) or angle (Angular), or both.
</p>


			

			

			

			
				
				<h3 id="NewPxRigidConstraintSpring">func <a href="/target/pxrigidconstraint.go?s=1183:1246#L24">NewPxRigidConstraintSpring</a></h3>
				<pre>func NewPxRigidConstraintSpring() (me *PxRigidConstraintSpring)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="PxSceneDef">type <a href="/target/pxscene.gt.go?s=102:879#L1">PxSceneDef</a></h2>
			<pre>type PxSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	Force fields influencing this physics scene.</span>
    ForceFields []*PxForceFieldInst
    <span class="comment">//	Refers to the rigid bodies and constraints participating in this scene.</span>
    Models []*PxModelInst
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	If set, a vector representation of this physics scene’s gravity force field. It is given as a denormalized direction vector of three floating-point values that indicate both the magnitude and direction of acceleration caused by the field.</span>
        Gravity *ScopedVec3
        <span class="comment">//	If set, the integration time step, measured in seconds, of the physics scene. This value is engine-specific. If omitted, the physics engine’s default is used.</span>
        TimeStep *ScopedFloat
    }
}</pre>
			<p>
Specifies an environment in which physical objects are instantiated and simulated.
</p>


			

			

			

			

			
				
				<h3 id="PxSceneDef.Init">func (*PxSceneDef) <a href="/target/pxscene.gt.go?s=899:927#L13">Init</a></h3>
				<pre>func (me *PxSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxSceneInst">type <a href="/target/pxscene.gt.go?s=975:1042#L17">PxSceneInst</a></h2>
			<pre>type PxSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates a physics scene resource.
</p>


			

			

			

			

			
				
				<h3 id="PxSceneInst.Init">func (*PxSceneInst) <a href="/target/pxscene.gt.go?s=1062:1091#L23">Init</a></h3>
				<pre>func (me *PxSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="PxShape">type <a href="/target/pxrigidbody.go?s=778:1824#L15">PxShape</a></h2>
			<pre>type PxShape struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	If true, the mass is distributed along the surface of this shape.</span>
    Hollow ScopedBool
    <span class="comment">//	The mass of this shape.</span>
    Mass *ScopedFloat
    <span class="comment">//	The density of this shape.</span>
    Density *ScopedFloat
    <span class="comment">//	Describes the physical surface properties for this shape.</span>
    Material PxMaterial
    <span class="comment">//	Geometry of the shape. At least and at most one of its fields should ever be set.</span>
    Geometry struct {
        <span class="comment">//	A flat plane.</span>
        Plane *GeometryBrepPlane
        <span class="comment">//	Axis-aligned box.</span>
        Box *GeometryBrepBox
        <span class="comment">//	A perfectly round sphere.</span>
        Sphere *GeometryBrepSphere
        <span class="comment">//	A cylinder primitive that is centered around its local origin and aligned along its local y axis.</span>
        Cylinder *PxCylinder
        <span class="comment">//	A capsule primitive that is centered on the local origin and aligned along the y axis.</span>
        Capsule *GeometryBrepCapsule
        <span class="comment">//	Refers to a previously defined mesh or spline geometric primitive.</span>
        Inst *GeometryInst
    }
    <span class="comment">//	Zero or more TRANSFORM_TYPE_ROTATE and/or TRANSFORM_TYPE_TRANSLATE transformations for the shape.</span>
    Transforms []*Transform
}</pre>
			<p>
A component part of a rigid body&#39;s collection of bounding shapes for collision detection.
</p>


			

			

			

			

			
		
			
			
			<h2 id="RefId">type <a href="/target/common.go?s=8728:8745#L241">RefId</a></h2>
			<pre>type RefId string</pre>
			<p>
References a resource by its unique identifier (Id).
</p>


			

			

			

			

			
				
				<h3 id="RefId.S">func (RefId) <a href="/target/common.go?s=8777:8803#L244">S</a></h3>
				<pre>func (me RefId) S() string</pre>
				<p>
Returns its current value.
</p>

				
				
			
				
				<h3 id="RefId.Set">func (*RefId) <a href="/target/common.go?s=8859:8889#L249">Set</a></h3>
				<pre>func (me *RefId) Set(v string)</pre>
				<p>
Modifies its current value.
</p>

				
				
			
		
			
			
			<h2 id="RefParam">type <a href="/target/common.go?s=8957:8977#L254">RefParam</a></h2>
			<pre>type RefParam RefSid</pre>
			<p>
References a previously defined parameter.
</p>


			

			

			

			

			
				
				<h3 id="RefParam.S">func (RefParam) <a href="/target/common.go?s=9009:9038#L257">S</a></h3>
				<pre>func (me RefParam) S() string</pre>
				<p>
Returns its current value.
</p>

				
				
			
				
				<h3 id="RefParam.Set">func (*RefParam) <a href="/target/common.go?s=9094:9127#L262">Set</a></h3>
				<pre>func (me *RefParam) Set(v string)</pre>
				<p>
Modifies its current value.
</p>

				
				
			
		
			
			
			<h2 id="RefSid">type <a href="/target/common.go?s=9209:9227#L267">RefSid</a></h2>
			<pre>type RefSid string</pre>
			<p>
References a resource by its scoped identifier (Sid).
</p>


			

			

			

			

			
				
				<h3 id="RefSid.S">func (RefSid) <a href="/target/common.go?s=9259:9286#L270">S</a></h3>
				<pre>func (me RefSid) S() string</pre>
				<p>
Returns its current value.
</p>

				
				
			
				
				<h3 id="RefSid.Set">func (*RefSid) <a href="/target/common.go?s=9342:9373#L275">Set</a></h3>
				<pre>func (me *RefSid) Set(v string)</pre>
				<p>
Modifies its current value.
</p>

				
				
			
		
			
			
			<h2 id="Scene">type <a href="/target/common.go?s=9477:9894#L280">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Embodies the entire set of information that can be visualized from the contents of a resource.</span>
    Visual *VisualSceneInst
    <span class="comment">//	Embodies the entire set of information that can be articulated kinematically from the contents of a resource.</span>
    Kinematics *KxSceneInst
    <span class="comment">//	Specifies an environment in which physical objects are instantiated and simulated.</span>
    Physics []*PxSceneInst
}</pre>
			<p>
Declares a complete, self-contained base of a scene hierarchy or scene graph.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ScopedBool">type <a href="/target/types.go?s=2728:2793#L120">ScopedBool</a></h2>
			<pre>type ScopedBool struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The value.</span>
    B bool
}</pre>
			<p>
A bool value that has a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ScopedFloat">type <a href="/target/types.go?s=2844:2913#L128">ScopedFloat</a></h2>
			<pre>type ScopedFloat struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The value.</span>
    F float64
}</pre>
			<p>
A float64 value that has a scoped identifier.
</p>


			

			

			

			
				
				<h3 id="Scopedf">func <a href="/target/assets.go?s=1165:1205#L28">Scopedf</a></h3>
				<pre>func Scopedf(f float64) (sf ScopedFloat)</pre>
				<p>
Returns a ScopedFloat with the specified value and no Sid.
</p>

				
			

			
		
			
			
			<h2 id="ScopedFloat3">type <a href="/target/types.go?s=2970:3040#L136">ScopedFloat3</a></h2>
			<pre>type ScopedFloat3 struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The values.</span>
    F Float3
}</pre>
			<p>
Three float64 values that have a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ScopedString">type <a href="/target/types.go?s=3090:3159#L144">ScopedString</a></h2>
			<pre>type ScopedString struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The value.</span>
    S string
}</pre>
			<p>
A string value that has a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ScopedVec3">type <a href="/target/types.go?s=3206:3277#L152">ScopedVec3</a></h2>
			<pre>type ScopedVec3 struct {
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	The vector.</span>
    V unum.Vec3
}</pre>
			<p>
A 3D vector that has a scoped identifier.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Source">type <a href="/target/source.go?s=1094:2155#L18">Source</a></h2>
			<pre>type Source struct {
    <span class="comment">//	Id</span>
    HasId
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Asset</span>
    HasAsset
    <span class="comment">//	Techniques</span>
    HasTechniques
    <span class="comment">//	The data array of this Source. Of all the []slice fields in this struct, only one should ever be non-empty at any time.</span>
    Array struct {
        <span class="comment">//	Id</span>
        HasId
        <span class="comment">//	Name</span>
        HasName
        <span class="comment">//	A slice into the array of bools that this Source represents, if any.</span>
        Bools []bool
        <span class="comment">//	A slice into the array of floats that this Source represents, if any.</span>
        Floats []float64
        <span class="comment">//	A slice into the array of RefIds that this Source represents, if any.</span>
        IdRefs []string
        <span class="comment">//	A slice into the array of ints that this Source represents, if any.</span>
        Ints []int64
        <span class="comment">//	A slice into the array of names that this Source represents, if any.</span>
        Names []string
        <span class="comment">//	A slice into the array of RefSids that this Source represents, if any.</span>
        SidRefs []string
        <span class="comment">//	A slice into the array of tokens that this Source represents, if any.</span>
        Tokens []string
    }
    <span class="comment">//	Common-technique profile</span>
    TC struct {
        <span class="comment">//	Describes a stream of values from this array data source.</span>
        Accessor *SourceAccessor
    }
}</pre>
			<p>
Declares a data repository that provides values according to the semantics of an Input that refers to it.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SourceAccessor">type <a href="/target/source.go?s=75:831#L1">SourceAccessor</a></h2>
			<pre>type SourceAccessor struct {
    <span class="comment">//	The number of times the array is accessed. Required.</span>
    Count uint64
    <span class="comment">//	The index of the first value to be read from the array. The default is 0. Optional.</span>
    Offset uint64
    <span class="comment">//	The *Id* of the array to access. Required.</span>
    Source RefId
    <span class="comment">//	The number of values that are to be considered a unit during each access to the array.</span>
    <span class="comment">//	The default is 1, indicating that a single value is accessed. Optional.</span>
    Stride uint64
    <span class="comment">//	The number and order of Params define the output of the accessor. Parameters</span>
    <span class="comment">//	are bound to values in the order in which both are specified. No reordering of the data can occur. A</span>
    <span class="comment">//	Param without a Name indicates that the value is not part of the output, so the Param</span>
    <span class="comment">//	is unbound.</span>
    Params []*Param
}</pre>
			<p>
Describes a stream of values from an array data source.
</p>


			

			

			

			
				
				<h3 id="NewSourceAccessor">func <a href="/target/source.go?s=893:938#L12">NewSourceAccessor</a></h3>
				<pre>func NewSourceAccessor() (me *SourceAccessor)</pre>
				<p>
Allocates, initializes and returns a new SourceAccessor.
</p>

				
			

			
		
			
			
			<h2 id="Sources">type <a href="/target/source.go?s=2209:2240#L56">Sources</a></h2>
			<pre>type Sources map[string]*Source</pre>
			<p>
A hash-table of Sources, each keyed with its Id.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Technique">type <a href="/target/common.go?s=10003:10253#L292">Technique</a></h2>
			<pre>type Technique struct {
    <span class="comment">//	The type of profile. This is a vendor-defined character string that indicates the platform or capability target for the technique.</span>
    Profile string
    <span class="comment">//	Arbitrary content or meta-data for this Technique.</span>
    Data []*xmlx.Node
}</pre>
			<p>
Declares platform-specific or program-specific information used to process some portion of the content.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Transform">type <a href="/target/common.go?s=10313:11174#L300">Transform</a></h2>
			<pre>type Transform struct {
    <span class="comment">//	Scoped identifier</span>
    HasSid
    <span class="comment">//	The type of this transformation (rotation, skewing, scaling, translation, &#34;look-at&#34;, or matrix).</span>
    <span class="comment">//	The only valid values are the TRANSFORM_TYPE_* enumerated constants.</span>
    Type int
    <span class="comment">//	Contains one or more vectors and values representing this transformation.</span>
    <span class="comment">//	If type is &#34;look-at&#34;, contains 9 values representing 3 vectors (eye position, interest point, up-axis).</span>
    <span class="comment">//	If type is matrix, contains 16 values representing a column-major 4x4 matrix.</span>
    <span class="comment">//	If type is skew, contains 7 values: one angle in degrees, then 2 vectors specifying the axes of rotation and translation.</span>
    <span class="comment">//	If type is rotate, contains 4 values: one vector specifying the axis of rotation, then 1 value for the angle in degrees.</span>
    <span class="comment">//	If type is translate or scale, contains 3 values representing a single column vector.</span>
    F []float64
}</pre>
			<p>
Represents a single transformation of a specific kind.
</p>


			

			

			

			

			
		
			
			
			<h2 id="VisualSceneDef">type <a href="/target/visualscene.gt.go?s=1702:1949#L43">VisualSceneDef</a></h2>
			<pre>type VisualSceneDef struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	A scene graph containing nodes of visual information and related data.</span>
    Nodes []*NodeDef
    <span class="comment">//	Specifies how to evaluate this visual scene.</span>
    Evaluations []*VisualSceneEvaluation
}</pre>
			<p>
Embodies the entire set of information that can be visualized from the contents of a resource.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneDef.Init">func (*VisualSceneDef) <a href="/target/visualscene.gt.go?s=1969:2001#L53">Init</a></h3>
				<pre>func (me *VisualSceneDef) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneEvaluation">type <a href="/target/visualscene.gt.go?s=83:359#L1">VisualSceneEvaluation</a></h2>
			<pre>type VisualSceneEvaluation struct {
    <span class="comment">//	Id, Name, Asset, Extras</span>
    BaseDef
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Whether evaluation is enabled. Disabling evaluation can be useful for debugging.</span>
    Disabled bool
    <span class="comment">//	Describes effects passes to render a scene.</span>
    RenderPasses []*VisualSceneRendering
}</pre>
			<p>
Declares information specifying how to evaluate a visual scene.
</p>


			

			

			

			

			
		
			
			
			<h2 id="VisualSceneInst">type <a href="/target/visualscene.gt.go?s=2048:2119#L57">VisualSceneInst</a></h2>
			<pre>type VisualSceneInst struct {
    <span class="comment">//	Sid, Name, Extras, DefRef</span>
    BaseInst
}</pre>
			<p>
Instantiates a visual scene resource.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneInst.Init">func (*VisualSceneInst) <a href="/target/visualscene.gt.go?s=2139:2172#L63">Init</a></h3>
				<pre>func (me *VisualSceneInst) Init()</pre>
				<p>
Initialization
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneRendering">type <a href="/target/visualscene.gt.go?s=411:905#L6">VisualSceneRendering</a></h2>
			<pre>type VisualSceneRendering struct {
    <span class="comment">//	Name</span>
    HasName
    <span class="comment">//	Sid</span>
    HasSid
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Refers to a node that contains a camera describing the viewpoint from which to render this compositing step. Optional.</span>
    CameraNode string
    <span class="comment">//	Specifies which layer or layers to render in this compositing step while evaluating the scene.</span>
    Layers Layers
    <span class="comment">//	If set, specifies which effect to render in this compositing step while evaluating the scene.</span>
    MaterialInst *VisualSceneRenderingMaterialInst
}</pre>
			<p>
Describes one effect pass to evaluate a scene.
</p>


			

			

			

			
				
				<h3 id="NewVisualSceneRendering">func <a href="/target/visualscene.gt.go?s=922:979#L22">NewVisualSceneRendering</a></h3>
				<pre>func NewVisualSceneRendering() (me *VisualSceneRendering)</pre>
				<p>
Constructor
</p>

				
			

			
		
			
			
			<h2 id="VisualSceneRenderingMaterialInst">type <a href="/target/visualscene.gt.go?s=1096:1602#L28">VisualSceneRenderingMaterialInst</a></h2>
			<pre>type VisualSceneRenderingMaterialInst struct {
    <span class="comment">//	Extras</span>
    HasExtras
    <span class="comment">//	Binds values to effect parameters upon instantiation.</span>
    Bindings []*FxBinding
    <span class="comment">//	Target specific techniques and passes inside a material rather than having to split the effects techniques and passes into multiple effects.</span>
    OverrideTechnique struct {
        <span class="comment">//	Specifies the Sid of a Technique</span>
        Ref RefSid
        <span class="comment">//	Specifies the Sid of one FxPass to execute. If not specified, then all of the Technique’s passes are used.</span>
        Pass RefSid
    }
}</pre>
			<p>
Instantiates a material resource for a screen effect.
</p>


			

			

			

			

			
		
		</div>
	

	







	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="collada/">collada</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>
	


		</div></div>
	</body>
</html>