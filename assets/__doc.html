<html>
	<head>
		<title>Package github.com/go3d/go-ngine/assets</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/assets</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/assets"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *assets* package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.
</p>
<p>
________
</p>
<p>
First off, the go:ngine 3 RULES of bugless(er) development:
</p>
<p>
1. you do NOT set exported fields directly, those are provided for simplified read-access. If a field is
meant to be modifiable, there will be a *SetFoo()* method or it will be documented explicitly as directly
modifiable, but such instances will be rare.
</p>
<p>
2. you do NOT instantiate exported struct types directly, as in &#34;new(ImageDef)&#34; or &#34;&amp;ImageDef {}&#34;. Many of
those are exported only for documentation, but are to be instantiated only inside the go:ngine package.
For types to be instantiated by package-external code (ie. your code), go:ngine packages provide constructor
functions -- often in collections, ie. img := ImageDefs.New(&#34;id&#34;) instead of, say, img := NewImageDef(&#34;id&#34;).
</p>
<p>
3. Those 2 are *default* assumptions and modes of operation -- there are a few &#34;if you know what you&#39;re
doing&#34; exemptions and those are (or will be) explicitly documented as such.
</p>
<p>
________
</p>
<p>
The *assets* package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.
These data structures only describe resource definitions and instances, but do not provide
any specific logic or algorithms, such as physics or visual rendering.
</p>
<p>
Context: any go:ngine app uses a variety of both simple and complex resource types, including for
example geometry definitions, image textures, material and light descriptions and many others.
</p>
<p>
While for all these resource types, the go:ngine *core* package manages their respective run-time
representation in its entirety,	some basic part of that representation is &#34;merely descriptive&#34; and
should be readable from or writable to a binary stream (&#34;design-time&#34;). That &#34;merely descriptive&#34;
sub-set of resource definitions is fully contained in this go:ngine *assets* package and thus decoupled
from the go:ngine *core* package.
</p>
<p>
This *assets* package thus allows for things such as server-side procedural asset generators, networked
resource streaming or simple custom asset-import/export/conversion tools, all of which shouldn&#39;t have to
needlessly depend on the graphics, windowing etc. stacks.
</p>
<p>
NOTE: there are essentially TWO distinct &#34;modes&#34; or use-cases in which the *assets* package is active:
</p>
<p>
1. in graphics-independent, server-side or non-interactive &#34;toolage&#34;, dealing only with the raw resource
data where it can be generated, loaded, stored, manipulated at will with no particular repercussions.
</p>
<p>
2. in an interactive graphical go:ngine app that also has the *core* package loaded:
</p>
<p>
All &#34;Sync&#34;-related functions pertain to use-case #2, where the *assets* package essentially becomes the
live repository for all resource definitions loaded, used, or manipulated by the *core* package at runtime.
So now every image definition in *assets* may have a corresponding GPU-bound texture object in *core*, every
*assets* mesh definition may be bound to a *core* *MeshBuffer*, etc.
</p>
<p>
Structure: generally speaking, all resource types are organized in a consistent fashion as follows ---
users familiar with the COLLADA format will notice a stark resemblance in terminology and resource organization:
</p>
<p>
1. First, there is a *FooDef* struct for the one-time definition of a unique resource:
GeometryMeshDef, ImageDef, LightDef, MaterialDef etc.
</p>
<p>
2. Next, there is a smaller *FooInst* struct for handling many individual (sometimes parameterized) instances of
an *FooDef*: GeometryMeshInst, ImageInst, LightInst, MaterialInst etc.
</p>
<p>
3. Finally, there is a light-weight *LibFooDefs* struct type (based on a *map* collection) containing Defs
associated with their ID: LibGeometryMeshDefs, LibImageDefs, LibLightDefs, LibMaterialDefs etc.
</p>
<p>
4. The package also provides a pre-initialized global *FooDefs* variable for each such Lib type, in simple apps
considered the &#34;default / main / only Lib you&#39;ll need&#34;: GeometryMeshDefs, ImageDefs, LightDefs, MaterialDefs etc.
</p>
<p>
5. For more complex use-cases, you can also organize multiple libs for any given resource type in the global
*AllFooDefLibs* variable, essentially a *map* collection of Libs: AllGeometryMeshDefLibs (of type
LibsGeometryMeshDef), AllImageDefLibs (of type LibsImageDef), AllLightDefLibs (of type LibsLightDef),
AllMaterialDefLibs (of type LibsMaterialDef) etc.
</p>
<p>
Any exported types in this package not following the above pattern (such as MeshData etc.) should be
considered &#34;auxiliary helpers&#34; rather than primary / &#34;first-class&#34; resource types.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#SyncChanges">func SyncChanges()</a></dd>
			
			
				
				<dd><a href="#AnimationChannel">type AnimationChannel</a></dd>
				
				
			
				
				<dd><a href="#AnimationClipDef">type AnimationClipDef</a></dd>
				
				
			
				
				<dd><a href="#AnimationDef">type AnimationDef</a></dd>
				
				
			
				
				<dd><a href="#AnimationInst">type AnimationInst</a></dd>
				
				
			
				
				<dd><a href="#AnimationSampler">type AnimationSampler</a></dd>
				
				
			
				
				<dd><a href="#Asset">type Asset</a></dd>
				
				
			
				
				<dd><a href="#Base">type Base</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SetDirty">func (me *Base) SetDirty()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SetFieldB">func (me *Base) SetFieldB(field *bool, val bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SetFieldF">func (me *Base) SetFieldF(field *float64, val float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SyncChanges">func (me *Base) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#BaseDef">type BaseDef</a></dd>
				
				
			
				
				<dd><a href="#BaseInst">type BaseInst</a></dd>
				
				
			
				
				<dd><a href="#BaseLib">type BaseLib</a></dd>
				
				
			
				
				<dd><a href="#Bool2">type Bool2</a></dd>
				
				
			
				
				<dd><a href="#Bool3">type Bool3</a></dd>
				
				
			
				
				<dd><a href="#Bool4">type Bool4</a></dd>
				
				
			
				
				<dd><a href="#CameraDef">type CameraDef</a></dd>
				
				
			
				
				<dd><a href="#CameraInst">type CameraInst</a></dd>
				
				
			
				
				<dd><a href="#Contributor">type Contributor</a></dd>
				
				
			
				
				<dd><a href="#ControllerDef">type ControllerDef</a></dd>
				
				
			
				
				<dd><a href="#ControllerInst">type ControllerInst</a></dd>
				
				
			
				
				<dd><a href="#ControllerMorph">type ControllerMorph</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerMorph">func NewControllerMorph() (me *ControllerMorph)</a></dd>
				
				
			
				
				<dd><a href="#ControllerSkin">type ControllerSkin</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewControllerSkin">func NewControllerSkin() (me *ControllerSkin)</a></dd>
				
				
			
				
				<dd><a href="#EffectDef">type EffectDef</a></dd>
				
				
			
				
				<dd><a href="#EffectInst">type EffectInst</a></dd>
				
				
			
				
				<dd><a href="#Extra">type Extra</a></dd>
				
				
			
				
				<dd><a href="#Float2">type Float2</a></dd>
				
				
			
				
				<dd><a href="#Float2x2">type Float2x2</a></dd>
				
				
			
				
				<dd><a href="#Float2x3">type Float2x3</a></dd>
				
				
			
				
				<dd><a href="#Float2x4">type Float2x4</a></dd>
				
				
			
				
				<dd><a href="#Float3">type Float3</a></dd>
				
				
			
				
				<dd><a href="#Float3x2">type Float3x2</a></dd>
				
				
			
				
				<dd><a href="#Float3x3">type Float3x3</a></dd>
				
				
			
				
				<dd><a href="#Float3x4">type Float3x4</a></dd>
				
				
			
				
				<dd><a href="#Float4">type Float4</a></dd>
				
				
			
				
				<dd><a href="#Float4x2">type Float4x2</a></dd>
				
				
			
				
				<dd><a href="#Float4x3">type Float4x3</a></dd>
				
				
			
				
				<dd><a href="#Float4x4">type Float4x4</a></dd>
				
				
			
				
				<dd><a href="#Float7">type Float7</a></dd>
				
				
			
				
				<dd><a href="#FormulaDef">type FormulaDef</a></dd>
				
				
			
				
				<dd><a href="#FormulaInst">type FormulaInst</a></dd>
				
				
			
				
				<dd><a href="#FxAnnotation">type FxAnnotation</a></dd>
				
				
			
				
				<dd><a href="#FxParamDef">type FxParamDef</a></dd>
				
				
			
				
				<dd><a href="#FxParamDefs">type FxParamDefs</a></dd>
				
				
			
				
				<dd><a href="#FxSampler">type FxSampler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFxSampler">func NewFxSampler() (me *FxSampler)</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerFiltering">type FxSamplerFiltering</a></dd>
				
				
			
				
				<dd><a href="#FxSamplerWrapping">type FxSamplerWrapping</a></dd>
				
				
			
				
				<dd><a href="#GeographicLocation">type GeographicLocation</a></dd>
				
				
			
				
				<dd><a href="#GeometryBrep">type GeometryBrep</a></dd>
				
				
			
				
				<dd><a href="#GeometryDef">type GeometryDef</a></dd>
				
				
			
				
				<dd><a href="#GeometryInst">type GeometryInst</a></dd>
				
				
			
				
				<dd><a href="#GeometryMesh">type GeometryMesh</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometryMesh">func NewGeometryMesh() (me *GeometryMesh)</a></dd>
				
				
			
				
				<dd><a href="#GeometryPrimitives">type GeometryPrimitives</a></dd>
				
				
			
				
				<dd><a href="#GeometrySpline">type GeometrySpline</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGeometrySpline">func NewGeometrySpline() (me *GeometrySpline)</a></dd>
				
				
			
				
				<dd><a href="#GeometryVertices">type GeometryVertices</a></dd>
				
				
			
				
				<dd><a href="#HasAsset">type HasAsset</a></dd>
				
				
			
				
				<dd><a href="#HasExtras">type HasExtras</a></dd>
				
				
			
				
				<dd><a href="#HasID">type HasID</a></dd>
				
				
			
				
				<dd><a href="#HasName">type HasName</a></dd>
				
				
			
				
				<dd><a href="#HasSid">type HasSid</a></dd>
				
				
			
				
				<dd><a href="#ImageDef">type ImageDef</a></dd>
				
				
			
				
				<dd><a href="#ImageInitFrom">type ImageInitFrom</a></dd>
				
				
			
				
				<dd><a href="#ImageInst">type ImageInst</a></dd>
				
				
			
				
				<dd><a href="#Input">type Input</a></dd>
				
				
			
				
				<dd><a href="#InputShared">type InputShared</a></dd>
				
				
			
				
				<dd><a href="#Int2">type Int2</a></dd>
				
				
			
				
				<dd><a href="#Int2x2">type Int2x2</a></dd>
				
				
			
				
				<dd><a href="#Int3">type Int3</a></dd>
				
				
			
				
				<dd><a href="#Int3x3">type Int3x3</a></dd>
				
				
			
				
				<dd><a href="#Int4">type Int4</a></dd>
				
				
			
				
				<dd><a href="#Int4x4">type Int4x4</a></dd>
				
				
			
				
				<dd><a href="#LibAnimationClipDefs">type LibAnimationClipDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Add">func (me *LibAnimationClipDefs) Add(d *AnimationClipDef) (n *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.AddNew">func (me *LibAnimationClipDefs) AddNew(id string) *AnimationClipDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.New">func (me *LibAnimationClipDefs) New(id string) (def *AnimationClipDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.Remove">func (me *LibAnimationClipDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationClipDefs.SyncChanges">func (me *LibAnimationClipDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibAnimationDefs">type LibAnimationDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Add">func (me *LibAnimationDefs) Add(d *AnimationDef) (n *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.AddNew">func (me *LibAnimationDefs) AddNew(id string) *AnimationDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.New">func (me *LibAnimationDefs) New(id string) (def *AnimationDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.Remove">func (me *LibAnimationDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibAnimationDefs.SyncChanges">func (me *LibAnimationDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibCameraDefs">type LibCameraDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Add">func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.AddNew">func (me *LibCameraDefs) AddNew(id string) *CameraDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.New">func (me *LibCameraDefs) New(id string) (def *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Remove">func (me *LibCameraDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.SyncChanges">func (me *LibCameraDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibControllerDefs">type LibControllerDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Add">func (me *LibControllerDefs) Add(d *ControllerDef) (n *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.AddNew">func (me *LibControllerDefs) AddNew(id string) *ControllerDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.New">func (me *LibControllerDefs) New(id string) (def *ControllerDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.Remove">func (me *LibControllerDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibControllerDefs.SyncChanges">func (me *LibControllerDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibEffectDefs">type LibEffectDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.Add">func (me *LibEffectDefs) Add(d *EffectDef) (n *EffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.AddNew">func (me *LibEffectDefs) AddNew(id string) *EffectDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.New">func (me *LibEffectDefs) New(id string) (def *EffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.Remove">func (me *LibEffectDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.SyncChanges">func (me *LibEffectDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibFormulaDefs">type LibFormulaDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Add">func (me *LibFormulaDefs) Add(d *FormulaDef) (n *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.AddNew">func (me *LibFormulaDefs) AddNew(id string) *FormulaDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.New">func (me *LibFormulaDefs) New(id string) (def *FormulaDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.Remove">func (me *LibFormulaDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibFormulaDefs.SyncChanges">func (me *LibFormulaDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibGeometryDefs">type LibGeometryDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Add">func (me *LibGeometryDefs) Add(d *GeometryDef) (n *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.AddNew">func (me *LibGeometryDefs) AddNew(id string) *GeometryDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.New">func (me *LibGeometryDefs) New(id string) (def *GeometryDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.Remove">func (me *LibGeometryDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibGeometryDefs.SyncChanges">func (me *LibGeometryDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibImageDefs">type LibImageDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.Add">func (me *LibImageDefs) Add(d *ImageDef) (n *ImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.AddNew">func (me *LibImageDefs) AddNew(id string) *ImageDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.New">func (me *LibImageDefs) New(id string) (def *ImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.Remove">func (me *LibImageDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.SyncChanges">func (me *LibImageDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibMaterialDefs">type LibMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.Add">func (me *LibMaterialDefs) Add(d *MaterialDef) (n *MaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.AddNew">func (me *LibMaterialDefs) AddNew(id string) *MaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.New">func (me *LibMaterialDefs) New(id string) (def *MaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.Remove">func (me *LibMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.SyncChanges">func (me *LibMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibNodeDefs">type LibNodeDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Add">func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.AddNew">func (me *LibNodeDefs) AddNew(id string) *NodeDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.New">func (me *LibNodeDefs) New(id string) (def *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Remove">func (me *LibNodeDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.SyncChanges">func (me *LibNodeDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibVisualSceneDefs">type LibVisualSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Add">func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.AddNew">func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.New">func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Remove">func (me *LibVisualSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.SyncChanges">func (me *LibVisualSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibsAnimationClipDef">type LibsAnimationClipDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsAnimationClipDef.AddNew">func (me LibsAnimationClipDef) AddNew(id string) (lib *LibAnimationClipDefs)</a></dd>
				
			
				
				<dd><a href="#LibsAnimationDef">type LibsAnimationDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsAnimationDef.AddNew">func (me LibsAnimationDef) AddNew(id string) (lib *LibAnimationDefs)</a></dd>
				
			
				
				<dd><a href="#LibsCameraDef">type LibsCameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsCameraDef.AddNew">func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</a></dd>
				
			
				
				<dd><a href="#LibsControllerDef">type LibsControllerDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsControllerDef.AddNew">func (me LibsControllerDef) AddNew(id string) (lib *LibControllerDefs)</a></dd>
				
			
				
				<dd><a href="#LibsEffectDef">type LibsEffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsEffectDef.AddNew">func (me LibsEffectDef) AddNew(id string) (lib *LibEffectDefs)</a></dd>
				
			
				
				<dd><a href="#LibsFormulaDef">type LibsFormulaDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsFormulaDef.AddNew">func (me LibsFormulaDef) AddNew(id string) (lib *LibFormulaDefs)</a></dd>
				
			
				
				<dd><a href="#LibsGeometryDef">type LibsGeometryDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsGeometryDef.AddNew">func (me LibsGeometryDef) AddNew(id string) (lib *LibGeometryDefs)</a></dd>
				
			
				
				<dd><a href="#LibsImageDef">type LibsImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsImageDef.AddNew">func (me LibsImageDef) AddNew(id string) (lib *LibImageDefs)</a></dd>
				
			
				
				<dd><a href="#LibsMaterialDef">type LibsMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsMaterialDef.AddNew">func (me LibsMaterialDef) AddNew(id string) (lib *LibMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsNodeDef">type LibsNodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsNodeDef.AddNew">func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</a></dd>
				
			
				
				<dd><a href="#LibsVisualSceneDef">type LibsVisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsVisualSceneDef.AddNew">func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</a></dd>
				
			
				
				<dd><a href="#ListBools">type ListBools</a></dd>
				
				
			
				
				<dd><a href="#ListFloats">type ListFloats</a></dd>
				
				
			
				
				<dd><a href="#ListInts">type ListInts</a></dd>
				
				
			
				
				<dd><a href="#ListStrings">type ListStrings</a></dd>
				
				
			
				
				<dd><a href="#MaterialDef">type MaterialDef</a></dd>
				
				
			
				
				<dd><a href="#MaterialInst">type MaterialInst</a></dd>
				
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddFaces">func (me *MeshData) AddFaces(faces ...MeshFace3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddNormals">func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddPositions">func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddTexCoords">func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</a></dd>
				
			
				
				<dd><a href="#MeshFace3">type MeshFace3</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#MeshRaw">type MeshRaw</a></dd>
				
				
			
				
				<dd><a href="#MeshRawFace">type MeshRawFace</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshRawFace">func NewMeshRawFace() (me *MeshRawFace)</a></dd>
				
				
			
				
				<dd><a href="#MeshVert">type MeshVert</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt2">type MeshVertAtt2</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt3">type MeshVertAtt3</a></dd>
				
				
			
				
				<dd><a href="#NodeDef">type NodeDef</a></dd>
				
				
			
				
				<dd><a href="#NodeInst">type NodeInst</a></dd>
				
				
			
				
				<dd><a href="#Param">type Param</a></dd>
				
				
			
				
				<dd><a href="#ParamBool">type ParamBool</a></dd>
				
				
			
				
				<dd><a href="#ParamDef">type ParamDef</a></dd>
				
				
			
				
				<dd><a href="#ParamDefs">type ParamDefs</a></dd>
				
				
			
				
				<dd><a href="#ParamFloat">type ParamFloat</a></dd>
				
				
			
				
				<dd><a href="#ParamInst">type ParamInst</a></dd>
				
				
			
				
				<dd><a href="#ParamInt">type ParamInt</a></dd>
				
				
			
				
				<dd><a href="#ParamScopedFloat">type ParamScopedFloat</a></dd>
				
				
			
				
				<dd><a href="#ParamString">type ParamString</a></dd>
				
				
			
				
				<dd><a href="#ParamUint">type ParamUint</a></dd>
				
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
				
			
				
				<dd><a href="#ScopedFloat">type ScopedFloat</a></dd>
				
				
			
				
				<dd><a href="#Source">type Source</a></dd>
				
				
			
				
				<dd><a href="#SourceAccessor">type SourceAccessor</a></dd>
				
				
			
				
				<dd><a href="#Sources">type Sources</a></dd>
				
				
			
				
				<dd><a href="#Technique">type Technique</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneDef">type VisualSceneDef</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneInst">type VisualSceneInst</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/animation.gt.go">animation.gt.go</a>
			
				<a href="/target/animationclip.gt.go">animationclip.gt.go</a>
			
				<a href="/target/assets.go">assets.go</a>
			
				<a href="/target/base.go">base.go</a>
			
				<a href="/target/camera.gt.go">camera.gt.go</a>
			
				<a href="/target/common.go">common.go</a>
			
				<a href="/target/controller.gt.go">controller.gt.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/effect.gt.go">effect.gt.go</a>
			
				<a href="/target/formula.gt.go">formula.gt.go</a>
			
				<a href="/target/fxsampler.go">fxsampler.go</a>
			
				<a href="/target/geometry.gt.go">geometry.gt.go</a>
			
				<a href="/target/image.gt.go">image.gt.go</a>
			
				<a href="/target/material.gt.go">material.gt.go</a>
			
				<a href="/target/meshdata.go">meshdata.go</a>
			
				<a href="/target/node.gt.go">node.gt.go</a>
			
				<a href="/target/scene.go">scene.go</a>
			
				<a href="/target/source.go">source.go</a>
			
				<a href="/target/types.go">types.go</a>
			
				<a href="/target/visualscene.gt.go">visualscene.gt.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    FX_SAMPLER_FILTER_NONE        = 0
    FX_SAMPLER_FILTER_NEAREST     = 0x2600
    FX_SAMPLER_FILTER_LINEAR      = 0x2601
    FX_SAMPLER_FILTER_ANISOTROPIC = 1

    FX_SAMPLER_WRAP_WRAP        = 0x2901
    FX_SAMPLER_WRAP_MIRROR      = 0x8370
    FX_SAMPLER_WRAP_CLAMP       = 0x812F
    FX_SAMPLER_WRAP_BORDER      = 0x812D
    FX_SAMPLER_WRAP_MIRROR_ONCE = 0
)</pre>
				
			
				<pre>const (
    GEOMETRY_PRIMITIVE_TYPE_LINES       = 0x0001
    GEOMETRY_PRIMITIVE_TYPE_LINE_STRIPS = 0x0003
    GEOMETRY_PRIMITIVE_TYPE_POLYGONS    = 2
    GEOMETRY_PRIMITIVE_TYPE_POLYLIST    = 7
    GEOMETRY_PRIMITIVE_TYPE_TRIANGLES   = 0x0004
    GEOMETRY_PRIMITIVE_TYPE_TRIFANS     = 0x0006
    GEOMETRY_PRIMITIVE_TYPE_TRISTRIPS   = 0x0005
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibAnimationDefs* libraries associated by their *ID*.</span>
    AllAnimationDefLibs = LibsAnimationDef{}

    <span class="comment">//	The &#34;default&#34; *LibAnimationDefs* library for *AnimationDef*s.</span>
    AnimationDefs = AllAnimationDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibAnimationClipDefs* libraries associated by their *ID*.</span>
    AllAnimationClipDefLibs = LibsAnimationClipDef{}

    <span class="comment">//	The &#34;default&#34; *LibAnimationClipDefs* library for *AnimationClipDef*s.</span>
    AnimationClipDefs = AllAnimationClipDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	This callback, set by *core* (or your custom package), gets called before SyncChanges() proceeds with syncing.</span>
    OnBeforeSyncAll func()

    <span class="comment">//	This callback, set by *core* (or your custom package), gets called after SyncChanges() has finished syncing.</span>
    OnAfterSyncAll func()

    <span class="comment">//	Your default unit-in-meters for geometry, coordinates and transformations.</span>
    <span class="comment">//	If a unit represents:</span>
    <span class="comment">//	- a meter, set to 1;</span>
    <span class="comment">//	- a centimeter, set to 0.01;</span>
    <span class="comment">//	- a kilometer, set to 1000;</span>
    <span class="comment">//	- an inch, set to 0.02539999969303608... etc.</span>
    <span class="comment">//	The *assets* package does not support multiple different or individual per-asset units.</span>
    <span class="comment">//	This is ONLY used when importing assets that specify their own unit-in-meters, those will be re-scaled to this unit.</span>
    <span class="comment">//	If you need to customize this value, do so before populating the *assets* package&#39;s libraries.</span>
    UnitInMeters float64 = 1
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibCameraDefs* libraries associated by their *ID*.</span>
    AllCameraDefLibs = LibsCameraDef{}

    <span class="comment">//	The &#34;default&#34; *LibCameraDefs* library for *CameraDef*s.</span>
    CameraDefs = AllCameraDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibControllerDefs* libraries associated by their *ID*.</span>
    AllControllerDefLibs = LibsControllerDef{}

    <span class="comment">//	The &#34;default&#34; *LibControllerDefs* library for *ControllerDef*s.</span>
    ControllerDefs = AllControllerDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibEffectDefs* libraries associated by their *ID*.</span>
    AllEffectDefLibs = LibsEffectDef{}

    <span class="comment">//	The &#34;default&#34; *LibEffectDefs* library for *EffectDef*s.</span>
    EffectDefs = AllEffectDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibFormulaDefs* libraries associated by their *ID*.</span>
    AllFormulaDefLibs = LibsFormulaDef{}

    <span class="comment">//	The &#34;default&#34; *LibFormulaDefs* library for *FormulaDef*s.</span>
    FormulaDefs = AllFormulaDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    DefaultFxSamplerFiltering = &amp;FxSamplerFiltering{
        FilterMag:     FX_SAMPLER_FILTER_LINEAR,
        FilterMin:     FX_SAMPLER_FILTER_LINEAR,
        FilterMip:     FX_SAMPLER_FILTER_LINEAR,
        MaxAnisotropy: 1,
    }
    DefaultFxSamplerWrapping = &amp;FxSamplerWrapping{
        BorderColor: ugfx.Rgba32{R: 0, G: 0, B: 0, A: 1},
        WrapS:       FX_SAMPLER_WRAP_WRAP,
        WrapT:       FX_SAMPLER_WRAP_WRAP,
        WrapP:       FX_SAMPLER_WRAP_WRAP,
    }
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibGeometryDefs* libraries associated by their *ID*.</span>
    AllGeometryDefLibs = LibsGeometryDef{}

    <span class="comment">//	The &#34;default&#34; *LibGeometryDefs* library for *GeometryDef*s.</span>
    GeometryDefs = AllGeometryDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibImageDefs* libraries associated by their *ID*.</span>
    AllImageDefLibs = LibsImageDef{}

    <span class="comment">//	The &#34;default&#34; *LibImageDefs* library for *ImageDef*s.</span>
    ImageDefs = AllImageDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibMaterialDefs* libraries associated by their *ID*.</span>
    AllMaterialDefLibs = LibsMaterialDef{}

    <span class="comment">//	The &#34;default&#34; *LibMaterialDefs* library for *MaterialDef*s.</span>
    MaterialDefs = AllMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibNodeDefs* libraries associated by their *ID*.</span>
    AllNodeDefLibs = LibsNodeDef{}

    <span class="comment">//	The &#34;default&#34; *LibNodeDefs* library for *NodeDef*s.</span>
    NodeDefs = AllNodeDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibVisualSceneDefs* libraries associated by their *ID*.</span>
    AllVisualSceneDefLibs = LibsVisualSceneDef{}

    <span class="comment">//	The &#34;default&#34; *LibVisualSceneDefs* library for *VisualSceneDef*s.</span>
    VisualSceneDefs = AllVisualSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
		
		
			
			
			<h2 id="SyncChanges">func <a href="/target/assets.go?s=1285:1303#L28">SyncChanges</a></h2>
			<pre>func SyncChanges()</pre>
			<p>
Signals to *core* (or your custom package) that changes have been made that need to be picked up. Call this after you have made any number of changes to your Defs, Insts or Libs.
</p>

			
		
		
			
			
			<h2 id="AnimationChannel">type <a href="/target/animation.gt.go?s=16:78#L1">AnimationChannel</a></h2>
			<pre>type AnimationChannel struct {
    Source string
    Target string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="AnimationClipDef">type <a href="/target/animationclip.gt.go?s=16:153#L1">AnimationClipDef</a></h2>
			<pre>type AnimationClipDef struct {
    BaseDef
    Start      float64
    End        float64
    Animations []*AnimationInst
    Formulas   []*FormulaInst
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="AnimationDef">type <a href="/target/animation.gt.go?s=186:347#L5">AnimationDef</a></h2>
			<pre>type AnimationDef struct {
    BaseDef
    AnimationDefs []*AnimationDef
    Channels      []*AnimationChannel
    Samplers      []*AnimationSampler
    Sources       Sources
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="AnimationInst">type <a href="/target/animation.gt.go?s=409:468#L17">AnimationInst</a></h2>
			<pre>type AnimationInst struct {
    BaseInst

    Def *AnimationDef
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="AnimationSampler">type <a href="/target/animation.gt.go?s=80:184#L1">AnimationSampler</a></h2>
			<pre>type AnimationSampler struct {
    HasID
    PreBehavior  string
    PostBehavior string
    Inputs       []*Input
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Asset">type <a href="/target/common.go?s=353:595#L16">Asset</a></h2>
			<pre>type Asset struct {
    HasExtras
    Created      string
    Modified     string
    Keywords     string
    Revision     string
    Subject      string
    Title        string
    UpAxis       string
    Contributors []*Contributor
    Coverage     *GeographicLocation
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Base">type <a href="/target/base.go?s=74:453#L1">Base</a></h2>
			<pre>type Base struct {
    <span class="comment">//	This callback, set by *core* (or your custom package), gets called by the *SyncChanges()* method.</span>
    <span class="comment">//	This is the ultimate point in the sync chain where *core* (or your custom package) picks up the changed</span>
    <span class="comment">//	contents of this *Def*, *Inst* or *Lib*. If this is a *Lib* this gets called after all *Defs* in it</span>
    <span class="comment">//	have synced.</span>
    OnSync func()
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Provides a common base for *Def*s, *Inst*s and *Lib*s.
</p>


			

			

			

			

			
				
				<h3 id="Base.SetDirty">func (*Base) <a href="/target/base.go?s=678:704#L6">SetDirty</a></h3>
				<pre>func (me *Base) SetDirty()</pre>
				<p>
You NEED to call this method if you modified this *Def* or *Inst* by setting its fields directly
(instead of using the provided *SetFoo()* methods) for your changes to be picked up by *core* (or your custom package).
</p>

				
				
			
				
				<h3 id="Base.SetFieldB">func (*Base) <a href="/target/base.go?s=727:775#L10">SetFieldB</a></h3>
				<pre>func (me *Base) SetFieldB(field *bool, val bool)</pre>
				
				
				
			
				
				<h3 id="Base.SetFieldF">func (*Base) <a href="/target/base.go?s=835:889#L17">SetFieldF</a></h3>
				<pre>func (me *Base) SetFieldF(field *float64, val float64)</pre>
				
				
				
			
				
				<h3 id="Base.SyncChanges">func (*Base) <a href="/target/base.go?s=1294:1323#L32">SyncChanges</a></h3>
				<pre>func (me *Base) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *Def*, *Inst* or *Lib* that need to be picked up.
Call this after you have made any number of changes to this this *Def*, *Inst* or *Lib*.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="BaseDef">type <a href="/target/base.go?s=1418:1484#L40">BaseDef</a></h2>
			<pre>type BaseDef struct {
    Base
    HasID
    HasName
    HasAsset
    HasExtras
}</pre>
			<p>
Provides a common base for *Def*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseInst">type <a href="/target/base.go?s=1525:1583#L49">BaseInst</a></h2>
			<pre>type BaseInst struct {
    Base
    HasName
    HasSid
    HasExtras
}</pre>
			<p>
Provides a common base for *Inst*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseLib">type <a href="/target/base.go?s=1623:1668#L57">BaseLib</a></h2>
			<pre>type BaseLib struct {
    Base
    HasID
    HasName
}</pre>
			<p>
Provides a common base for *Lib*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Bool2">type <a href="/target/types.go?s=16:34#L1">Bool2</a></h2>
			<pre>type Bool2 [2]bool</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Bool3">type <a href="/target/types.go?s=36:54#L1">Bool3</a></h2>
			<pre>type Bool3 [3]bool</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Bool4">type <a href="/target/types.go?s=56:74#L1">Bool4</a></h2>
			<pre>type Bool4 [4]bool</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="CameraDef">type <a href="/target/camera.gt.go?s=119:756#L1">CameraDef</a></h2>
			<pre>type CameraDef struct {
    BaseDef

    <span class="comment">//	Horizontal field-of-view for perspective camera.</span>
    FovX float64

    <span class="comment">//	Vertical field-of-view for perspective camera.</span>
    FovY float64

    <span class="comment">//	Horizontal magnification for orthographic camera.</span>
    MagX float64

    <span class="comment">//	Verticial magnification for orthographic camera.</span>
    MagY float64

    <span class="comment">//	The distance of the lens to the far-plane. Camera cannot see anything behind the far-plane.</span>
    Zfar float64

    <span class="comment">//	The distance of the lens to the near-plane. Camera cannot see anything in front of the near-plane.</span>
    Znear float64

    <span class="comment">//	Specifies whether this camera is an orthographic (rather than a perspective) camera.</span>
    Ortho bool
}</pre>
			<p>
Defines a perspective or orthographic camera. Only perspective cameras are supported at this point.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraInst">type <a href="/target/camera.gt.go?s=839:947#L23">CameraInst</a></h2>
			<pre>type CameraInst struct {
    BaseInst

    <span class="comment">//	The camera definition referenced by this instance.</span>
    Def *CameraDef
}</pre>
			<p>
An instance referencing a camera definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Contributor">type <a href="/target/common.go?s=597:778#L29">Contributor</a></h2>
			<pre>type Contributor struct {
    Author        string
    AuthorEmail   string
    AuthorWebsite string
    AuthoringTool string
    Comments      string
    Copyright     string
    SourceData    string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ControllerDef">type <a href="/target/controller.gt.go?s=624:709#L29">ControllerDef</a></h2>
			<pre>type ControllerDef struct {
    BaseDef
    Morph *ControllerMorph
    Skin  *ControllerSkin
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ControllerInst">type <a href="/target/controller.gt.go?s=748:809#L38">ControllerInst</a></h2>
			<pre>type ControllerInst struct {
    BaseInst

    Def *ControllerDef
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ControllerMorph">type <a href="/target/controller.gt.go?s=16:149#L1">ControllerMorph</a></h2>
			<pre>type ControllerMorph struct {
    Relative bool
    Source   string
    Sources  Sources
    Targets  struct {
        HasExtras
        Inputs []*Input
    }
}</pre>
			

			

			

			

			
				
				<h3 id="NewControllerMorph">func <a href="/target/controller.gt.go?s=151:198#L3">NewControllerMorph</a></h3>
				<pre>func NewControllerMorph() (me *ControllerMorph)</pre>
				
				
			

			
		
			
			
			<h2 id="ControllerSkin">type <a href="/target/controller.gt.go?s=255:521#L8">ControllerSkin</a></h2>
			<pre>type ControllerSkin struct {
    Source          string
    BindShapeMatrix *Float4x4
    Sources         Sources
    Joints          struct {
        HasExtras
        Inputs []*Input
    }
    VertexWeights struct {
        Count  uint64
        Inputs []*InputShared
        VCount []int64
        V      []int64
    }
}</pre>
			

			

			

			

			
				
				<h3 id="NewControllerSkin">func <a href="/target/controller.gt.go?s=523:568#L24">NewControllerSkin</a></h3>
				<pre>func NewControllerSkin() (me *ControllerSkin)</pre>
				
				
			

			
		
			
			
			<h2 id="EffectDef">type <a href="/target/effect.gt.go?s=124:212#L1">EffectDef</a></h2>
			<pre>type EffectDef struct {
    BaseDef
    Annotations []*FxAnnotation
    Params      FxParamDefs
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry and screen-space image processing.
</p>


			

			

			

			

			
		
			
			
			<h2 id="EffectInst">type <a href="/target/effect.gt.go?s=322:430#L5">EffectInst</a></h2>
			<pre>type EffectInst struct {
    BaseInst

    <span class="comment">//	The Effect definition referenced by this instance.</span>
    Def *EffectDef
}</pre>
			<p>
An instance referencing a Effect definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Extra">type <a href="/target/common.go?s=780:871#L39">Extra</a></h2>
			<pre>type Extra struct {
    HasID
    HasName
    HasAsset
    Type       string
    Techniques []*Technique
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float2">type <a href="/target/types.go?s=76:98#L1">Float2</a></h2>
			<pre>type Float2 [2]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float2x2">type <a href="/target/types.go?s=100:124#L1">Float2x2</a></h2>
			<pre>type Float2x2 [4]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float2x3">type <a href="/target/types.go?s=126:150#L3">Float2x3</a></h2>
			<pre>type Float2x3 [6]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float2x4">type <a href="/target/types.go?s=152:176#L5">Float2x4</a></h2>
			<pre>type Float2x4 [8]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float3">type <a href="/target/types.go?s=178:200#L7">Float3</a></h2>
			<pre>type Float3 [3]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float3x2">type <a href="/target/types.go?s=202:226#L9">Float3x2</a></h2>
			<pre>type Float3x2 [6]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float3x3">type <a href="/target/types.go?s=228:252#L11">Float3x3</a></h2>
			<pre>type Float3x3 [9]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float3x4">type <a href="/target/types.go?s=254:279#L13">Float3x4</a></h2>
			<pre>type Float3x4 [12]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float4">type <a href="/target/types.go?s=281:303#L15">Float4</a></h2>
			<pre>type Float4 [4]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float4x2">type <a href="/target/types.go?s=305:329#L17">Float4x2</a></h2>
			<pre>type Float4x2 [8]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float4x3">type <a href="/target/types.go?s=331:356#L19">Float4x3</a></h2>
			<pre>type Float4x3 [12]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float4x4">type <a href="/target/types.go?s=358:383#L21">Float4x4</a></h2>
			<pre>type Float4x4 [16]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Float7">type <a href="/target/types.go?s=385:407#L23">Float7</a></h2>
			<pre>type Float7 [7]float64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FormulaDef">type <a href="/target/formula.gt.go?s=16:187#L1">FormulaDef</a></h2>
			<pre>type FormulaDef struct {
    BaseDef
    HasSid
    ParamDefs       ParamDefs
    Target          ParamFloat
    TechniqueCommon struct {
        Data interface{}
    }
    Techniques []*Technique
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FormulaInst">type <a href="/target/formula.gt.go?s=251:337#L8">FormulaInst</a></h2>
			<pre>type FormulaInst struct {
    BaseInst
    Def        *FormulaDef
    ParamInsts []*ParamInst
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxAnnotation">type <a href="/target/common.go?s=873:929#L47">FxAnnotation</a></h2>
			<pre>type FxAnnotation struct {
    HasName
    Value interface{}
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxParamDef">type <a href="/target/common.go?s=931:1030#L52">FxParamDef</a></h2>
			<pre>type FxParamDef struct {
    ParamDef
    Annotations        []*FxAnnotation
    Modifier, Semantic string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxParamDefs">type <a href="/target/common.go?s=1032:1071#L58">FxParamDefs</a></h2>
			<pre>type FxParamDefs map[string]*FxParamDef</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxSampler">type <a href="/target/fxsampler.go?s=1126:1234#L37">FxSampler</a></h2>
			<pre>type FxSampler struct {
    Image     *ImageInst
    Filtering *FxSamplerFiltering
    Wrapping  *FxSamplerWrapping
}</pre>
			

			

			

			

			
				
				<h3 id="NewFxSampler">func <a href="/target/fxsampler.go?s=1236:1271#L43">NewFxSampler</a></h3>
				<pre>func NewFxSampler() (me *FxSampler)</pre>
				
				
			

			
		
			
			
			<h2 id="FxSamplerFiltering">type <a href="/target/fxsampler.go?s=840:1031#L25">FxSamplerFiltering</a></h2>
			<pre>type FxSamplerFiltering struct {
    FilterMag, FilterMin, FilterMip int
    MaxAnisotropy                   uint32
    MipMaxLevel, MipMinLevel        uint8
    MipBias                         float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxSamplerWrapping">type <a href="/target/fxsampler.go?s=1033:1124#L32">FxSamplerWrapping</a></h2>
			<pre>type FxSamplerWrapping struct {
    BorderColor         ugfx.Rgba32
    WrapS, WrapT, WrapP int
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeographicLocation">type <a href="/target/common.go?s=1073:1208#L60">GeographicLocation</a></h2>
			<pre>type GeographicLocation struct {
    Longitude        float64
    Latitude         float64
    Altitude         float64
    AltitudeAbsolute bool
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryBrep">type <a href="/target/geometry.gt.go?s=339:378#L3">GeometryBrep</a></h2>
			<pre>type GeometryBrep struct {
    HasExtras
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryDef">type <a href="/target/geometry.gt.go?s=1075:1179#L51">GeometryDef</a></h2>
			<pre>type GeometryDef struct {
    BaseDef
    Brep   *GeometryBrep
    Mesh   *GeometryMesh
    Spline *GeometrySpline
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryInst">type <a href="/target/geometry.gt.go?s=1216:1273#L61">GeometryInst</a></h2>
			<pre>type GeometryInst struct {
    BaseInst

    Def *GeometryDef
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometryMesh">type <a href="/target/geometry.gt.go?s=380:503#L7">GeometryMesh</a></h2>
			<pre>type GeometryMesh struct {
    HasExtras
    Sources    Sources
    Vertices   *GeometryVertices
    Primitives []*GeometryPrimitives
}</pre>
			

			

			

			

			
				
				<h3 id="NewGeometryMesh">func <a href="/target/geometry.gt.go?s=505:546#L14">NewGeometryMesh</a></h3>
				<pre>func NewGeometryMesh() (me *GeometryMesh)</pre>
				
				
			

			
		
			
			
			<h2 id="GeometryPrimitives">type <a href="/target/geometry.gt.go?s=600:745#L19">GeometryPrimitives</a></h2>
			<pre>type GeometryPrimitives struct {
    HasExtras
    HasName
    Count    uint64
    Material string
    Inputs   []*InputShared
    Indices  []int64
    Type     int
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="GeometrySpline">type <a href="/target/geometry.gt.go?s=747:894#L29">GeometrySpline</a></h2>
			<pre>type GeometrySpline struct {
    HasExtras
    Closed          bool
    Sources         Sources
    ControlVertices struct {
        HasExtras
        Inputs []*Input
    }
}</pre>
			

			

			

			

			
				
				<h3 id="NewGeometrySpline">func <a href="/target/geometry.gt.go?s=974:1019#L46">NewGeometrySpline</a></h3>
				<pre>func NewGeometrySpline() (me *GeometrySpline)</pre>
				
				
			

			
		
			
			
			<h2 id="GeometryVertices">type <a href="/target/geometry.gt.go?s=896:972#L39">GeometryVertices</a></h2>
			<pre>type GeometryVertices struct {
    HasID
    HasName
    HasExtras
    Inputs []*Input
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasAsset">type <a href="/target/common.go?s=16:54#L1">HasAsset</a></h2>
			<pre>type HasAsset struct {
    Asset *Asset
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasExtras">type <a href="/target/common.go?s=56:98#L1">HasExtras</a></h2>
			<pre>type HasExtras struct {
    Extras []*Extra
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasID">type <a href="/target/common.go?s=100:190#L1">HasID</a></h2>
			<pre>type HasID struct {
    <span class="comment">//	The unique identifier of this *Def*, *Inst* or *Lib*.</span>
    ID string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasName">type <a href="/target/common.go?s=192:301#L6">HasName</a></h2>
			<pre>type HasName struct {
    <span class="comment">//	The optional pretty-print name/title of this *Def*, *Inst* or *Lib*.</span>
    Name string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasSid">type <a href="/target/common.go?s=303:351#L11">HasSid</a></h2>
			<pre>type HasSid struct {
    <span class="comment">//	Scoped ID</span>
    Sid string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ImageDef">type <a href="/target/image.gt.go?s=477:633#L7">ImageDef</a></h2>
			<pre>type ImageDef struct {
    BaseDef
    HasSid
    <span class="comment">//	Initializes an entire Image or portions of an Image from referenced or embedded data.</span>
    InitFrom *ImageInitFrom
}</pre>
			<p>
Declares the storage for the graphical representation of an object.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ImageInitFrom">type <a href="/target/image.gt.go?s=57:404#L1">ImageInitFrom</a></h2>
			<pre>type ImageInitFrom struct {
    <span class="comment">//	Initializes higher MIP levels if data does not exist in a file. Defaults to true.</span>
    AutoMip bool

    <span class="comment">//	Contains the embedded image data as a sequence of bytes.</span>
    RawData []byte

    <span class="comment">//	The URL of a file from which to take initialization data. Can be a relative path</span>
    <span class="comment">//	such as &#34;walltextures/wall01.jpg&#34;.</span>
    RefUrl string
}</pre>
			<p>
Used for the ImageDef.InitFrom field.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ImageInst">type <a href="/target/image.gt.go?s=760:865#L19">ImageInst</a></h2>
			<pre>type ImageInst struct {
    BaseInst

    <span class="comment">//	The image definition referenced by this instance.</span>
    Def *ImageDef
}</pre>
			<p>
An instance referencing an Image definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Input">type <a href="/target/common.go?s=1210:1265#L67">Input</a></h2>
			<pre>type Input struct {
    Semantic string
    Source   string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="InputShared">type <a href="/target/common.go?s=1267:1331#L72">InputShared</a></h2>
			<pre>type InputShared struct {
    Input
    Offset uint64
    Set    uint64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Int2">type <a href="/target/types.go?s=409:427#L25">Int2</a></h2>
			<pre>type Int2 [2]int64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Int2x2">type <a href="/target/types.go?s=429:449#L27">Int2x2</a></h2>
			<pre>type Int2x2 [4]int64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Int3">type <a href="/target/types.go?s=451:469#L29">Int3</a></h2>
			<pre>type Int3 [3]int64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Int3x3">type <a href="/target/types.go?s=471:491#L31">Int3x3</a></h2>
			<pre>type Int3x3 [9]int64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Int4">type <a href="/target/types.go?s=493:511#L33">Int4</a></h2>
			<pre>type Int4 [4]int64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Int4x4">type <a href="/target/types.go?s=513:534#L35">Int4x4</a></h2>
			<pre>type Int4x4 [16]int64</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="LibAnimationClipDefs">type <a href="/target/animationclip.gt.go?s=2021:2301#L61">LibAnimationClipDefs</a></h2>
			<pre>type LibAnimationClipDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*AnimationClipDef
}</pre>
			<p>
A library that contains *AnimationClipDef*s associated by their *ID*. To create a new *LibAnimationClipDefs* library, ONLY
use the *LibsAnimationClipDef.New()* or *LibsAnimationClipDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibAnimationClipDefs.Add">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=2697:2775#L77">Add</a></h3>
				<pre>func (me *LibAnimationClipDefs) Add(d *AnimationClipDef) (n *AnimationClipDef)</pre>
				<p>
Adds the specified *AnimationClipDef* definition to this *LibAnimationClipDefs*, and returns it.
</p>
<p>
If this *LibAnimationClipDefs* already contains a *AnimationClipDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.AddNew">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=3127:3194#L88">AddNew</a></h3>
				<pre>func (me *LibAnimationClipDefs) AddNew(id string) *AnimationClipDef</pre>
				<p>
Creates a new *AnimationClipDef* definition with the specified *ID*, adds it to this *LibAnimationClipDefs*, and returns it.
</p>
<p>
If this *LibAnimationClipDefs* already contains a *AnimationClipDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.New">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=3365:3435#L91">New</a></h3>
				<pre>func (me *LibAnimationClipDefs) New(id string) (def *AnimationClipDef)</pre>
				<p>
Creates a new *AnimationClipDef* definition with the specified *ID* and returns it, but does not add it to this *LibAnimationClipDefs*.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.Remove">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=3571:3620#L94">Remove</a></h3>
				<pre>func (me *LibAnimationClipDefs) Remove(id string)</pre>
				<p>
Removes the *AnimationClipDef* with the specified *ID* from this *LibAnimationClipDefs*.
</p>

				
				
			
				
				<h3 id="LibAnimationClipDefs.SyncChanges">func (*LibAnimationClipDefs) <a href="/target/animationclip.gt.go?s=3978:4023#L99">SyncChanges</a></h3>
				<pre>func (me *LibAnimationClipDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibAnimationClipDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibAnimationClipDefs* library or its *AnimationClipDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibAnimationDefs">type <a href="/target/animation.gt.go?s=2197:2469#L83">LibAnimationDefs</a></h2>
			<pre>type LibAnimationDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*AnimationDef
}</pre>
			<p>
A library that contains *AnimationDef*s associated by their *ID*. To create a new *LibAnimationDefs* library, ONLY
use the *LibsAnimationDef.New()* or *LibsAnimationDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibAnimationDefs.Add">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=2833:2899#L99">Add</a></h3>
				<pre>func (me *LibAnimationDefs) Add(d *AnimationDef) (n *AnimationDef)</pre>
				<p>
Adds the specified *AnimationDef* definition to this *LibAnimationDefs*, and returns it.
</p>
<p>
If this *LibAnimationDefs* already contains a *AnimationDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.AddNew">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=3235:3294#L110">AddNew</a></h3>
				<pre>func (me *LibAnimationDefs) AddNew(id string) *AnimationDef</pre>
				<p>
Creates a new *AnimationDef* definition with the specified *ID*, adds it to this *LibAnimationDefs*, and returns it.
</p>
<p>
If this *LibAnimationDefs* already contains a *AnimationDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.New">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=3457:3519#L113">New</a></h3>
				<pre>func (me *LibAnimationDefs) New(id string) (def *AnimationDef)</pre>
				<p>
Creates a new *AnimationDef* definition with the specified *ID* and returns it, but does not add it to this *LibAnimationDefs*.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.Remove">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=3643:3688#L116">Remove</a></h3>
				<pre>func (me *LibAnimationDefs) Remove(id string)</pre>
				<p>
Removes the *AnimationDef* with the specified *ID* from this *LibAnimationDefs*.
</p>

				
				
			
				
				<h3 id="LibAnimationDefs.SyncChanges">func (*LibAnimationDefs) <a href="/target/animation.gt.go?s=4034:4075#L121">SyncChanges</a></h3>
				<pre>func (me *LibAnimationDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibAnimationDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibAnimationDefs* library or its *AnimationDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibCameraDefs">type <a href="/target/camera.gt.go?s=2571:2837#L90">LibCameraDefs</a></h2>
			<pre>type LibCameraDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*CameraDef
}</pre>
			<p>
A library that contains *CameraDef*s associated by their *ID*. To create a new *LibCameraDefs* library, ONLY
use the *LibsCameraDef.New()* or *LibsCameraDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibCameraDefs.Add">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=3177:3234#L106">Add</a></h3>
				<pre>func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</pre>
				<p>
Adds the specified *CameraDef* definition to this *LibCameraDefs*, and returns it.
</p>
<p>
If this *LibCameraDefs* already contains a *CameraDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.AddNew">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=3558:3611#L117">AddNew</a></h3>
				<pre>func (me *LibCameraDefs) AddNew(id string) *CameraDef</pre>
				<p>
Creates a new *CameraDef* definition with the specified *ID*, adds it to this *LibCameraDefs*, and returns it.
</p>
<p>
If this *LibCameraDefs* already contains a *CameraDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.New">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=3768:3824#L120">New</a></h3>
				<pre>func (me *LibCameraDefs) New(id string) (def *CameraDef)</pre>
				<p>
Creates a new *CameraDef* definition with the specified *ID* and returns it, but does not add it to this *LibCameraDefs*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Remove">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=3939:3981#L123">Remove</a></h3>
				<pre>func (me *LibCameraDefs) Remove(id string)</pre>
				<p>
Removes the *CameraDef* with the specified *ID* from this *LibCameraDefs*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.SyncChanges">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4318:4356#L128">SyncChanges</a></h3>
				<pre>func (me *LibCameraDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibCameraDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibCameraDefs* library or its *CameraDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibControllerDefs">type <a href="/target/controller.gt.go?s=2573:2847#L104">LibControllerDefs</a></h2>
			<pre>type LibControllerDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*ControllerDef
}</pre>
			<p>
A library that contains *ControllerDef*s associated by their *ID*. To create a new *LibControllerDefs* library, ONLY
use the *LibsControllerDef.New()* or *LibsControllerDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibControllerDefs.Add">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=3219:3288#L120">Add</a></h3>
				<pre>func (me *LibControllerDefs) Add(d *ControllerDef) (n *ControllerDef)</pre>
				<p>
Adds the specified *ControllerDef* definition to this *LibControllerDefs*, and returns it.
</p>
<p>
If this *LibControllerDefs* already contains a *ControllerDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.AddNew">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=3628:3689#L131">AddNew</a></h3>
				<pre>func (me *LibControllerDefs) AddNew(id string) *ControllerDef</pre>
				<p>
Creates a new *ControllerDef* definition with the specified *ID*, adds it to this *LibControllerDefs*, and returns it.
</p>
<p>
If this *LibControllerDefs* already contains a *ControllerDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.New">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=3854:3918#L134">New</a></h3>
				<pre>func (me *LibControllerDefs) New(id string) (def *ControllerDef)</pre>
				<p>
Creates a new *ControllerDef* definition with the specified *ID* and returns it, but does not add it to this *LibControllerDefs*.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.Remove">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=4045:4091#L137">Remove</a></h3>
				<pre>func (me *LibControllerDefs) Remove(id string)</pre>
				<p>
Removes the *ControllerDef* with the specified *ID* from this *LibControllerDefs*.
</p>

				
				
			
				
				<h3 id="LibControllerDefs.SyncChanges">func (*LibControllerDefs) <a href="/target/controller.gt.go?s=4440:4482#L142">SyncChanges</a></h3>
				<pre>func (me *LibControllerDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibControllerDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibControllerDefs* library or its *ControllerDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibEffectDefs">type <a href="/target/effect.gt.go?s=2054:2320#L72">LibEffectDefs</a></h2>
			<pre>type LibEffectDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*EffectDef
}</pre>
			<p>
A library that contains *EffectDef*s associated by their *ID*. To create a new *LibEffectDefs* library, ONLY
use the *LibsEffectDef.New()* or *LibsEffectDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibEffectDefs.Add">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=2660:2717#L88">Add</a></h3>
				<pre>func (me *LibEffectDefs) Add(d *EffectDef) (n *EffectDef)</pre>
				<p>
Adds the specified *EffectDef* definition to this *LibEffectDefs*, and returns it.
</p>
<p>
If this *LibEffectDefs* already contains a *EffectDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibEffectDefs.AddNew">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=3041:3094#L99">AddNew</a></h3>
				<pre>func (me *LibEffectDefs) AddNew(id string) *EffectDef</pre>
				<p>
Creates a new *EffectDef* definition with the specified *ID*, adds it to this *LibEffectDefs*, and returns it.
</p>
<p>
If this *LibEffectDefs* already contains a *EffectDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibEffectDefs.New">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=3251:3307#L102">New</a></h3>
				<pre>func (me *LibEffectDefs) New(id string) (def *EffectDef)</pre>
				<p>
Creates a new *EffectDef* definition with the specified *ID* and returns it, but does not add it to this *LibEffectDefs*.
</p>

				
				
			
				
				<h3 id="LibEffectDefs.Remove">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=3422:3464#L105">Remove</a></h3>
				<pre>func (me *LibEffectDefs) Remove(id string)</pre>
				<p>
Removes the *EffectDef* with the specified *ID* from this *LibEffectDefs*.
</p>

				
				
			
				
				<h3 id="LibEffectDefs.SyncChanges">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=3801:3839#L110">SyncChanges</a></h3>
				<pre>func (me *LibEffectDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibEffectDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibEffectDefs* library or its *EffectDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibFormulaDefs">type <a href="/target/formula.gt.go?s=1996:2264#L74">LibFormulaDefs</a></h2>
			<pre>type LibFormulaDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*FormulaDef
}</pre>
			<p>
A library that contains *FormulaDef*s associated by their *ID*. To create a new *LibFormulaDefs* library, ONLY
use the *LibsFormulaDef.New()* or *LibsFormulaDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibFormulaDefs.Add">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=2612:2672#L90">Add</a></h3>
				<pre>func (me *LibFormulaDefs) Add(d *FormulaDef) (n *FormulaDef)</pre>
				<p>
Adds the specified *FormulaDef* definition to this *LibFormulaDefs*, and returns it.
</p>
<p>
If this *LibFormulaDefs* already contains a *FormulaDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.AddNew">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=3000:3055#L101">AddNew</a></h3>
				<pre>func (me *LibFormulaDefs) AddNew(id string) *FormulaDef</pre>
				<p>
Creates a new *FormulaDef* definition with the specified *ID*, adds it to this *LibFormulaDefs*, and returns it.
</p>
<p>
If this *LibFormulaDefs* already contains a *FormulaDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.New">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=3214:3272#L104">New</a></h3>
				<pre>func (me *LibFormulaDefs) New(id string) (def *FormulaDef)</pre>
				<p>
Creates a new *FormulaDef* definition with the specified *ID* and returns it, but does not add it to this *LibFormulaDefs*.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.Remove">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=3390:3433#L107">Remove</a></h3>
				<pre>func (me *LibFormulaDefs) Remove(id string)</pre>
				<p>
Removes the *FormulaDef* with the specified *ID* from this *LibFormulaDefs*.
</p>

				
				
			
				
				<h3 id="LibFormulaDefs.SyncChanges">func (*LibFormulaDefs) <a href="/target/formula.gt.go?s=3773:3812#L112">SyncChanges</a></h3>
				<pre>func (me *LibFormulaDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibFormulaDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibFormulaDefs* library or its *FormulaDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibGeometryDefs">type <a href="/target/geometry.gt.go?s=2967:3237#L127">LibGeometryDefs</a></h2>
			<pre>type LibGeometryDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*GeometryDef
}</pre>
			<p>
A library that contains *GeometryDef*s associated by their *ID*. To create a new *LibGeometryDefs* library, ONLY
use the *LibsGeometryDef.New()* or *LibsGeometryDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibGeometryDefs.Add">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=3593:3656#L143">Add</a></h3>
				<pre>func (me *LibGeometryDefs) Add(d *GeometryDef) (n *GeometryDef)</pre>
				<p>
Adds the specified *GeometryDef* definition to this *LibGeometryDefs*, and returns it.
</p>
<p>
If this *LibGeometryDefs* already contains a *GeometryDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.AddNew">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=3988:4045#L154">AddNew</a></h3>
				<pre>func (me *LibGeometryDefs) AddNew(id string) *GeometryDef</pre>
				<p>
Creates a new *GeometryDef* definition with the specified *ID*, adds it to this *LibGeometryDefs*, and returns it.
</p>
<p>
If this *LibGeometryDefs* already contains a *GeometryDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.New">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=4206:4266#L157">New</a></h3>
				<pre>func (me *LibGeometryDefs) New(id string) (def *GeometryDef)</pre>
				<p>
Creates a new *GeometryDef* definition with the specified *ID* and returns it, but does not add it to this *LibGeometryDefs*.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.Remove">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=4387:4431#L160">Remove</a></h3>
				<pre>func (me *LibGeometryDefs) Remove(id string)</pre>
				<p>
Removes the *GeometryDef* with the specified *ID* from this *LibGeometryDefs*.
</p>

				
				
			
				
				<h3 id="LibGeometryDefs.SyncChanges">func (*LibGeometryDefs) <a href="/target/geometry.gt.go?s=4774:4814#L165">SyncChanges</a></h3>
				<pre>func (me *LibGeometryDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibGeometryDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibGeometryDefs* library or its *GeometryDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibImageDefs">type <a href="/target/image.gt.go?s=2454:2718#L86">LibImageDefs</a></h2>
			<pre>type LibImageDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*ImageDef
}</pre>
			<p>
A library that contains *ImageDef*s associated by their *ID*. To create a new *LibImageDefs* library, ONLY
use the *LibsImageDef.New()* or *LibsImageDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibImageDefs.Add">func (*LibImageDefs) <a href="/target/image.gt.go?s=3050:3104#L102">Add</a></h3>
				<pre>func (me *LibImageDefs) Add(d *ImageDef) (n *ImageDef)</pre>
				<p>
Adds the specified *ImageDef* definition to this *LibImageDefs*, and returns it.
</p>
<p>
If this *LibImageDefs* already contains a *ImageDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.AddNew">func (*LibImageDefs) <a href="/target/image.gt.go?s=3424:3475#L113">AddNew</a></h3>
				<pre>func (me *LibImageDefs) AddNew(id string) *ImageDef</pre>
				<p>
Creates a new *ImageDef* definition with the specified *ID*, adds it to this *LibImageDefs*, and returns it.
</p>
<p>
If this *LibImageDefs* already contains a *ImageDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.New">func (*LibImageDefs) <a href="/target/image.gt.go?s=3630:3684#L116">New</a></h3>
				<pre>func (me *LibImageDefs) New(id string) (def *ImageDef)</pre>
				<p>
Creates a new *ImageDef* definition with the specified *ID* and returns it, but does not add it to this *LibImageDefs*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.Remove">func (*LibImageDefs) <a href="/target/image.gt.go?s=3796:3837#L119">Remove</a></h3>
				<pre>func (me *LibImageDefs) Remove(id string)</pre>
				<p>
Removes the *ImageDef* with the specified *ID* from this *LibImageDefs*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.SyncChanges">func (*LibImageDefs) <a href="/target/image.gt.go?s=4171:4208#L124">SyncChanges</a></h3>
				<pre>func (me *LibImageDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibImageDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibImageDefs* library or its *ImageDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibMaterialDefs">type <a href="/target/material.gt.go?s=2055:2325#L69">LibMaterialDefs</a></h2>
			<pre>type LibMaterialDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*MaterialDef
}</pre>
			<p>
A library that contains *MaterialDef*s associated by their *ID*. To create a new *LibMaterialDefs* library, ONLY
use the *LibsMaterialDef.New()* or *LibsMaterialDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibMaterialDefs.Add">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=2681:2744#L85">Add</a></h3>
				<pre>func (me *LibMaterialDefs) Add(d *MaterialDef) (n *MaterialDef)</pre>
				<p>
Adds the specified *MaterialDef* definition to this *LibMaterialDefs*, and returns it.
</p>
<p>
If this *LibMaterialDefs* already contains a *MaterialDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.AddNew">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3076:3133#L96">AddNew</a></h3>
				<pre>func (me *LibMaterialDefs) AddNew(id string) *MaterialDef</pre>
				<p>
Creates a new *MaterialDef* definition with the specified *ID*, adds it to this *LibMaterialDefs*, and returns it.
</p>
<p>
If this *LibMaterialDefs* already contains a *MaterialDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.New">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3294:3354#L99">New</a></h3>
				<pre>func (me *LibMaterialDefs) New(id string) (def *MaterialDef)</pre>
				<p>
Creates a new *MaterialDef* definition with the specified *ID* and returns it, but does not add it to this *LibMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.Remove">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3475:3519#L102">Remove</a></h3>
				<pre>func (me *LibMaterialDefs) Remove(id string)</pre>
				<p>
Removes the *MaterialDef* with the specified *ID* from this *LibMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.SyncChanges">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3862:3902#L107">SyncChanges</a></h3>
				<pre>func (me *LibMaterialDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibMaterialDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibMaterialDefs* library or its *MaterialDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibNodeDefs">type <a href="/target/node.gt.go?s=2320:2582#L82">LibNodeDefs</a></h2>
			<pre>type LibNodeDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*NodeDef
}</pre>
			<p>
A library that contains *NodeDef*s associated by their *ID*. To create a new *LibNodeDefs* library, ONLY
use the *LibsNodeDef.New()* or *LibsNodeDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibNodeDefs.Add">func (*LibNodeDefs) <a href="/target/node.gt.go?s=2906:2957#L98">Add</a></h3>
				<pre>func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</pre>
				<p>
Adds the specified *NodeDef* definition to this *LibNodeDefs*, and returns it.
</p>
<p>
If this *LibNodeDefs* already contains a *NodeDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.AddNew">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3273:3322#L109">AddNew</a></h3>
				<pre>func (me *LibNodeDefs) AddNew(id string) *NodeDef</pre>
				<p>
Creates a new *NodeDef* definition with the specified *ID*, adds it to this *LibNodeDefs*, and returns it.
</p>
<p>
If this *LibNodeDefs* already contains a *NodeDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.New">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3475:3527#L112">New</a></h3>
				<pre>func (me *LibNodeDefs) New(id string) (def *NodeDef)</pre>
				<p>
Creates a new *NodeDef* definition with the specified *ID* and returns it, but does not add it to this *LibNodeDefs*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Remove">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3636:3676#L115">Remove</a></h3>
				<pre>func (me *LibNodeDefs) Remove(id string)</pre>
				<p>
Removes the *NodeDef* with the specified *ID* from this *LibNodeDefs*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.SyncChanges">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4007:4043#L120">SyncChanges</a></h3>
				<pre>func (me *LibNodeDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibNodeDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibNodeDefs* library or its *NodeDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibVisualSceneDefs">type <a href="/target/visualscene.gt.go?s=1957:2233#L66">LibVisualSceneDefs</a></h2>
			<pre>type LibVisualSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*VisualSceneDef
}</pre>
			<p>
A library that contains *VisualSceneDef*s associated by their *ID*. To create a new *LibVisualSceneDefs* library, ONLY
use the *LibsVisualSceneDef.New()* or *LibsVisualSceneDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibVisualSceneDefs.Add">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=2613:2685#L82">Add</a></h3>
				<pre>func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</pre>
				<p>
Adds the specified *VisualSceneDef* definition to this *LibVisualSceneDefs*, and returns it.
</p>
<p>
If this *LibVisualSceneDefs* already contains a *VisualSceneDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.AddNew">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3029:3092#L93">AddNew</a></h3>
				<pre>func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</pre>
				<p>
Creates a new *VisualSceneDef* definition with the specified *ID*, adds it to this *LibVisualSceneDefs*, and returns it.
</p>
<p>
If this *LibVisualSceneDefs* already contains a *VisualSceneDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.New">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3259:3325#L96">New</a></h3>
				<pre>func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</pre>
				<p>
Creates a new *VisualSceneDef* definition with the specified *ID* and returns it, but does not add it to this *LibVisualSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Remove">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3455:3502#L99">Remove</a></h3>
				<pre>func (me *LibVisualSceneDefs) Remove(id string)</pre>
				<p>
Removes the *VisualSceneDef* with the specified *ID* from this *LibVisualSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.SyncChanges">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3854:3897#L104">SyncChanges</a></h3>
				<pre>func (me *LibVisualSceneDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibVisualSceneDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibVisualSceneDefs* library or its *VisualSceneDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibsAnimationClipDef">type <a href="/target/animationclip.gt.go?s=1201:1259#L40">LibsAnimationClipDef</a></h2>
			<pre>type LibsAnimationClipDef map[string]*LibAnimationClipDefs</pre>
			<p>
The underlying type of the global *AllAnimationClipDefLibs* variable: a *map* collection that contains
*LibAnimationClipDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsAnimationClipDef.AddNew">func (LibsAnimationClipDef) <a href="/target/animationclip.gt.go?s=1535:1611#L45">AddNew</a></h3>
				<pre>func (me LibsAnimationClipDef) AddNew(id string) (lib *LibAnimationClipDefs)</pre>
				<p>
Creates a new *LibAnimationClipDefs* library with the specified *ID*, adds it to this *LibsAnimationClipDef*, and returns it.
</p>
<p>
If this *LibsAnimationClipDef* already contains a *LibAnimationClipDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsAnimationDef">type <a href="/target/animation.gt.go?s=1437:1487#L62">LibsAnimationDef</a></h2>
			<pre>type LibsAnimationDef map[string]*LibAnimationDefs</pre>
			<p>
The underlying type of the global *AllAnimationDefLibs* variable: a *map* collection that contains
*LibAnimationDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsAnimationDef.AddNew">func (LibsAnimationDef) <a href="/target/animation.gt.go?s=1747:1815#L67">AddNew</a></h3>
				<pre>func (me LibsAnimationDef) AddNew(id string) (lib *LibAnimationDefs)</pre>
				<p>
Creates a new *LibAnimationDefs* library with the specified *ID*, adds it to this *LibsAnimationDef*, and returns it.
</p>
<p>
If this *LibsAnimationDef* already contains a *LibAnimationDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsCameraDef">type <a href="/target/camera.gt.go?s=1856:1900#L69">LibsCameraDef</a></h2>
			<pre>type LibsCameraDef map[string]*LibCameraDefs</pre>
			<p>
The underlying type of the global *AllCameraDefLibs* variable: a *map* collection that contains
*LibCameraDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsCameraDef.AddNew">func (LibsCameraDef) <a href="/target/camera.gt.go?s=2148:2210#L74">AddNew</a></h3>
				<pre>func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</pre>
				<p>
Creates a new *LibCameraDefs* library with the specified *ID*, adds it to this *LibsCameraDef*, and returns it.
</p>
<p>
If this *LibsCameraDef* already contains a *LibCameraDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsControllerDef">type <a href="/target/controller.gt.go?s=1798:1850#L83">LibsControllerDef</a></h2>
			<pre>type LibsControllerDef map[string]*LibControllerDefs</pre>
			<p>
The underlying type of the global *AllControllerDefLibs* variable: a *map* collection that contains
*LibControllerDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsControllerDef.AddNew">func (LibsControllerDef) <a href="/target/controller.gt.go?s=2114:2184#L88">AddNew</a></h3>
				<pre>func (me LibsControllerDef) AddNew(id string) (lib *LibControllerDefs)</pre>
				<p>
Creates a new *LibControllerDefs* library with the specified *ID*, adds it to this *LibsControllerDef*, and returns it.
</p>
<p>
If this *LibsControllerDef* already contains a *LibControllerDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsEffectDef">type <a href="/target/effect.gt.go?s=1339:1383#L51">LibsEffectDef</a></h2>
			<pre>type LibsEffectDef map[string]*LibEffectDefs</pre>
			<p>
The underlying type of the global *AllEffectDefLibs* variable: a *map* collection that contains
*LibEffectDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsEffectDef.AddNew">func (LibsEffectDef) <a href="/target/effect.gt.go?s=1631:1693#L56">AddNew</a></h3>
				<pre>func (me LibsEffectDef) AddNew(id string) (lib *LibEffectDefs)</pre>
				<p>
Creates a new *LibEffectDefs* library with the specified *ID*, adds it to this *LibsEffectDef*, and returns it.
</p>
<p>
If this *LibsEffectDef* already contains a *LibEffectDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsFormulaDef">type <a href="/target/formula.gt.go?s=1266:1312#L53">LibsFormulaDef</a></h2>
			<pre>type LibsFormulaDef map[string]*LibFormulaDefs</pre>
			<p>
The underlying type of the global *AllFormulaDefLibs* variable: a *map* collection that contains
*LibFormulaDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsFormulaDef.AddNew">func (LibsFormulaDef) <a href="/target/formula.gt.go?s=1564:1628#L58">AddNew</a></h3>
				<pre>func (me LibsFormulaDef) AddNew(id string) (lib *LibFormulaDefs)</pre>
				<p>
Creates a new *LibFormulaDefs* library with the specified *ID*, adds it to this *LibsFormulaDef*, and returns it.
</p>
<p>
If this *LibsFormulaDef* already contains a *LibFormulaDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsGeometryDef">type <a href="/target/geometry.gt.go?s=2222:2270#L106">LibsGeometryDef</a></h2>
			<pre>type LibsGeometryDef map[string]*LibGeometryDefs</pre>
			<p>
The underlying type of the global *AllGeometryDefLibs* variable: a *map* collection that contains
*LibGeometryDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsGeometryDef.AddNew">func (LibsGeometryDef) <a href="/target/geometry.gt.go?s=2526:2592#L111">AddNew</a></h3>
				<pre>func (me LibsGeometryDef) AddNew(id string) (lib *LibGeometryDefs)</pre>
				<p>
Creates a new *LibGeometryDefs* library with the specified *ID*, adds it to this *LibsGeometryDef*, and returns it.
</p>
<p>
If this *LibsGeometryDef* already contains a *LibGeometryDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsImageDef">type <a href="/target/image.gt.go?s=1754:1796#L65">LibsImageDef</a></h2>
			<pre>type LibsImageDef map[string]*LibImageDefs</pre>
			<p>
The underlying type of the global *AllImageDefLibs* variable: a *map* collection that contains
*LibImageDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsImageDef.AddNew">func (LibsImageDef) <a href="/target/image.gt.go?s=2040:2100#L70">AddNew</a></h3>
				<pre>func (me LibsImageDef) AddNew(id string) (lib *LibImageDefs)</pre>
				<p>
Creates a new *LibImageDefs* library with the specified *ID*, adds it to this *LibsImageDef*, and returns it.
</p>
<p>
If this *LibsImageDef* already contains a *LibImageDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsMaterialDef">type <a href="/target/material.gt.go?s=1310:1358#L48">LibsMaterialDef</a></h2>
			<pre>type LibsMaterialDef map[string]*LibMaterialDefs</pre>
			<p>
The underlying type of the global *AllMaterialDefLibs* variable: a *map* collection that contains
*LibMaterialDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsMaterialDef.AddNew">func (LibsMaterialDef) <a href="/target/material.gt.go?s=1614:1680#L53">AddNew</a></h3>
				<pre>func (me LibsMaterialDef) AddNew(id string) (lib *LibMaterialDefs)</pre>
				<p>
Creates a new *LibMaterialDefs* library with the specified *ID*, adds it to this *LibsMaterialDef*, and returns it.
</p>
<p>
If this *LibsMaterialDef* already contains a *LibMaterialDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsNodeDef">type <a href="/target/node.gt.go?s=1635:1675#L61">LibsNodeDef</a></h2>
			<pre>type LibsNodeDef map[string]*LibNodeDefs</pre>
			<p>
The underlying type of the global *AllNodeDefLibs* variable: a *map* collection that contains
*LibNodeDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsNodeDef.AddNew">func (LibsNodeDef) <a href="/target/node.gt.go?s=1915:1973#L66">AddNew</a></h3>
				<pre>func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</pre>
				<p>
Creates a new *LibNodeDefs* library with the specified *ID*, adds it to this *LibsNodeDef*, and returns it.
</p>
<p>
If this *LibsNodeDef* already contains a *LibNodeDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsVisualSceneDef">type <a href="/target/visualscene.gt.go?s=1167:1221#L45">LibsVisualSceneDef</a></h2>
			<pre>type LibsVisualSceneDef map[string]*LibVisualSceneDefs</pre>
			<p>
The underlying type of the global *AllVisualSceneDefLibs* variable: a *map* collection that contains
*LibVisualSceneDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsVisualSceneDef.AddNew">func (LibsVisualSceneDef) <a href="/target/visualscene.gt.go?s=1489:1561#L50">AddNew</a></h3>
				<pre>func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</pre>
				<p>
Creates a new *LibVisualSceneDefs* library with the specified *ID*, adds it to this *LibsVisualSceneDef*, and returns it.
</p>
<p>
If this *LibsVisualSceneDef* already contains a *LibVisualSceneDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="ListBools">type <a href="/target/types.go?s=536:587#L37">ListBools</a></h2>
			<pre>type ListBools struct {
    HasID
    HasName
    B []bool
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ListFloats">type <a href="/target/types.go?s=589:644#L43">ListFloats</a></h2>
			<pre>type ListFloats struct {
    HasID
    HasName
    F []float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ListInts">type <a href="/target/types.go?s=646:697#L49">ListInts</a></h2>
			<pre>type ListInts struct {
    HasID
    HasName
    I []int64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ListStrings">type <a href="/target/types.go?s=699:754#L55">ListStrings</a></h2>
			<pre>type ListStrings struct {
    HasID
    HasName
    S []string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="MaterialDef">type <a href="/target/material.gt.go?s=124:160#L1">MaterialDef</a></h2>
			<pre>type MaterialDef struct {
    BaseDef
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry and screen-space image processing.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MaterialInst">type <a href="/target/material.gt.go?s=247:361#L2">MaterialInst</a></h2>
			<pre>type MaterialInst struct {
    BaseInst

    <span class="comment">//	The material definition referenced by this instance.</span>
    Def *MaterialDef
}</pre>
			<p>
An instance referencing a material definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshData">type <a href="/target/meshdata.go?s=1164:1387#L40">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">//	Vertex positions</span>
    Positions []MeshVertAtt3
    <span class="comment">//	Vertex texture coordinates</span>
    TexCoords []MeshVertAtt2
    <span class="comment">//	Vertex normals</span>
    Normals []MeshVertAtt3
    <span class="comment">//	Indexed triangle definitions</span>
    Faces []MeshFace3
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="NewMeshData">func <a href="/target/meshdata.go?s=1443:1476#L52">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
				
				<h3 id="MeshData.AddFaces">func (*MeshData) <a href="/target/meshdata.go?s=1554:1602#L58">AddFaces</a></h3>
				<pre>func (me *MeshData) AddFaces(faces ...MeshFace3)</pre>
				<p>
Adds all specified Faces to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddNormals">func (*MeshData) <a href="/target/meshdata.go?s=1865:1920#L68">AddNormals</a></h3>
				<pre>func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</pre>
				<p>
Adds all the specified Normals to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddPositions">func (*MeshData) <a href="/target/meshdata.go?s=1697:1756#L63">AddPositions</a></h3>
				<pre>func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</pre>
				<p>
Adds all specified Positions to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddTexCoords">func (*MeshData) <a href="/target/meshdata.go?s=2025:2084#L73">AddTexCoords</a></h3>
				<pre>func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</pre>
				<p>
Adds all the specified TexCoords to this MeshData.
</p>

				
				
			
		
			
			
			<h2 id="MeshFace3">type <a href="/target/meshdata.go?s=140:166#L1">MeshFace3</a></h2>
			<pre>type MeshFace3 [3]MeshVert</pre>
			<p>
Represents an indexed triangle.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/meshdata.go?s=41:103#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Temporary concoction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRaw">type <a href="/target/meshdata.go?s=255:400#L1">MeshRaw</a></h2>
			<pre>type MeshRaw struct {
    <span class="comment">//	Raw vertices</span>
    MeshVerts []float32
    <span class="comment">//	Vertex indices</span>
    Indices []uint32
    <span class="comment">//	Raw face definitions</span>
    Faces []*MeshRawFace
}</pre>
			<p>
Represents semi-processed loaded mesh data &#34;almost ready&#34; to core.Mesh.GpuUpload().
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRawFace">type <a href="/target/meshdata.go?s=450:532#L10">MeshRawFace</a></h2>
			<pre>type MeshRawFace struct {
    <span class="comment">//	Indices of the triangle corners</span>
    Entries [3]uint32
}</pre>
			<p>
Represents a triangle face inside a MeshRaw.
</p>


			

			

			

			
				
				<h3 id="NewMeshRawFace">func <a href="/target/meshdata.go?s=591:630#L16">NewMeshRawFace</a></h3>
				<pre>func NewMeshRawFace() (me *MeshRawFace)</pre>
				<p>
Initializes and returns a new *MeshRawFace* instance.
</p>

				
			

			
		
			
			
			<h2 id="MeshVert">type <a href="/target/meshdata.go?s=698:885#L22">MeshVert</a></h2>
			<pre>type MeshVert struct {
    <span class="comment">//	Index of the vertex position</span>
    PosIndex uint32

    <span class="comment">//	Index of the texture-coordinate.</span>
    TexCoordIndex uint32

    <span class="comment">//	Index of the vertex normal.</span>
    NormalIndex uint32
}</pre>
			<p>
Represents an indexed vertex.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt2">type <a href="/target/meshdata.go?s=974:1002#L34">MeshVertAtt2</a></h2>
			<pre>type MeshVertAtt2 [2]float32</pre>
			<p>
Represents a 2-component vertex attribute (such as for example texture-coordinates)
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt3">type <a href="/target/meshdata.go?s=1086:1114#L37">MeshVertAtt3</a></h2>
			<pre>type MeshVertAtt3 [3]float32</pre>
			<p>
Represents a 3-component vertex attribute (such as for example vertex-normals)
</p>


			

			

			

			

			
		
			
			
			<h2 id="NodeDef">type <a href="/target/node.gt.go?s=271:554#L1">NodeDef</a></h2>
			<pre>type NodeDef struct {
    BaseDef
    HasSid

    <span class="comment">//	The names of the layers to which this Node belongs.</span>
    Layers map[string]bool

    <span class="comment">//	Allows the Node to recursively define hierarchy.</span>
    NodeDefs []*NodeDef

    <span class="comment">//	Allows the Node to instantiate a hierarchy of other Nodes.</span>
    NodeInsts []*NodeInst
}</pre>
			<p>
A Node embodies the hierarchical relationship of elements in a Scene by declaring a point of
interest in a Scene. A Node denotes one point on a branch of the Scene graph. The Node is
essentially the root of a sub-graph of the entire Scene graph.
</p>


			

			

			

			

			
		
			
			
			<h2 id="NodeInst">type <a href="/target/node.gt.go?s=664:766#L15">NodeInst</a></h2>
			<pre>type NodeInst struct {
    BaseInst

    <span class="comment">//	The Node definition referenced by this instance.</span>
    Def *NodeDef
}</pre>
			<p>
An instance referencing a Node definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Param">type <a href="/target/common.go?s=1333:1405#L78">Param</a></h2>
			<pre>type Param struct {
    HasName
    HasSid
    Semantic string
    Type     string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamBool">type <a href="/target/types.go?s=756:803#L61">ParamBool</a></h2>
			<pre>type ParamBool struct {
    B   bool
    Ref string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamDef">type <a href="/target/common.go?s=1407:1458#L85">ParamDef</a></h2>
			<pre>type ParamDef struct {
    HasSid
    Value interface{}
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamDefs">type <a href="/target/common.go?s=1460:1495#L90">ParamDefs</a></h2>
			<pre>type ParamDefs map[string]*ParamDef</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamFloat">type <a href="/target/types.go?s=805:856#L66">ParamFloat</a></h2>
			<pre>type ParamFloat struct {
    F   float64
    Ref string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamInst">type <a href="/target/common.go?s=1497:1555#L92">ParamInst</a></h2>
			<pre>type ParamInst struct {
    Ref   string
    Value interface{}
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamInt">type <a href="/target/types.go?s=858:905#L71">ParamInt</a></h2>
			<pre>type ParamInt struct {
    I   int64
    Ref string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamScopedFloat">type <a href="/target/types.go?s=907:968#L76">ParamScopedFloat</a></h2>
			<pre>type ParamScopedFloat struct {
    F   ScopedFloat
    Ref string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamString">type <a href="/target/types.go?s=970:1021#L81">ParamString</a></h2>
			<pre>type ParamString struct {
    S   string
    Ref string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ParamUint">type <a href="/target/types.go?s=1023:1072#L86">ParamUint</a></h2>
			<pre>type ParamUint struct {
    U   uint64
    Ref string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Scene">type <a href="/target/scene.go?s=221:325#L1">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	The Visual Scene associated with this Scene.</span>
    VisualSceneInst *VisualSceneInst
}</pre>
			<p>
Declares a complete, self-contained base of a Scene hierarchy or Scene graph. Currently just defined by a
Visual Scene, later to be augmented by optional &#34;kinematics scenes&#34; and/or &#34;physics scenes&#34;.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ScopedFloat">type <a href="/target/types.go?s=1074:1120#L91">ScopedFloat</a></h2>
			<pre>type ScopedFloat struct {
    HasSid
    F float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Source">type <a href="/target/source.go?s=125:410#L1">Source</a></h2>
			<pre>type Source struct {
    BaseDef
    Data struct {
        Bools   *ListBools
        Floats  *ListFloats
        IdRefs  *ListStrings
        Ints    *ListInts
        Names   *ListStrings
        SidRefs *ListStrings
        Tokens  *ListStrings
    }
    TechniqueCommon struct {
        Accessor *SourceAccessor
    }
    Techniques []*Technique
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="SourceAccessor">type <a href="/target/source.go?s=16:123#L1">SourceAccessor</a></h2>
			<pre>type SourceAccessor struct {
    Count  uint64
    Offset uint64
    Source string
    Stride uint64
    Params []*Param
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Sources">type <a href="/target/source.go?s=412:443#L18">Sources</a></h2>
			<pre>type Sources map[string]*Source</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Technique">type <a href="/target/common.go?s=1557:1619#L97">Technique</a></h2>
			<pre>type Technique struct {
    Profile string
    Data    interface{}
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="VisualSceneDef">type <a href="/target/visualscene.gt.go?s=16:55#L1">VisualSceneDef</a></h2>
			<pre>type VisualSceneDef struct {
    BaseDef
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="VisualSceneInst">type <a href="/target/visualscene.gt.go?s=95:158#L1">VisualSceneInst</a></h2>
			<pre>type VisualSceneInst struct {
    BaseInst

    Def *VisualSceneDef
}</pre>
			

			

			

			

			

			
		
		</div>
	

	







	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="collada/">collada</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>
	


		</div></div>
	</body>
</html>