<html>
	<head>
		<title>Package github.com/go3d/go-ngine/assets</title>
		<meta charset="UTF-8" />
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<link type="text/css" rel="stylesheet" href="http://golang.org/doc/style.css" />
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
		<script type="text/javascript" src="http://golang.org/doc/godocs.js"></script>
	</head>
	<body>
		<div id="page" class="wide">
		<div class="container">
		<h1>Package github.com/go3d/go-ngine/assets</h1>
		<div id="nav"></div>
		<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/go3d/go-ngine/assets"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index">Index</a></dd>
			
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
The *assets* package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.
</p>
<p>
________
</p>
<p>
First off, the go:ngine 3 RULES of bugless(er) development:
</p>
<p>
1. you do NOT set exported fields directly, those are provided for simplified read-access. If a field is
meant to be modifiable, there will be a *SetFoo()* method or it will be documented explicitly as directly
modifiable, but such instances will be rare.
</p>
<p>
2. you do NOT instantiate exported struct types directly, as in &#34;new(ImageDef)&#34; or &#34;&amp;ImageDef {}&#34;. Many of
those are exported only for documentation, but are to be instantiated only inside the go:ngine package.
For types to be instantiated by package-external code (ie. your code), go:ngine packages provide constructor
functions -- often in collections, ie. img := ImageDefs.New(&#34;id&#34;) instead of, say, img := NewImageDef(&#34;id&#34;).
</p>
<p>
3. Those 2 are *default* assumptions and modes of operation -- there are a few &#34;if you know what you&#39;re
doing&#34; exemptions and those are (or will be) explicitly documented as such.
</p>
<p>
________
</p>
<p>
The *assets* package provides the (de)serializable, logic-less base data structures for all resource types
used in a go:ngine app.
These data structures only describe resource definitions and instances, but do not provide
any specific logic or algorithms, such as physics or visual rendering.
</p>
<p>
Context: any go:ngine app uses a variety of both simple and complex resource types, including for
example geometry definitions, image textures, material and light descriptions and many others.
</p>
<p>
While for all these resource types, the go:ngine *core* package manages their respective run-time
representation in its entirety,	some basic part of that representation is &#34;merely descriptive&#34; and
should be readable from or writable to a binary stream (&#34;design-time&#34;). That &#34;merely descriptive&#34;
sub-set of resource definitions is fully contained in this go:ngine *assets* package and thus decoupled
from the go:ngine *core* package.
</p>
<p>
This *assets* package thus allows for things such as server-side procedural asset generators, networked
resource streaming or simple custom asset-import/export/conversion tools, all of which shouldn&#39;t have to
needlessly depend on the graphics, windowing etc. stacks.
</p>
<p>
NOTE: there are essentially TWO distinct &#34;modes&#34; or use-cases in which the *assets* package is active:
</p>
<p>
1. in graphics-independent, server-side or non-interactive &#34;toolage&#34;, dealing only with the raw resource
data where it can be generated, loaded, stored, manipulated at will with no particular repercussions.
</p>
<p>
2. in an interactive graphical go:ngine app that also has the *core* package loaded:
</p>
<p>
All &#34;Sync&#34;-related functions pertain to use-case #2, where the *assets* package essentially becomes the
live repository for all resource definitions loaded, used, or manipulated by the *core* package at runtime.
So now every image definition in *assets* may have a corresponding GPU-bound texture object in *core*, every
*assets* mesh definition may be bound to a *core* *MeshBuffer*, etc.
</p>
<p>
Structure: generally speaking, all resource types are organized in a consistent fashion as follows ---
users familiar with the COLLADA format will notice a stark resemblance in terminology and resource organization:
</p>
<p>
1. First, there is a *FooDef* struct for the one-time definition of a unique resource:
GeometryMeshDef, ImageDef, LightDef, MaterialDef etc.
</p>
<p>
2. Next, there is a smaller *FooInst* struct for handling many individual (sometimes parameterized) instances of
an *FooDef*: GeometryMeshInst, ImageInst, LightInst, MaterialInst etc.
</p>
<p>
3. Finally, there is a light-weight *LibFooDefs* struct type (based on a *map* collection) containing Defs
associated with their ID: LibGeometryMeshDefs, LibImageDefs, LibLightDefs, LibMaterialDefs etc.
</p>
<p>
4. The package also provides a pre-initialized global *FooDefs* variable for each such Lib type, in simple apps
considered the &#34;default / main / only Lib you&#39;ll need&#34;: GeometryMeshDefs, ImageDefs, LightDefs, MaterialDefs etc.
</p>
<p>
5. For more complex use-cases, you can also organize multiple libs for any given resource type in the global
*AllFooDefLibs* variable, essentially a *map* collection of Libs: AllGeometryMeshDefLibs (of type
LibsGeometryMeshDef), AllImageDefLibs (of type LibsImageDef), AllLightDefLibs (of type LibsLightDef),
AllMaterialDefLibs (of type LibsMaterialDef) etc.
</p>
<p>
Any exported types in this package not following the above pattern (such as MeshData etc.) should be
considered &#34;auxiliary helpers&#34; rather than primary / &#34;first-class&#34; resource types.
</p>

			</div>
		</div>
		
	
		<h2 id="pkg-index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#SyncChanges">func SyncChanges()</a></dd>
			
			
				
				<dd><a href="#Base">type Base</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SetDirty">func (me *Base) SetDirty()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Base.SyncChanges">func (me *Base) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#BaseDef">type BaseDef</a></dd>
				
				
			
				
				<dd><a href="#BaseInst">type BaseInst</a></dd>
				
				
			
				
				<dd><a href="#BaseLib">type BaseLib</a></dd>
				
				
			
				
				<dd><a href="#CameraDef">type CameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.NewInst">func (me *CameraDef) NewInst(id string) (inst *CameraInst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetFovX">func (me *CameraDef) SetFovX(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetFovY">func (me *CameraDef) SetFovY(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetMagX">func (me *CameraDef) SetMagX(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetMagY">func (me *CameraDef) SetMagY(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetOrtho">func (me *CameraDef) SetOrtho(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetZfar">func (me *CameraDef) SetZfar(v float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CameraDef.SetZnear">func (me *CameraDef) SetZnear(v float64)</a></dd>
				
			
				
				<dd><a href="#CameraInst">type CameraInst</a></dd>
				
				
			
				
				<dd><a href="#EffectDef">type EffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EffectDef.NewInst">func (me *EffectDef) NewInst(id string) (inst *EffectInst)</a></dd>
				
			
				
				<dd><a href="#EffectInst">type EffectInst</a></dd>
				
				
			
				
				<dd><a href="#FxParamDef">type FxParamDef</a></dd>
				
				
			
				
				<dd><a href="#FxParamDefs">type FxParamDefs</a></dd>
				
				
			
				
				<dd><a href="#HasID">type HasID</a></dd>
				
				
			
				
				<dd><a href="#HasName">type HasName</a></dd>
				
				
			
				
				<dd><a href="#HasSid">type HasSid</a></dd>
				
				
			
				
				<dd><a href="#ImageDef">type ImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ImageDef.NewInst">func (me *ImageDef) NewInst(id string) (inst *ImageInst)</a></dd>
				
			
				
				<dd><a href="#ImageInitFrom">type ImageInitFrom</a></dd>
				
				
			
				
				<dd><a href="#ImageInst">type ImageInst</a></dd>
				
				
			
				
				<dd><a href="#LibCameraDefs">type LibCameraDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Add">func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.AddNew">func (me *LibCameraDefs) AddNew(id string) *CameraDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.New">func (me *LibCameraDefs) New(id string) (def *CameraDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.Remove">func (me *LibCameraDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibCameraDefs.SyncChanges">func (me *LibCameraDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibEffectDefs">type LibEffectDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.Add">func (me *LibEffectDefs) Add(d *EffectDef) (n *EffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.AddNew">func (me *LibEffectDefs) AddNew(id string) *EffectDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.New">func (me *LibEffectDefs) New(id string) (def *EffectDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.Remove">func (me *LibEffectDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibEffectDefs.SyncChanges">func (me *LibEffectDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibImageDefs">type LibImageDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.Add">func (me *LibImageDefs) Add(d *ImageDef) (n *ImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.AddNew">func (me *LibImageDefs) AddNew(id string) *ImageDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.New">func (me *LibImageDefs) New(id string) (def *ImageDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.Remove">func (me *LibImageDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibImageDefs.SyncChanges">func (me *LibImageDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibMaterialDefs">type LibMaterialDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.Add">func (me *LibMaterialDefs) Add(d *MaterialDef) (n *MaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.AddNew">func (me *LibMaterialDefs) AddNew(id string) *MaterialDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.New">func (me *LibMaterialDefs) New(id string) (def *MaterialDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.Remove">func (me *LibMaterialDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibMaterialDefs.SyncChanges">func (me *LibMaterialDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibNodeDefs">type LibNodeDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Add">func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.AddNew">func (me *LibNodeDefs) AddNew(id string) *NodeDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.New">func (me *LibNodeDefs) New(id string) (def *NodeDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.Remove">func (me *LibNodeDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibNodeDefs.SyncChanges">func (me *LibNodeDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibVisualSceneDefs">type LibVisualSceneDefs</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Add">func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.AddNew">func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.New">func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.Remove">func (me *LibVisualSceneDefs) Remove(id string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LibVisualSceneDefs.SyncChanges">func (me *LibVisualSceneDefs) SyncChanges()</a></dd>
				
			
				
				<dd><a href="#LibsCameraDef">type LibsCameraDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsCameraDef.AddNew">func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</a></dd>
				
			
				
				<dd><a href="#LibsEffectDef">type LibsEffectDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsEffectDef.AddNew">func (me LibsEffectDef) AddNew(id string) (lib *LibEffectDefs)</a></dd>
				
			
				
				<dd><a href="#LibsImageDef">type LibsImageDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsImageDef.AddNew">func (me LibsImageDef) AddNew(id string) (lib *LibImageDefs)</a></dd>
				
			
				
				<dd><a href="#LibsMaterialDef">type LibsMaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsMaterialDef.AddNew">func (me LibsMaterialDef) AddNew(id string) (lib *LibMaterialDefs)</a></dd>
				
			
				
				<dd><a href="#LibsNodeDef">type LibsNodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsNodeDef.AddNew">func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</a></dd>
				
			
				
				<dd><a href="#LibsVisualSceneDef">type LibsVisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LibsVisualSceneDef.AddNew">func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</a></dd>
				
			
				
				<dd><a href="#MaterialDef">type MaterialDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MaterialDef.NewInst">func (me *MaterialDef) NewInst(id string) (inst *MaterialInst)</a></dd>
				
			
				
				<dd><a href="#MaterialInst">type MaterialInst</a></dd>
				
				
			
				
				<dd><a href="#MeshData">type MeshData</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshData">func NewMeshData() (me *MeshData)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddFaces">func (me *MeshData) AddFaces(faces ...MeshFace3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddNormals">func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddPositions">func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MeshData.AddTexCoords">func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</a></dd>
				
			
				
				<dd><a href="#MeshFace3">type MeshFace3</a></dd>
				
				
			
				
				<dd><a href="#MeshProvider">type MeshProvider</a></dd>
				
				
			
				
				<dd><a href="#MeshRaw">type MeshRaw</a></dd>
				
				
			
				
				<dd><a href="#MeshRawFace">type MeshRawFace</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMeshRawFace">func NewMeshRawFace() (me *MeshRawFace)</a></dd>
				
				
			
				
				<dd><a href="#MeshVert">type MeshVert</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt2">type MeshVertAtt2</a></dd>
				
				
			
				
				<dd><a href="#MeshVertAtt3">type MeshVertAtt3</a></dd>
				
				
			
				
				<dd><a href="#NodeDef">type NodeDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeDef.NewInst">func (me *NodeDef) NewInst(id string) (inst *NodeInst)</a></dd>
				
			
				
				<dd><a href="#NodeInst">type NodeInst</a></dd>
				
				
			
				
				<dd><a href="#Sampler">type Sampler</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSampler">func NewSampler() (me *Sampler)</a></dd>
				
				
			
				
				<dd><a href="#SamplerFiltering">type SamplerFiltering</a></dd>
				
				
			
				
				<dd><a href="#SamplerWrapping">type SamplerWrapping</a></dd>
				
				
			
				
				<dd><a href="#Scene">type Scene</a></dd>
				
				
			
				
				<dd><a href="#VisualSceneDef">type VisualSceneDef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VisualSceneDef.NewInst">func (me *VisualSceneDef) NewInst(id string) (inst *VisualSceneInst)</a></dd>
				
			
				
				<dd><a href="#VisualSceneInst">type VisualSceneInst</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="/target/assets.go">assets.go</a>
			
				<a href="/target/base.go">base.go</a>
			
				<a href="/target/camera.gt.go">camera.gt.go</a>
			
				<a href="/target/common.go">common.go</a>
			
				<a href="/target/doc.go">doc.go</a>
			
				<a href="/target/effect.gt.go">effect.gt.go</a>
			
				<a href="/target/image.gt.go">image.gt.go</a>
			
				<a href="/target/material.gt.go">material.gt.go</a>
			
				<a href="/target/meshdata.go">meshdata.go</a>
			
				<a href="/target/node.gt.go">node.gt.go</a>
			
				<a href="/target/sampler.go">sampler.go</a>
			
				<a href="/target/scene.go">scene.go</a>
			
				<a href="/target/visualscene.gt.go">visualscene.gt.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="pkg-constants">Constants</h2>
			
				<pre>const (
    SAMPLER_FILTER_NONE        = 0
    SAMPLER_FILTER_NEAREST     = 0x2600
    SAMPLER_FILTER_LINEAR      = 0x2601
    SAMPLER_FILTER_ANISOTROPIC = 1

    SAMPLER_WRAP_WRAP        = 0x2901
    SAMPLER_WRAP_MIRROR      = 0x8370
    SAMPLER_WRAP_CLAMP       = 0x812F
    SAMPLER_WRAP_BORDER      = 0x812D
    SAMPLER_WRAP_MIRROR_ONCE = 0
)</pre>
				
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<pre>var (
    <span class="comment">//	This callback, set by *core* (or your custom package), gets called before SyncChanges() proceeds with syncing.</span>
    OnBeforeSyncAll func()

    <span class="comment">//	This callback, set by *core* (or your custom package), gets called after SyncChanges() has finished syncing.</span>
    OnAfterSyncAll func()

    <span class="comment">//	Your default unit-in-meters for geometry, coordinates and transformations.</span>
    <span class="comment">//	If a unit represents:</span>
    <span class="comment">//	- a meter, set to 1;</span>
    <span class="comment">//	- a centimeter, set to 0.01;</span>
    <span class="comment">//	- a kilometer, set to 1000;</span>
    <span class="comment">//	- an inch, set to 0.02539999969303608... etc.</span>
    <span class="comment">//	The *assets* package does not support multiple different or individual per-asset units.</span>
    <span class="comment">//	This is ONLY used when importing assets that specify their own unit-in-meters, those will be re-scaled to this unit.</span>
    <span class="comment">//	If you need to customize this value, do so before populating the *assets* package&#39;s libraries.</span>
    UnitInMeters float64 = 1
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibCameraDefs* libraries associated by their *ID*.</span>
    AllCameraDefLibs = LibsCameraDef{}

    <span class="comment">//	The &#34;default&#34; *LibCameraDefs* library for *CameraDef*s.</span>
    CameraDefs = AllCameraDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibEffectDefs* libraries associated by their *ID*.</span>
    AllEffectDefLibs = LibsEffectDef{}

    <span class="comment">//	The &#34;default&#34; *LibEffectDefs* library for *EffectDef*s.</span>
    EffectDefs = AllEffectDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibImageDefs* libraries associated by their *ID*.</span>
    AllImageDefLibs = LibsImageDef{}

    <span class="comment">//	The &#34;default&#34; *LibImageDefs* library for *ImageDef*s.</span>
    ImageDefs = AllImageDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibMaterialDefs* libraries associated by their *ID*.</span>
    AllMaterialDefLibs = LibsMaterialDef{}

    <span class="comment">//	The &#34;default&#34; *LibMaterialDefs* library for *MaterialDef*s.</span>
    MaterialDefs = AllMaterialDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibNodeDefs* libraries associated by their *ID*.</span>
    AllNodeDefLibs = LibsNodeDef{}

    <span class="comment">//	The &#34;default&#34; *LibNodeDefs* library for *NodeDef*s.</span>
    NodeDefs = AllNodeDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
				<pre>var (
    DefaultSamplerFiltering = &amp;SamplerFiltering{
        Mag:           SAMPLER_FILTER_LINEAR,
        Min:           SAMPLER_FILTER_LINEAR,
        Mip:           SAMPLER_FILTER_LINEAR,
        MaxAnisotropy: 1,
    }
    DefaultSamplerWrapping = &amp;SamplerWrapping{
        BorderColor: ugfx.Rgba32{R: 0, G: 0, B: 0, A: 1},
        WrapS:       SAMPLER_WRAP_WRAP,
        WrapT:       SAMPLER_WRAP_WRAP,
        WrapP:       SAMPLER_WRAP_WRAP,
    }
)</pre>
				
			
				<pre>var (
    <span class="comment">//	A *map* collection that contains *LibVisualSceneDefs* libraries associated by their *ID*.</span>
    AllVisualSceneDefLibs = LibsVisualSceneDef{}

    <span class="comment">//	The &#34;default&#34; *LibVisualSceneDefs* library for *VisualSceneDef*s.</span>
    VisualSceneDefs = AllVisualSceneDefLibs.AddNew(&#34;&#34;)
)</pre>
				
			
		
		
			
			
			<h2 id="SyncChanges">func <a href="/target/assets.go?s=1285:1303#L28">SyncChanges</a></h2>
			<pre>func SyncChanges()</pre>
			<p>
Signals to *core* (or your custom package) that changes have been made that need to be picked up. Call this after you have made any number of changes to your Defs, Insts or Libs.
</p>

			
		
		
			
			
			<h2 id="Base">type <a href="/target/base.go?s=74:453#L1">Base</a></h2>
			<pre>type Base struct {
    <span class="comment">//	This callback, set by *core* (or your custom package), gets called by the *SyncChanges()* method.</span>
    <span class="comment">//	This is the ultimate point in the sync chain where *core* (or your custom package) picks up the changed</span>
    <span class="comment">//	contents of this *Def*, *Inst* or *Lib*. If this is a *Lib* this gets called after all *Defs* in it</span>
    <span class="comment">//	have synced.</span>
    OnSync func()
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Provides a common base for *Def*s, *Inst*s and *Lib*s.
</p>


			

			

			

			

			
				
				<h3 id="Base.SetDirty">func (*Base) <a href="/target/base.go?s=678:704#L6">SetDirty</a></h3>
				<pre>func (me *Base) SetDirty()</pre>
				<p>
You NEED to call this method if you modified this *Def* or *Inst* by setting its fields directly
(instead of using the provided *SetFoo()* methods) for your changes to be picked up by *core* (or your custom package).
</p>

				
				
			
				
				<h3 id="Base.SyncChanges">func (*Base) <a href="/target/base.go?s=1072:1101#L18">SyncChanges</a></h3>
				<pre>func (me *Base) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *Def*, *Inst* or *Lib* that need to be picked up.
Call this after you have made any number of changes to this this *Def*, *Inst* or *Lib*.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="BaseDef">type <a href="/target/base.go?s=1196:1241#L26">BaseDef</a></h2>
			<pre>type BaseDef struct {
    Base
    HasID
    HasName
}</pre>
			<p>
Provides a common base for *Def*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseInst">type <a href="/target/base.go?s=1282:1329#L33">BaseInst</a></h2>
			<pre>type BaseInst struct {
    Base
    HasName
    HasSid
}</pre>
			<p>
Provides a common base for *Inst*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="BaseLib">type <a href="/target/base.go?s=1369:1414#L40">BaseLib</a></h2>
			<pre>type BaseLib struct {
    Base
    HasID
    HasName
}</pre>
			<p>
Provides a common base for *Lib*s.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CameraDef">type <a href="/target/camera.gt.go?s=119:756#L1">CameraDef</a></h2>
			<pre>type CameraDef struct {
    BaseDef

    <span class="comment">//	Horizontal field-of-view for perspective camera.</span>
    FovX float64

    <span class="comment">//	Vertical field-of-view for perspective camera.</span>
    FovY float64

    <span class="comment">//	Horizontal magnification for orthographic camera.</span>
    MagX float64

    <span class="comment">//	Verticial magnification for orthographic camera.</span>
    MagY float64

    <span class="comment">//	The distance of the lens to the far-plane. Camera cannot see anything behind the far-plane.</span>
    Zfar float64

    <span class="comment">//	The distance of the lens to the near-plane. Camera cannot see anything in front of the near-plane.</span>
    Znear float64

    <span class="comment">//	Specifies whether this camera is an orthographic (rather than a perspective) camera.</span>
    Ortho bool
}</pre>
			<p>
Defines a perspective or orthographic camera. Only perspective cameras are supported at this point.
</p>


			

			

			

			

			
				
				<h3 id="CameraDef.NewInst">func (*CameraDef) <a href="/target/camera.gt.go?s=2694:2752#L99">NewInst</a></h3>
				<pre>func (me *CameraDef) NewInst(id string) (inst *CameraInst)</pre>
				<p>
Creates and returns a new *CameraInst* instance referencing this *CameraDef* definition.
</p>

				
				
			
				
				<h3 id="CameraDef.SetFovX">func (*CameraDef) <a href="/target/camera.gt.go?s=905:944#L23">SetFovX</a></h3>
				<pre>func (me *CameraDef) SetFovX(v float64)</pre>
				<p>
Sets the *FovX* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetFovY">func (*CameraDef) <a href="/target/camera.gt.go?s=1116:1155#L31">SetFovY</a></h3>
				<pre>func (me *CameraDef) SetFovY(v float64)</pre>
				<p>
Sets the *FovY* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetMagX">func (*CameraDef) <a href="/target/camera.gt.go?s=1327:1366#L39">SetMagX</a></h3>
				<pre>func (me *CameraDef) SetMagX(v float64)</pre>
				<p>
Sets the *MagX* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetMagY">func (*CameraDef) <a href="/target/camera.gt.go?s=1538:1577#L47">SetMagY</a></h3>
				<pre>func (me *CameraDef) SetMagY(v float64)</pre>
				<p>
Sets the *MagY* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetOrtho">func (*CameraDef) <a href="/target/camera.gt.go?s=1750:1787#L55">SetOrtho</a></h3>
				<pre>func (me *CameraDef) SetOrtho(v bool)</pre>
				<p>
Sets the *Ortho* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetZfar">func (*CameraDef) <a href="/target/camera.gt.go?s=1961:2000#L63">SetZfar</a></h3>
				<pre>func (me *CameraDef) SetZfar(v float64)</pre>
				<p>
Sets the *Zfar* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
				
				<h3 id="CameraDef.SetZnear">func (*CameraDef) <a href="/target/camera.gt.go?s=2173:2213#L71">SetZnear</a></h3>
				<pre>func (me *CameraDef) SetZnear(v float64)</pre>
				<p>
Sets the *Znear* field for this *CameraDef* and calls its *Base.SetDirty()* to register the change for syncing.
</p>

				
				
			
		
			
			
			<h2 id="CameraInst">type <a href="/target/camera.gt.go?s=2321:2429#L79">CameraInst</a></h2>
			<pre>type CameraInst struct {
    BaseInst

    <span class="comment">//	The camera definition referenced by this instance.</span>
    Def *CameraDef
}</pre>
			<p>
An instance referencing a camera definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="EffectDef">type <a href="/target/effect.gt.go?s=124:178#L1">EffectDef</a></h2>
			<pre>type EffectDef struct {
    BaseDef
    Params FxParamDefs
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry and screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="EffectDef.NewInst">func (*EffectDef) <a href="/target/effect.gt.go?s=661:719#L24">NewInst</a></h3>
				<pre>func (me *EffectDef) NewInst(id string) (inst *EffectInst)</pre>
				<p>
Creates and returns a new *EffectInst* instance referencing this *EffectDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="EffectInst">type <a href="/target/effect.gt.go?s=288:396#L4">EffectInst</a></h2>
			<pre>type EffectInst struct {
    BaseInst

    <span class="comment">//	The Effect definition referenced by this instance.</span>
    Def *EffectDef
}</pre>
			<p>
An instance referencing a Effect definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FxParamDef">type <a href="/target/common.go?s=57:150#L1">FxParamDef</a></h2>
			<pre>type FxParamDef struct {
    HasSid
    Modifier, Semantic string
    Value              interface{}
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="FxParamDefs">type <a href="/target/common.go?s=16:55#L1">FxParamDefs</a></h2>
			<pre>type FxParamDefs map[string]*FxParamDef</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasID">type <a href="/target/common.go?s=152:242#L1">HasID</a></h2>
			<pre>type HasID struct {
    <span class="comment">//	The unique identifier of this *Def*, *Inst* or *Lib*.</span>
    ID string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasName">type <a href="/target/common.go?s=244:353#L6">HasName</a></h2>
			<pre>type HasName struct {
    <span class="comment">//	The optional pretty-print name/title of this *Def*, *Inst* or *Lib*.</span>
    Name string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="HasSid">type <a href="/target/common.go?s=355:403#L11">HasSid</a></h2>
			<pre>type HasSid struct {
    <span class="comment">//	Scoped ID</span>
    Sid string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ImageDef">type <a href="/target/image.gt.go?s=477:633#L7">ImageDef</a></h2>
			<pre>type ImageDef struct {
    BaseDef
    HasSid
    <span class="comment">//	Initializes an entire Image or portions of an Image from referenced or embedded data.</span>
    InitFrom *ImageInitFrom
}</pre>
			<p>
Declares the storage for the graphical representation of an object.
</p>


			

			

			

			

			
				
				<h3 id="ImageDef.NewInst">func (*ImageDef) <a href="/target/image.gt.go?s=1123:1179#L39">NewInst</a></h3>
				<pre>func (me *ImageDef) NewInst(id string) (inst *ImageInst)</pre>
				<p>
Creates and returns a new *ImageInst* instance referencing this *ImageDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="ImageInitFrom">type <a href="/target/image.gt.go?s=57:404#L1">ImageInitFrom</a></h2>
			<pre>type ImageInitFrom struct {
    <span class="comment">//	Initializes higher MIP levels if data does not exist in a file. Defaults to true.</span>
    AutoMip bool

    <span class="comment">//	Contains the embedded image data as a sequence of bytes.</span>
    RawData []byte

    <span class="comment">//	The URL of a file from which to take initialization data. Can be a relative path</span>
    <span class="comment">//	such as &#34;walltextures/wall01.jpg&#34;.</span>
    RefUrl string
}</pre>
			<p>
Used for the ImageDef.InitFrom field.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ImageInst">type <a href="/target/image.gt.go?s=760:865#L19">ImageInst</a></h2>
			<pre>type ImageInst struct {
    BaseInst

    <span class="comment">//	The image definition referenced by this instance.</span>
    Def *ImageDef
}</pre>
			<p>
An instance referencing an Image definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LibCameraDefs">type <a href="/target/camera.gt.go?s=4047:4313#L144">LibCameraDefs</a></h2>
			<pre>type LibCameraDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*CameraDef
}</pre>
			<p>
A library that contains *CameraDef*s associated by their *ID*. To create a new *LibCameraDefs* library, ONLY
use the *LibsCameraDef.New()* or *LibsCameraDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibCameraDefs.Add">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=4653:4710#L160">Add</a></h3>
				<pre>func (me *LibCameraDefs) Add(d *CameraDef) (n *CameraDef)</pre>
				<p>
Adds the specified *CameraDef* definition to this *LibCameraDefs*, and returns it.
</p>
<p>
If this *LibCameraDefs* already contains a *CameraDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.AddNew">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5034:5087#L171">AddNew</a></h3>
				<pre>func (me *LibCameraDefs) AddNew(id string) *CameraDef</pre>
				<p>
Creates a new *CameraDef* definition with the specified *ID*, adds it to this *LibCameraDefs*, and returns it.
</p>
<p>
If this *LibCameraDefs* already contains a *CameraDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.New">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5244:5300#L174">New</a></h3>
				<pre>func (me *LibCameraDefs) New(id string) (def *CameraDef)</pre>
				<p>
Creates a new *CameraDef* definition with the specified *ID* and returns it, but does not add it to this *LibCameraDefs*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.Remove">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5415:5457#L177">Remove</a></h3>
				<pre>func (me *LibCameraDefs) Remove(id string)</pre>
				<p>
Removes the *CameraDef* with the specified *ID* from this *LibCameraDefs*.
</p>

				
				
			
				
				<h3 id="LibCameraDefs.SyncChanges">func (*LibCameraDefs) <a href="/target/camera.gt.go?s=5794:5832#L182">SyncChanges</a></h3>
				<pre>func (me *LibCameraDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibCameraDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibCameraDefs* library or its *CameraDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibEffectDefs">type <a href="/target/effect.gt.go?s=2014:2280#L69">LibEffectDefs</a></h2>
			<pre>type LibEffectDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*EffectDef
}</pre>
			<p>
A library that contains *EffectDef*s associated by their *ID*. To create a new *LibEffectDefs* library, ONLY
use the *LibsEffectDef.New()* or *LibsEffectDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibEffectDefs.Add">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=2620:2677#L85">Add</a></h3>
				<pre>func (me *LibEffectDefs) Add(d *EffectDef) (n *EffectDef)</pre>
				<p>
Adds the specified *EffectDef* definition to this *LibEffectDefs*, and returns it.
</p>
<p>
If this *LibEffectDefs* already contains a *EffectDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibEffectDefs.AddNew">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=3001:3054#L96">AddNew</a></h3>
				<pre>func (me *LibEffectDefs) AddNew(id string) *EffectDef</pre>
				<p>
Creates a new *EffectDef* definition with the specified *ID*, adds it to this *LibEffectDefs*, and returns it.
</p>
<p>
If this *LibEffectDefs* already contains a *EffectDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibEffectDefs.New">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=3211:3267#L99">New</a></h3>
				<pre>func (me *LibEffectDefs) New(id string) (def *EffectDef)</pre>
				<p>
Creates a new *EffectDef* definition with the specified *ID* and returns it, but does not add it to this *LibEffectDefs*.
</p>

				
				
			
				
				<h3 id="LibEffectDefs.Remove">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=3382:3424#L102">Remove</a></h3>
				<pre>func (me *LibEffectDefs) Remove(id string)</pre>
				<p>
Removes the *EffectDef* with the specified *ID* from this *LibEffectDefs*.
</p>

				
				
			
				
				<h3 id="LibEffectDefs.SyncChanges">func (*LibEffectDefs) <a href="/target/effect.gt.go?s=3761:3799#L107">SyncChanges</a></h3>
				<pre>func (me *LibEffectDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibEffectDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibEffectDefs* library or its *EffectDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibImageDefs">type <a href="/target/image.gt.go?s=2448:2712#L84">LibImageDefs</a></h2>
			<pre>type LibImageDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*ImageDef
}</pre>
			<p>
A library that contains *ImageDef*s associated by their *ID*. To create a new *LibImageDefs* library, ONLY
use the *LibsImageDef.New()* or *LibsImageDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibImageDefs.Add">func (*LibImageDefs) <a href="/target/image.gt.go?s=3044:3098#L100">Add</a></h3>
				<pre>func (me *LibImageDefs) Add(d *ImageDef) (n *ImageDef)</pre>
				<p>
Adds the specified *ImageDef* definition to this *LibImageDefs*, and returns it.
</p>
<p>
If this *LibImageDefs* already contains a *ImageDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.AddNew">func (*LibImageDefs) <a href="/target/image.gt.go?s=3418:3469#L111">AddNew</a></h3>
				<pre>func (me *LibImageDefs) AddNew(id string) *ImageDef</pre>
				<p>
Creates a new *ImageDef* definition with the specified *ID*, adds it to this *LibImageDefs*, and returns it.
</p>
<p>
If this *LibImageDefs* already contains a *ImageDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.New">func (*LibImageDefs) <a href="/target/image.gt.go?s=3624:3678#L114">New</a></h3>
				<pre>func (me *LibImageDefs) New(id string) (def *ImageDef)</pre>
				<p>
Creates a new *ImageDef* definition with the specified *ID* and returns it, but does not add it to this *LibImageDefs*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.Remove">func (*LibImageDefs) <a href="/target/image.gt.go?s=3790:3831#L117">Remove</a></h3>
				<pre>func (me *LibImageDefs) Remove(id string)</pre>
				<p>
Removes the *ImageDef* with the specified *ID* from this *LibImageDefs*.
</p>

				
				
			
				
				<h3 id="LibImageDefs.SyncChanges">func (*LibImageDefs) <a href="/target/image.gt.go?s=4165:4202#L122">SyncChanges</a></h3>
				<pre>func (me *LibImageDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibImageDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibImageDefs* library or its *ImageDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibMaterialDefs">type <a href="/target/material.gt.go?s=2049:2319#L67">LibMaterialDefs</a></h2>
			<pre>type LibMaterialDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*MaterialDef
}</pre>
			<p>
A library that contains *MaterialDef*s associated by their *ID*. To create a new *LibMaterialDefs* library, ONLY
use the *LibsMaterialDef.New()* or *LibsMaterialDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibMaterialDefs.Add">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=2675:2738#L83">Add</a></h3>
				<pre>func (me *LibMaterialDefs) Add(d *MaterialDef) (n *MaterialDef)</pre>
				<p>
Adds the specified *MaterialDef* definition to this *LibMaterialDefs*, and returns it.
</p>
<p>
If this *LibMaterialDefs* already contains a *MaterialDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.AddNew">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3070:3127#L94">AddNew</a></h3>
				<pre>func (me *LibMaterialDefs) AddNew(id string) *MaterialDef</pre>
				<p>
Creates a new *MaterialDef* definition with the specified *ID*, adds it to this *LibMaterialDefs*, and returns it.
</p>
<p>
If this *LibMaterialDefs* already contains a *MaterialDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.New">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3288:3348#L97">New</a></h3>
				<pre>func (me *LibMaterialDefs) New(id string) (def *MaterialDef)</pre>
				<p>
Creates a new *MaterialDef* definition with the specified *ID* and returns it, but does not add it to this *LibMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.Remove">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3469:3513#L100">Remove</a></h3>
				<pre>func (me *LibMaterialDefs) Remove(id string)</pre>
				<p>
Removes the *MaterialDef* with the specified *ID* from this *LibMaterialDefs*.
</p>

				
				
			
				
				<h3 id="LibMaterialDefs.SyncChanges">func (*LibMaterialDefs) <a href="/target/material.gt.go?s=3856:3896#L105">SyncChanges</a></h3>
				<pre>func (me *LibMaterialDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibMaterialDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibMaterialDefs* library or its *MaterialDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibNodeDefs">type <a href="/target/node.gt.go?s=2314:2576#L80">LibNodeDefs</a></h2>
			<pre>type LibNodeDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*NodeDef
}</pre>
			<p>
A library that contains *NodeDef*s associated by their *ID*. To create a new *LibNodeDefs* library, ONLY
use the *LibsNodeDef.New()* or *LibsNodeDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibNodeDefs.Add">func (*LibNodeDefs) <a href="/target/node.gt.go?s=2900:2951#L96">Add</a></h3>
				<pre>func (me *LibNodeDefs) Add(d *NodeDef) (n *NodeDef)</pre>
				<p>
Adds the specified *NodeDef* definition to this *LibNodeDefs*, and returns it.
</p>
<p>
If this *LibNodeDefs* already contains a *NodeDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.AddNew">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3267:3316#L107">AddNew</a></h3>
				<pre>func (me *LibNodeDefs) AddNew(id string) *NodeDef</pre>
				<p>
Creates a new *NodeDef* definition with the specified *ID*, adds it to this *LibNodeDefs*, and returns it.
</p>
<p>
If this *LibNodeDefs* already contains a *NodeDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.New">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3469:3521#L110">New</a></h3>
				<pre>func (me *LibNodeDefs) New(id string) (def *NodeDef)</pre>
				<p>
Creates a new *NodeDef* definition with the specified *ID* and returns it, but does not add it to this *LibNodeDefs*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.Remove">func (*LibNodeDefs) <a href="/target/node.gt.go?s=3630:3670#L113">Remove</a></h3>
				<pre>func (me *LibNodeDefs) Remove(id string)</pre>
				<p>
Removes the *NodeDef* with the specified *ID* from this *LibNodeDefs*.
</p>

				
				
			
				
				<h3 id="LibNodeDefs.SyncChanges">func (*LibNodeDefs) <a href="/target/node.gt.go?s=4001:4037#L118">SyncChanges</a></h3>
				<pre>func (me *LibNodeDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibNodeDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibNodeDefs* library or its *NodeDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibVisualSceneDefs">type <a href="/target/visualscene.gt.go?s=2384:2660#L69">LibVisualSceneDefs</a></h2>
			<pre>type LibVisualSceneDefs struct {
    BaseLib
    <span class="comment">//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT</span>
    <span class="comment">//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.</span>
    M map[string]*VisualSceneDef
}</pre>
			<p>
A library that contains *VisualSceneDef*s associated by their *ID*. To create a new *LibVisualSceneDefs* library, ONLY
use the *LibsVisualSceneDef.New()* or *LibsVisualSceneDef.AddNew()* methods.
</p>


			

			

			

			

			
				
				<h3 id="LibVisualSceneDefs.Add">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3040:3112#L85">Add</a></h3>
				<pre>func (me *LibVisualSceneDefs) Add(d *VisualSceneDef) (n *VisualSceneDef)</pre>
				<p>
Adds the specified *VisualSceneDef* definition to this *LibVisualSceneDefs*, and returns it.
</p>
<p>
If this *LibVisualSceneDefs* already contains a *VisualSceneDef* definition with the same *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.AddNew">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3456:3519#L96">AddNew</a></h3>
				<pre>func (me *LibVisualSceneDefs) AddNew(id string) *VisualSceneDef</pre>
				<p>
Creates a new *VisualSceneDef* definition with the specified *ID*, adds it to this *LibVisualSceneDefs*, and returns it.
</p>
<p>
If this *LibVisualSceneDefs* already contains a *VisualSceneDef* definition with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.New">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3686:3752#L99">New</a></h3>
				<pre>func (me *LibVisualSceneDefs) New(id string) (def *VisualSceneDef)</pre>
				<p>
Creates a new *VisualSceneDef* definition with the specified *ID* and returns it, but does not add it to this *LibVisualSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.Remove">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=3882:3929#L102">Remove</a></h3>
				<pre>func (me *LibVisualSceneDefs) Remove(id string)</pre>
				<p>
Removes the *VisualSceneDef* with the specified *ID* from this *LibVisualSceneDefs*.
</p>

				
				
			
				
				<h3 id="LibVisualSceneDefs.SyncChanges">func (*LibVisualSceneDefs) <a href="/target/visualscene.gt.go?s=4281:4324#L107">SyncChanges</a></h3>
				<pre>func (me *LibVisualSceneDefs) SyncChanges()</pre>
				<p>
Signals to *core* (or your custom package) that changes have been made to this *LibVisualSceneDefs* that need to be picked up.
Call this after you have made any number of changes to this *LibVisualSceneDefs* library or its *VisualSceneDef* definitions.
Also called by the global *SyncChanges()* function.
</p>

				
				
			
		
			
			
			<h2 id="LibsCameraDef">type <a href="/target/camera.gt.go?s=3332:3376#L123">LibsCameraDef</a></h2>
			<pre>type LibsCameraDef map[string]*LibCameraDefs</pre>
			<p>
The underlying type of the global *AllCameraDefLibs* variable: a *map* collection that contains
*LibCameraDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsCameraDef.AddNew">func (LibsCameraDef) <a href="/target/camera.gt.go?s=3624:3686#L128">AddNew</a></h3>
				<pre>func (me LibsCameraDef) AddNew(id string) (lib *LibCameraDefs)</pre>
				<p>
Creates a new *LibCameraDefs* library with the specified *ID*, adds it to this *LibsCameraDef*, and returns it.
</p>
<p>
If this *LibsCameraDef* already contains a *LibCameraDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsEffectDef">type <a href="/target/effect.gt.go?s=1299:1343#L48">LibsEffectDef</a></h2>
			<pre>type LibsEffectDef map[string]*LibEffectDefs</pre>
			<p>
The underlying type of the global *AllEffectDefLibs* variable: a *map* collection that contains
*LibEffectDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsEffectDef.AddNew">func (LibsEffectDef) <a href="/target/effect.gt.go?s=1591:1653#L53">AddNew</a></h3>
				<pre>func (me LibsEffectDef) AddNew(id string) (lib *LibEffectDefs)</pre>
				<p>
Creates a new *LibEffectDefs* library with the specified *ID*, adds it to this *LibsEffectDef*, and returns it.
</p>
<p>
If this *LibsEffectDef* already contains a *LibEffectDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsImageDef">type <a href="/target/image.gt.go?s=1748:1790#L63">LibsImageDef</a></h2>
			<pre>type LibsImageDef map[string]*LibImageDefs</pre>
			<p>
The underlying type of the global *AllImageDefLibs* variable: a *map* collection that contains
*LibImageDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsImageDef.AddNew">func (LibsImageDef) <a href="/target/image.gt.go?s=2034:2094#L68">AddNew</a></h3>
				<pre>func (me LibsImageDef) AddNew(id string) (lib *LibImageDefs)</pre>
				<p>
Creates a new *LibImageDefs* library with the specified *ID*, adds it to this *LibsImageDef*, and returns it.
</p>
<p>
If this *LibsImageDef* already contains a *LibImageDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsMaterialDef">type <a href="/target/material.gt.go?s=1304:1352#L46">LibsMaterialDef</a></h2>
			<pre>type LibsMaterialDef map[string]*LibMaterialDefs</pre>
			<p>
The underlying type of the global *AllMaterialDefLibs* variable: a *map* collection that contains
*LibMaterialDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsMaterialDef.AddNew">func (LibsMaterialDef) <a href="/target/material.gt.go?s=1608:1674#L51">AddNew</a></h3>
				<pre>func (me LibsMaterialDef) AddNew(id string) (lib *LibMaterialDefs)</pre>
				<p>
Creates a new *LibMaterialDefs* library with the specified *ID*, adds it to this *LibsMaterialDef*, and returns it.
</p>
<p>
If this *LibsMaterialDef* already contains a *LibMaterialDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsNodeDef">type <a href="/target/node.gt.go?s=1629:1669#L59">LibsNodeDef</a></h2>
			<pre>type LibsNodeDef map[string]*LibNodeDefs</pre>
			<p>
The underlying type of the global *AllNodeDefLibs* variable: a *map* collection that contains
*LibNodeDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsNodeDef.AddNew">func (LibsNodeDef) <a href="/target/node.gt.go?s=1909:1967#L64">AddNew</a></h3>
				<pre>func (me LibsNodeDef) AddNew(id string) (lib *LibNodeDefs)</pre>
				<p>
Creates a new *LibNodeDefs* library with the specified *ID*, adds it to this *LibsNodeDef*, and returns it.
</p>
<p>
If this *LibsNodeDef* already contains a *LibNodeDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="LibsVisualSceneDef">type <a href="/target/visualscene.gt.go?s=1594:1648#L48">LibsVisualSceneDef</a></h2>
			<pre>type LibsVisualSceneDef map[string]*LibVisualSceneDefs</pre>
			<p>
The underlying type of the global *AllVisualSceneDefLibs* variable: a *map* collection that contains
*LibVisualSceneDefs* libraries associated by their *ID*.
</p>


			

			

			

			

			
				
				<h3 id="LibsVisualSceneDef.AddNew">func (LibsVisualSceneDef) <a href="/target/visualscene.gt.go?s=1916:1988#L53">AddNew</a></h3>
				<pre>func (me LibsVisualSceneDef) AddNew(id string) (lib *LibVisualSceneDefs)</pre>
				<p>
Creates a new *LibVisualSceneDefs* library with the specified *ID*, adds it to this *LibsVisualSceneDef*, and returns it.
</p>
<p>
If this *LibsVisualSceneDef* already contains a *LibVisualSceneDefs* library with the specified *ID*, does nothing and returns *nil*.
</p>

				
				
			
		
			
			
			<h2 id="MaterialDef">type <a href="/target/material.gt.go?s=124:160#L1">MaterialDef</a></h2>
			<pre>type MaterialDef struct {
    BaseDef
}</pre>
			<p>
Defines the equations necessary for the visual appearance of geometry and screen-space image processing.
</p>


			

			

			

			

			
				
				<h3 id="MaterialDef.NewInst">func (*MaterialDef) <a href="/target/material.gt.go?s=640:702#L22">NewInst</a></h3>
				<pre>func (me *MaterialDef) NewInst(id string) (inst *MaterialInst)</pre>
				<p>
Creates and returns a new *MaterialInst* instance referencing this *MaterialDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="MaterialInst">type <a href="/target/material.gt.go?s=247:361#L2">MaterialInst</a></h2>
			<pre>type MaterialInst struct {
    BaseInst

    <span class="comment">//	The material definition referenced by this instance.</span>
    Def *MaterialDef
}</pre>
			<p>
An instance referencing a material definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshData">type <a href="/target/meshdata.go?s=1164:1387#L40">MeshData</a></h2>
			<pre>type MeshData struct {
    <span class="comment">//	Vertex positions</span>
    Positions []MeshVertAtt3
    <span class="comment">//	Vertex texture coordinates</span>
    TexCoords []MeshVertAtt2
    <span class="comment">//	Vertex normals</span>
    Normals []MeshVertAtt3
    <span class="comment">//	Indexed triangle definitions</span>
    Faces []MeshFace3
}</pre>
			<p>
Represents yet-unprocessed mesh source data.
</p>


			

			

			

			
				
				<h3 id="NewMeshData">func <a href="/target/meshdata.go?s=1443:1476#L52">NewMeshData</a></h3>
				<pre>func NewMeshData() (me *MeshData)</pre>
				<p>
Initializes and returns a new *MeshData* instance.
</p>

				
			

			
				
				<h3 id="MeshData.AddFaces">func (*MeshData) <a href="/target/meshdata.go?s=1554:1602#L58">AddFaces</a></h3>
				<pre>func (me *MeshData) AddFaces(faces ...MeshFace3)</pre>
				<p>
Adds all specified Faces to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddNormals">func (*MeshData) <a href="/target/meshdata.go?s=1865:1920#L68">AddNormals</a></h3>
				<pre>func (me *MeshData) AddNormals(normals ...MeshVertAtt3)</pre>
				<p>
Adds all the specified Normals to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddPositions">func (*MeshData) <a href="/target/meshdata.go?s=1697:1756#L63">AddPositions</a></h3>
				<pre>func (me *MeshData) AddPositions(positions ...MeshVertAtt3)</pre>
				<p>
Adds all specified Positions to this MeshData.
</p>

				
				
			
				
				<h3 id="MeshData.AddTexCoords">func (*MeshData) <a href="/target/meshdata.go?s=2025:2084#L73">AddTexCoords</a></h3>
				<pre>func (me *MeshData) AddTexCoords(texCoords ...MeshVertAtt2)</pre>
				<p>
Adds all the specified TexCoords to this MeshData.
</p>

				
				
			
		
			
			
			<h2 id="MeshFace3">type <a href="/target/meshdata.go?s=140:166#L1">MeshFace3</a></h2>
			<pre>type MeshFace3 [3]MeshVert</pre>
			<p>
Represents an indexed triangle.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshProvider">type <a href="/target/meshdata.go?s=41:103#L1">MeshProvider</a></h2>
			<pre>type MeshProvider func(args ...interface{}) (*MeshData, error)</pre>
			<p>
Temporary concoction.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRaw">type <a href="/target/meshdata.go?s=255:400#L1">MeshRaw</a></h2>
			<pre>type MeshRaw struct {
    <span class="comment">//	Raw vertices</span>
    MeshVerts []float32
    <span class="comment">//	Vertex indices</span>
    Indices []uint32
    <span class="comment">//	Raw face definitions</span>
    Faces []*MeshRawFace
}</pre>
			<p>
Represents semi-processed loaded mesh data &#34;almost ready&#34; to core.Mesh.GpuUpload().
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshRawFace">type <a href="/target/meshdata.go?s=450:532#L10">MeshRawFace</a></h2>
			<pre>type MeshRawFace struct {
    <span class="comment">//	Indices of the triangle corners</span>
    Entries [3]uint32
}</pre>
			<p>
Represents a triangle face inside a MeshRaw.
</p>


			

			

			

			
				
				<h3 id="NewMeshRawFace">func <a href="/target/meshdata.go?s=591:630#L16">NewMeshRawFace</a></h3>
				<pre>func NewMeshRawFace() (me *MeshRawFace)</pre>
				<p>
Initializes and returns a new *MeshRawFace* instance.
</p>

				
			

			
		
			
			
			<h2 id="MeshVert">type <a href="/target/meshdata.go?s=698:885#L22">MeshVert</a></h2>
			<pre>type MeshVert struct {
    <span class="comment">//	Index of the vertex position</span>
    PosIndex uint32

    <span class="comment">//	Index of the texture-coordinate.</span>
    TexCoordIndex uint32

    <span class="comment">//	Index of the vertex normal.</span>
    NormalIndex uint32
}</pre>
			<p>
Represents an indexed vertex.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt2">type <a href="/target/meshdata.go?s=974:1002#L34">MeshVertAtt2</a></h2>
			<pre>type MeshVertAtt2 [2]float32</pre>
			<p>
Represents a 2-component vertex attribute (such as for example texture-coordinates)
</p>


			

			

			

			

			
		
			
			
			<h2 id="MeshVertAtt3">type <a href="/target/meshdata.go?s=1086:1114#L37">MeshVertAtt3</a></h2>
			<pre>type MeshVertAtt3 [3]float32</pre>
			<p>
Represents a 3-component vertex attribute (such as for example vertex-normals)
</p>


			

			

			

			

			
		
			
			
			<h2 id="NodeDef">type <a href="/target/node.gt.go?s=271:554#L1">NodeDef</a></h2>
			<pre>type NodeDef struct {
    BaseDef
    HasSid

    <span class="comment">//	The names of the layers to which this Node belongs.</span>
    Layers map[string]bool

    <span class="comment">//	Allows the Node to recursively define hierarchy.</span>
    NodeDefs []*NodeDef

    <span class="comment">//	Allows the Node to instantiate a hierarchy of other Nodes.</span>
    NodeInsts []*NodeInst
}</pre>
			<p>
A Node embodies the hierarchical relationship of elements in a Scene by declaring a point of
interest in a Scene. A Node denotes one point on a branch of the Scene graph. The Node is
essentially the root of a sub-graph of the entire Scene graph.
</p>


			

			

			

			

			
				
				<h3 id="NodeDef.NewInst">func (*NodeDef) <a href="/target/node.gt.go?s=1017:1071#L35">NewInst</a></h3>
				<pre>func (me *NodeDef) NewInst(id string) (inst *NodeInst)</pre>
				<p>
Creates and returns a new *NodeInst* instance referencing this *NodeDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="NodeInst">type <a href="/target/node.gt.go?s=664:766#L15">NodeInst</a></h2>
			<pre>type NodeInst struct {
    BaseInst

    <span class="comment">//	The Node definition referenced by this instance.</span>
    Def *NodeDef
}</pre>
			<p>
An instance referencing a Node definition.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Sampler">type <a href="/target/sampler.go?s=1041:1143#L37">Sampler</a></h2>
			<pre>type Sampler struct {
    Image     *ImageInst
    Filtering *SamplerFiltering
    Wrapping  *SamplerWrapping
}</pre>
			

			

			

			

			
				
				<h3 id="NewSampler">func <a href="/target/sampler.go?s=1145:1176#L43">NewSampler</a></h3>
				<pre>func NewSampler() (me *Sampler)</pre>
				
				
			

			
		
			
			
			<h2 id="SamplerFiltering">type <a href="/target/sampler.go?s=787:948#L25">SamplerFiltering</a></h2>
			<pre>type SamplerFiltering struct {
    Mag, Min, Mip            int
    MaxAnisotropy            uint32
    MipMaxLevel, MipMinLevel uint8
    MipBias                  float64
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="SamplerWrapping">type <a href="/target/sampler.go?s=950:1039#L32">SamplerWrapping</a></h2>
			<pre>type SamplerWrapping struct {
    BorderColor         ugfx.Rgba32
    WrapS, WrapT, WrapP int
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Scene">type <a href="/target/scene.go?s=221:325#L1">Scene</a></h2>
			<pre>type Scene struct {
    <span class="comment">//	The Visual Scene associated with this Scene.</span>
    VisualSceneInst *VisualSceneInst
}</pre>
			<p>
Declares a complete, self-contained base of a Scene hierarchy or Scene graph. Currently just defined by a
Visual Scene, later to be augmented by optional &#34;kinematics scenes&#34; and/or &#34;physics scenes&#34;.
</p>


			

			

			

			

			
		
			
			
			<h2 id="VisualSceneDef">type <a href="/target/visualscene.gt.go?s=334:373#L1">VisualSceneDef</a></h2>
			<pre>type VisualSceneDef struct {
    BaseDef
}</pre>
			<p>
Embodies the entire set of information that can be visualized from the contents of the *Lib* libraries.
The hierarchical structure of the Visual Scene is organized into a scene graph. A scene graph is a
directed acyclic graph or tree data structure that contains nodes of visual information and related data.
</p>


			

			

			

			

			
				
				<h3 id="VisualSceneDef.NewInst">func (*VisualSceneDef) <a href="/target/visualscene.gt.go?s=891:959#L24">NewInst</a></h3>
				<pre>func (me *VisualSceneDef) NewInst(id string) (inst *VisualSceneInst)</pre>
				<p>
Creates and returns a new *VisualSceneInst* instance referencing this *VisualSceneDef* definition.
</p>

				
				
			
		
			
			
			<h2 id="VisualSceneInst">type <a href="/target/visualscene.gt.go?s=467:591#L4">VisualSceneInst</a></h2>
			<pre>type VisualSceneInst struct {
    BaseInst

    <span class="comment">//	The Visual Scene definition referenced by this instance.</span>
    Def *VisualSceneDef
}</pre>
			<p>
An instance referencing a Visual Scene definition.
</p>


			

			

			

			

			
		
		</div>
	

	







	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		<tr>
		<td><a href="..">..</a></td>
		</tr>
	
	
		
			<tr>
			<td class="name"><a href="collada/">collada</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto"></td>
			</tr>
		
	
	</table>
	


		</div></div>
	</body>
</html>