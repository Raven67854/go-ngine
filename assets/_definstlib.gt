package gt

func new__T__Def(id string) (me *__T__Def) {
	me = &__T__Def{}
	me.ID = id
	me.Base.init()
	me.Init()
	return
}

/*
//	Creates and returns a new *__T__Inst* instance referencing this *__T__Def* definition.
func (me *__T__Def) NewInst(id string) (inst *__T__Inst) {
	inst = &__T__Inst{Def: me}
	inst.Init()
	return
}
*/

var (
	//	A *map* collection that contains *Lib__T__Defs* libraries associated by their *ID*.
	All__T__DefLibs = Libs__T__Def{}

	//	The "default" *Lib__T__Defs* library for *__T__Def*s.
	__T__Defs = All__T__DefLibs.AddNew("")
)

func init() {
	syncHandlers = append(syncHandlers, func() {
		for _, lib := range All__T__DefLibs {
			lib.SyncChanges()
		}
	})
}

//	The underlying type of the global *All__T__DefLibs* variable: a *map* collection that contains
//	*Lib__T__Defs* libraries associated by their *ID*.
type Libs__T__Def map[string]*Lib__T__Defs

//	Creates a new *Lib__T__Defs* library with the specified *ID*, adds it to this *Libs__T__Def*, and returns it.
//	
//	If this *Libs__T__Def* already contains a *Lib__T__Defs* library with the specified *ID*, does nothing and returns *nil*.
func (me Libs__T__Def) AddNew(id string) (lib *Lib__T__Defs) {
	if me[id] != nil {
		return
	}
	lib = me.new(id)
	me[id] = lib
	return
}

func (me Libs__T__Def) new(id string) (lib *Lib__T__Defs) {
	lib = newLib__T__Defs(id)
	return
}

//	A library that contains *__T__Def*s associated by their *ID*. To create a new *Lib__T__Defs* library, ONLY
//	use the *Libs__T__Def.New()* or *Libs__T__Def.AddNew()* methods.
type Lib__T__Defs struct {
	BaseLib
	//	The underlying *map* collection. NOTE: this is for easier read-access and range-iteration -- DO NOT
	//	write to *M*, instead use the *Add()*, *AddNew()*, *Remove()* methods ONLY or bugs WILL ensue.
	M map[string]*__T__Def
}

func newLib__T__Defs(id string) (me *Lib__T__Defs) {
	me = &Lib__T__Defs{M: map[string]*__T__Def{}}
	me.ID = id
	return
}

//	Adds the specified *__T__Def* definition to this *Lib__T__Defs*, and returns it.
//	
//	If this *Lib__T__Defs* already contains a *__T__Def* definition with the same *ID*, does nothing and returns *nil*.
func (me *Lib__T__Defs) Add(d *__T__Def) (n *__T__Def) {
	if me.M[d.ID] == nil {
		n, me.M[d.ID] = d, d
		me.SetDirty()
	}
	return
}

//	Creates a new *__T__Def* definition with the specified *ID*, adds it to this *Lib__T__Defs*, and returns it.
//	
//	If this *Lib__T__Defs* already contains a *__T__Def* definition with the specified *ID*, does nothing and returns *nil*.
func (me *Lib__T__Defs) AddNew(id string) *__T__Def { return me.Add(me.New(id)) }

//	Creates a new *__T__Def* definition with the specified *ID* and returns it, but does not add it to this *Lib__T__Defs*.
func (me *Lib__T__Defs) New(id string) (def *__T__Def) { def = new__T__Def(id); return }

//	Removes the *__T__Def* with the specified *ID* from this *Lib__T__Defs*.
func (me *Lib__T__Defs) Remove(id string) { delete(me.M, id); me.SetDirty() }

//	Signals to *core* (or your custom package) that changes have been made to this *Lib__T__Defs* that need to be picked up.
//	Call this after you have made any number of changes to this *Lib__T__Defs* library or its *__T__Def* definitions.
//	Also called by the global *SyncChanges()* function.
func (me *Lib__T__Defs) SyncChanges() {
	me.BaseLib.Base.SyncChanges()
	for _, def := range me.M {
		def.BaseDef.Base.SyncChanges()
	}
}
